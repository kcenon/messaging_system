<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: Distributed Task Queue System - Improvement Plan</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d1/db3/md_docs_2TASK__QUEUE__IMPROVEMENT__PLAN.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Distributed Task Queue System - Improvement Plan</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md2155"></a> </p>
<h1><a class="anchor" id="autotoc_md2156"></a>
Executive Summary</h1>
<p>messaging_system을 **분산 작업 큐 시스템**으로 개선하기 위한 구현 계획입니다.</p>
<p><b>목표</b>: Celery/Sidekiq 수준의 기능을 갖춘 C++ 분산 작업 큐 시스템 구축</p>
<hr  />
<h1><a class="anchor" id="autotoc_md2158"></a>
Phase 1: Task Core (기반 확장)</h1>
<h2><a class="anchor" id="autotoc_md2159"></a>
1.1 Task 정의 확장</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/task.h</code></p>
<p>현재 <code>message</code> 클래스를 확장하여 Task 전용 구조 생성:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>kcenon::messaging::task {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> task_state {</div>
<div class="line">    pending,      <span class="comment">// 대기 중</span></div>
<div class="line">    queued,       <span class="comment">// 큐에 등록됨</span></div>
<div class="line">    running,      <span class="comment">// 실행 중</span></div>
<div class="line">    succeeded,    <span class="comment">// 성공 완료</span></div>
<div class="line">    failed,       <span class="comment">// 실패</span></div>
<div class="line">    retrying,     <span class="comment">// 재시도 중</span></div>
<div class="line">    cancelled,    <span class="comment">// 취소됨</span></div>
<div class="line">    expired       <span class="comment">// 만료됨</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>task_config {</div>
<div class="line">    std::chrono::milliseconds timeout{300000};     <span class="comment">// 5분 기본</span></div>
<div class="line">    <span class="keywordtype">size_t</span> max_retries = 3;</div>
<div class="line">    std::chrono::milliseconds retry_delay{1000};</div>
<div class="line">    <span class="keywordtype">double</span> retry_backoff_multiplier = 2.0;</div>
<div class="line">    message_priority priority = message_priority::normal;</div>
<div class="line">    std::optional&lt;std::chrono::system_clock::time_point&gt; eta;  <span class="comment">// 예약 실행</span></div>
<div class="line">    std::optional&lt;std::chrono::milliseconds&gt; expires;          <span class="comment">// 만료 시간</span></div>
<div class="line">    std::string queue_name = <span class="stringliteral">&quot;default&quot;</span>;                        <span class="comment">// 큐 지정</span></div>
<div class="line">    std::vector&lt;std::string&gt; tags;                             <span class="comment">// 그룹화/필터링</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>task : <span class="keyword">public</span> message {</div>
<div class="line">    std::string task_id_;</div>
<div class="line">    std::string task_name_;           <span class="comment">// 핸들러 식별자 (e.g., &quot;email.send&quot;)</span></div>
<div class="line">    task_state state_ = task_state::pending;</div>
<div class="line">    task_config config_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 실행 추적</span></div>
<div class="line">    <span class="keywordtype">size_t</span> attempt_count_ = 0;</div>
<div class="line">    std::chrono::system_clock::time_point started_at_;</div>
<div class="line">    std::chrono::system_clock::time_point completed_at_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 진행률 (0.0 ~ 1.0)</span></div>
<div class="line">    std::atomic&lt;double&gt; progress_{0.0};</div>
<div class="line">    std::string progress_message_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 결과/에러</span></div>
<div class="line">    std::optional&lt;container_module::value_container&gt; result_;</div>
<div class="line">    std::optional&lt;std::string&gt; error_message_;</div>
<div class="line">    std::optional&lt;std::string&gt; error_traceback_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2160"></a>
1.2 Task Builder</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>task_builder {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    task_builder(<span class="keyword">const</span> std::string&amp; task_name);</div>
<div class="line"> </div>
<div class="line">    task_builder&amp; payload(container_module::value_container payload);</div>
<div class="line">    task_builder&amp; priority(message_priority priority);</div>
<div class="line">    task_builder&amp; timeout(std::chrono::milliseconds timeout);</div>
<div class="line">    task_builder&amp; retries(<span class="keywordtype">size_t</span> max_retries);</div>
<div class="line">    task_builder&amp; queue(<span class="keyword">const</span> std::string&amp; queue_name);</div>
<div class="line">    task_builder&amp; eta(std::chrono::system_clock::time_point execute_at);</div>
<div class="line">    task_builder&amp; countdown(std::chrono::milliseconds delay);</div>
<div class="line">    task_builder&amp; expires(std::chrono::milliseconds expires_in);</div>
<div class="line">    task_builder&amp; tag(<span class="keyword">const</span> std::string&amp; tag);</div>
<div class="line"> </div>
<div class="line">    common::Result&lt;task&gt; build();</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2162"></a>
Phase 2: Worker System</h1>
<h2><a class="anchor" id="autotoc_md2163"></a>
2.1 Task Handler Interface</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/task_handler.h</code></p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">class </span>task_context {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// 진행률 업데이트</span></div>
<div class="line">    <span class="keywordtype">void</span> update_progress(<span class="keywordtype">double</span> progress, <span class="keyword">const</span> std::string&amp; message = <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 체크포인트 저장 (재시도 시 복구용)</span></div>
<div class="line">    <span class="keywordtype">void</span> save_checkpoint(<span class="keyword">const</span> container_module::value_container&amp; state);</div>
<div class="line">    container_module::value_container load_checkpoint() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 하위 작업 생성</span></div>
<div class="line">    common::Result&lt;std::string&gt; spawn_subtask(task subtask);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 취소 확인</span></div>
<div class="line">    <span class="keywordtype">bool</span> is_cancelled() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 로깅</span></div>
<div class="line">    <span class="keywordtype">void</span> log_info(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line">    <span class="keywordtype">void</span> log_warning(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line">    <span class="keywordtype">void</span> log_error(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 현재 작업 정보</span></div>
<div class="line">    <span class="keyword">const</span> task&amp; current_task() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> attempt_number() <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>task_handler_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~task_handler_interface() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 핸들러 이름 (task_name과 매칭)</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string name() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 실행</span></div>
<div class="line">    <span class="keyword">virtual</span> common::Result&lt;container_module::value_container&gt; execute(</div>
<div class="line">        <span class="keyword">const</span> task&amp; t,</div>
<div class="line">        task_context&amp; ctx</div>
<div class="line">    ) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 선택적: 재시도 전 훅</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_retry(<span class="keyword">const</span> task&amp; t, <span class="keywordtype">size_t</span> attempt) {}</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 선택적: 실패 시 훅</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_failure(<span class="keyword">const</span> task&amp; t, <span class="keyword">const</span> std::string&amp; error) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>simple_task_handler = std::function&lt;</div>
<div class="line">    common::Result&lt;container_module::value_container&gt;(</div>
<div class="line">        <span class="keyword">const</span> task&amp;,</div>
<div class="line">        task_context&amp;</div>
<div class="line">    )</div>
<div class="line">&gt;;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2164"></a>
2.2 Worker Pool</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/worker_pool.h</code></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>worker_config {</div>
<div class="line">    <span class="keywordtype">size_t</span> concurrency = std::thread::hardware_concurrency();</div>
<div class="line">    std::vector&lt;std::string&gt; queues = {<span class="stringliteral">&quot;default&quot;</span>};  <span class="comment">// 처리할 큐 목록</span></div>
<div class="line">    std::chrono::milliseconds poll_interval{100};</div>
<div class="line">    <span class="keywordtype">bool</span> prefetch = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> prefetch_count = 10;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>worker_pool {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    worker_pool(</div>
<div class="line">        std::shared_ptr&lt;task_queue&gt; queue,</div>
<div class="line">        std::shared_ptr&lt;result_backend&gt; results,</div>
<div class="line">        worker_config config = {}</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 핸들러 등록</span></div>
<div class="line">    <span class="keywordtype">void</span> register_handler(std::shared_ptr&lt;task_handler_interface&gt; handler);</div>
<div class="line">    <span class="keywordtype">void</span> register_handler(<span class="keyword">const</span> std::string&amp; name, simple_task_handler handler);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 수명주기</span></div>
<div class="line">    common::VoidResult start();</div>
<div class="line">    common::VoidResult stop();</div>
<div class="line">    common::VoidResult shutdown_graceful(std::chrono::milliseconds timeout);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 상태</span></div>
<div class="line">    <span class="keywordtype">bool</span> is_running() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> active_workers() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> idle_workers() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 통계</span></div>
<div class="line">    <span class="keyword">struct </span>worker_statistics {</div>
<div class="line">        uint64_t tasks_processed;</div>
<div class="line">        uint64_t tasks_succeeded;</div>
<div class="line">        uint64_t tasks_failed;</div>
<div class="line">        uint64_t tasks_retried;</div>
<div class="line">        std::chrono::milliseconds avg_execution_time;</div>
<div class="line">        std::chrono::milliseconds max_execution_time;</div>
<div class="line">    };</div>
<div class="line">    worker_statistics get_statistics() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> worker_loop(<span class="keywordtype">size_t</span> worker_id);</div>
<div class="line">    common::VoidResult execute_task(task&amp; t);</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2166"></a>
Phase 3: Task Queue (확장)</h1>
<h2><a class="anchor" id="autotoc_md2167"></a>
3.1 Priority Task Queue</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/task_queue.h</code></p>
<p>기존 <code>message_queue</code> + <code>message_bus</code>를 확장:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>task_queue_config {</div>
<div class="line">    <span class="keywordtype">size_t</span> max_size = 100000;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_persistence = <span class="keyword">false</span>;</div>
<div class="line">    std::string persistence_path;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_delayed_queue = <span class="keyword">true</span>;       <span class="comment">// ETA 지원</span></div>
<div class="line">    std::chrono::milliseconds delayed_poll_interval{1000};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>task_queue {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    task_queue(task_queue_config config = {});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 등록</span></div>
<div class="line">    common::Result&lt;std::string&gt; enqueue(task t);</div>
<div class="line">    common::Result&lt;std::vector&lt;std::string&gt;&gt; enqueue_bulk(std::vector&lt;task&gt; tasks);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 가져오기 (워커용)</span></div>
<div class="line">    common::Result&lt;task&gt; dequeue(</div>
<div class="line">        <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; queue_names,</div>
<div class="line">        std::chrono::milliseconds timeout</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 취소</span></div>
<div class="line">    common::VoidResult cancel(<span class="keyword">const</span> std::string&amp; task_id);</div>
<div class="line">    common::VoidResult cancel_by_tag(<span class="keyword">const</span> std::string&amp; tag);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 조회</span></div>
<div class="line">    common::Result&lt;task&gt; get_task(<span class="keyword">const</span> std::string&amp; task_id) <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> queue_size(<span class="keyword">const</span> std::string&amp; queue_name) <span class="keyword">const</span>;</div>
<div class="line">    std::vector&lt;std::string&gt; list_queues() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 지연 작업 관리 (내부)</span></div>
<div class="line">    <span class="keywordtype">void</span> process_delayed_tasks();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// 큐별 priority queue</span></div>
<div class="line">    std::unordered_map&lt;std::string, std::unique_ptr&lt;message_queue&gt;&gt; queues_;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 지연 작업 (ETA 기반)</span></div>
<div class="line">    <span class="keyword">struct </span>delayed_task {</div>
<div class="line">        task t;</div>
<div class="line">        std::chrono::system_clock::time_point execute_at;</div>
<div class="line">    };</div>
<div class="line">    std::priority_queue&lt;</div>
<div class="line">        delayed_task,</div>
<div class="line">        std::vector&lt;delayed_task&gt;,</div>
<div class="line">        <span class="comment">/* earliest first */</span></div>
<div class="line">    &gt; delayed_queue_;</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2169"></a>
Phase 4: Result Backend</h1>
<h2><a class="anchor" id="autotoc_md2170"></a>
4.1 Result Backend Interface</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/result_backend.h</code></p>
<div class="fragment"><div class="line"><span class="keyword">class </span>result_backend_interface {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~result_backend_interface() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 상태 저장</span></div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult store_state(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; task_id,</div>
<div class="line">        task_state state</div>
<div class="line">    ) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 결과 저장</span></div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult store_result(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; task_id,</div>
<div class="line">        <span class="keyword">const</span> container_module::value_container&amp; result</div>
<div class="line">    ) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 에러 저장</span></div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult store_error(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; task_id,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; error,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; traceback = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">    ) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 진행률 저장</span></div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult store_progress(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; task_id,</div>
<div class="line">        <span class="keywordtype">double</span> progress,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; message = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">    ) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 조회</span></div>
<div class="line">    <span class="keyword">virtual</span> common::Result&lt;task_state&gt; get_state(<span class="keyword">const</span> std::string&amp; task_id) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> common::Result&lt;container_module::value_container&gt; get_result(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; task_id</div>
<div class="line">    ) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> common::Result&lt;double&gt; get_progress(<span class="keyword">const</span> std::string&amp; task_id) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 대기</span></div>
<div class="line">    <span class="keyword">virtual</span> common::Result&lt;container_module::value_container&gt; wait_for_result(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; task_id,</div>
<div class="line">        std::chrono::milliseconds timeout</div>
<div class="line">    ) = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 정리</span></div>
<div class="line">    <span class="keyword">virtual</span> common::VoidResult cleanup_expired(</div>
<div class="line">        std::chrono::milliseconds max_age</div>
<div class="line">    ) = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2171"></a>
4.2 In-Memory Result Backend</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>memory_result_backend : <span class="keyword">public</span> result_backend_interface {</div>
<div class="line">    <span class="keyword">struct </span>task_result {</div>
<div class="line">        task_state state;</div>
<div class="line">        std::optional&lt;container_module::value_container&gt; result;</div>
<div class="line">        std::optional&lt;std::string&gt; error;</div>
<div class="line">        std::optional&lt;std::string&gt; traceback;</div>
<div class="line">        <span class="keywordtype">double</span> progress = 0.0;</div>
<div class="line">        std::string progress_message;</div>
<div class="line">        std::chrono::system_clock::time_point updated_at;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::unordered_map&lt;std::string, task_result&gt; results_;</div>
<div class="line">    <span class="keyword">mutable</span> std::shared_mutex mutex_;</div>
<div class="line">    std::condition_variable_any cv_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2172"></a>
4.3 Redis Result Backend (선택적)</h2>
<div class="fragment"><div class="line"><span class="comment">// network_system 통합 후 구현</span></div>
<div class="line"><span class="keyword">class </span>redis_result_backend : <span class="keyword">public</span> result_backend_interface {</div>
<div class="line">    <span class="comment">// Redis를 통한 분산 결과 저장</span></div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2174"></a>
Phase 5: Task Client (Producer)</h1>
<h2><a class="anchor" id="autotoc_md2175"></a>
5.1 Task Client</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/task_client.h</code></p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">class </span>async_result {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    async_result(</div>
<div class="line">        std::string task_id,</div>
<div class="line">        std::shared_ptr&lt;result_backend_interface&gt; backend</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 ID</span></div>
<div class="line">    <span class="keyword">const</span> std::string&amp; task_id() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 상태 확인</span></div>
<div class="line">    task_state state() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> is_ready() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> is_successful() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> is_failed() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 진행률</span></div>
<div class="line">    <span class="keywordtype">double</span> progress() <span class="keyword">const</span>;</div>
<div class="line">    std::string progress_message() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 결과 조회 (블로킹)</span></div>
<div class="line">    common::Result&lt;container_module::value_container&gt; get(</div>
<div class="line">        std::chrono::milliseconds timeout = std::chrono::milliseconds::max()</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 결과 조회 (콜백)</span></div>
<div class="line">    <span class="keywordtype">void</span> then(</div>
<div class="line">        std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> container_module::value_container&amp;)&gt; on_success,</div>
<div class="line">        std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> std::string&amp;)&gt; on_failure = <span class="keyword">nullptr</span></div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 취소</span></div>
<div class="line">    common::VoidResult revoke();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 자식 작업</span></div>
<div class="line">    std::vector&lt;async_result&gt; children() <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>task_client {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    task_client(</div>
<div class="line">        std::shared_ptr&lt;task_queue&gt; queue,</div>
<div class="line">        std::shared_ptr&lt;result_backend_interface&gt; results</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 즉시 실행</span></div>
<div class="line">    async_result send(task t);</div>
<div class="line">    async_result send(<span class="keyword">const</span> std::string&amp; task_name, container_module::value_container payload);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 지연 실행</span></div>
<div class="line">    async_result send_later(task t, std::chrono::milliseconds delay);</div>
<div class="line">    async_result send_at(task t, std::chrono::system_clock::time_point eta);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 그룹 실행</span></div>
<div class="line">    std::vector&lt;async_result&gt; send_batch(std::vector&lt;task&gt; tasks);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 체인 실행 (순차)</span></div>
<div class="line">    async_result chain(std::vector&lt;task&gt; tasks);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 병렬 실행 후 집계</span></div>
<div class="line">    async_result chord(</div>
<div class="line">        std::vector&lt;task&gt; tasks,</div>
<div class="line">        task callback</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 결과 조회</span></div>
<div class="line">    async_result get_result(<span class="keyword">const</span> std::string&amp; task_id);</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2177"></a>
Phase 6: Scheduler</h1>
<h2><a class="anchor" id="autotoc_md2178"></a>
6.1 Periodic Task Scheduler</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/scheduler.h</code></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>schedule_entry {</div>
<div class="line">    std::string name;                    <span class="comment">// 스케줄 이름</span></div>
<div class="line">    task task_template;                  <span class="comment">// 실행할 작업 템플릿</span></div>
<div class="line">    std::variant&lt;</div>
<div class="line">        std::chrono::seconds,            <span class="comment">// 고정 간격</span></div>
<div class="line">        std::string                      <span class="comment">// Cron 표현식 (e.g., &quot;0 */5 * * *&quot;)</span></div>
<div class="line">    &gt; schedule;</div>
<div class="line">    <span class="keywordtype">bool</span> enabled = <span class="keyword">true</span>;</div>
<div class="line">    std::optional&lt;std::chrono::system_clock::time_point&gt; last_run;</div>
<div class="line">    std::optional&lt;std::chrono::system_clock::time_point&gt; next_run;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>task_scheduler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    task_scheduler(std::shared_ptr&lt;task_client&gt; client);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 스케줄 등록</span></div>
<div class="line">    common::VoidResult add_periodic(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; name,</div>
<div class="line">        task task_template,</div>
<div class="line">        std::chrono::seconds interval</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    common::VoidResult add_cron(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; name,</div>
<div class="line">        task task_template,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; cron_expression</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 스케줄 관리</span></div>
<div class="line">    common::VoidResult remove(<span class="keyword">const</span> std::string&amp; name);</div>
<div class="line">    common::VoidResult enable(<span class="keyword">const</span> std::string&amp; name);</div>
<div class="line">    common::VoidResult disable(<span class="keyword">const</span> std::string&amp; name);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 수명주기</span></div>
<div class="line">    common::VoidResult start();</div>
<div class="line">    common::VoidResult stop();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 조회</span></div>
<div class="line">    std::vector&lt;schedule_entry&gt; list_schedules() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> scheduler_loop();</div>
<div class="line">    std::chrono::system_clock::time_point calculate_next_run(</div>
<div class="line">        <span class="keyword">const</span> schedule_entry&amp; entry</div>
<div class="line">    );</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2180"></a>
Phase 7: Monitoring &amp; Management</h1>
<h2><a class="anchor" id="autotoc_md2181"></a>
7.1 Task Monitor</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/monitor.h</code></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>queue_stats {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">size_t</span> pending_count;</div>
<div class="line">    <span class="keywordtype">size_t</span> running_count;</div>
<div class="line">    <span class="keywordtype">size_t</span> delayed_count;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>worker_info {</div>
<div class="line">    std::string worker_id;</div>
<div class="line">    std::vector&lt;std::string&gt; queues;</div>
<div class="line">    <span class="keywordtype">size_t</span> active_tasks;</div>
<div class="line">    std::chrono::system_clock::time_point last_heartbeat;</div>
<div class="line">    <span class="keywordtype">bool</span> is_healthy;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>task_monitor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    task_monitor(</div>
<div class="line">        std::shared_ptr&lt;task_queue&gt; queue,</div>
<div class="line">        std::shared_ptr&lt;result_backend_interface&gt; results,</div>
<div class="line">        std::shared_ptr&lt;worker_pool&gt; workers = <span class="keyword">nullptr</span></div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 큐 통계</span></div>
<div class="line">    std::vector&lt;queue_stats&gt; get_queue_stats() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 워커 상태</span></div>
<div class="line">    std::vector&lt;worker_info&gt; get_workers() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 조회</span></div>
<div class="line">    std::vector&lt;task&gt; list_active_tasks() <span class="keyword">const</span>;</div>
<div class="line">    std::vector&lt;task&gt; list_pending_tasks(<span class="keyword">const</span> std::string&amp; queue = <span class="stringliteral">&quot;default&quot;</span>) <span class="keyword">const</span>;</div>
<div class="line">    std::vector&lt;task&gt; list_failed_tasks(<span class="keywordtype">size_t</span> limit = 100) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 관리</span></div>
<div class="line">    common::VoidResult cancel_task(<span class="keyword">const</span> std::string&amp; task_id);</div>
<div class="line">    common::VoidResult retry_task(<span class="keyword">const</span> std::string&amp; task_id);</div>
<div class="line">    common::VoidResult purge_queue(<span class="keyword">const</span> std::string&amp; queue_name);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 이벤트 구독</span></div>
<div class="line">    <span class="keywordtype">void</span> on_task_started(std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> task&amp;)&gt; handler);</div>
<div class="line">    <span class="keywordtype">void</span> on_task_completed(std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> task&amp;, <span class="keywordtype">bool</span> success)&gt; handler);</div>
<div class="line">    <span class="keywordtype">void</span> on_task_failed(std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> task&amp;, <span class="keyword">const</span> std::string&amp; error)&gt; handler);</div>
<div class="line">    <span class="keywordtype">void</span> on_worker_offline(std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> std::string&amp; worker_id)&gt; handler);</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2183"></a>
Phase 8: Integration</h1>
<h2><a class="anchor" id="autotoc_md2184"></a>
8.1 통합 서비스 컨테이너</h2>
<p><b>위치</b>: <code>include/kcenon/messaging/task/task_system.h</code></p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>task_system_config {</div>
<div class="line">    task_queue_config queue;</div>
<div class="line">    worker_config worker;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_scheduler = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_monitoring = <span class="keyword">true</span>;</div>
<div class="line">    std::string result_backend_type = <span class="stringliteral">&quot;memory&quot;</span>;  <span class="comment">// &quot;memory&quot;, &quot;redis&quot;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>task_system {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> task_system(task_system_config config = {});</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 수명주기</span></div>
<div class="line">    common::VoidResult start();</div>
<div class="line">    common::VoidResult stop();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 컴포넌트 접근</span></div>
<div class="line">    task_client&amp; client();</div>
<div class="line">    worker_pool&amp; workers();</div>
<div class="line">    task_scheduler&amp; scheduler();</div>
<div class="line">    task_monitor&amp; monitor();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 핸들러 등록 (편의 메서드)</span></div>
<div class="line">    <span class="keywordtype">void</span> register_handler(<span class="keyword">const</span> std::string&amp; name, simple_task_handler handler);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 제출 (편의 메서드)</span></div>
<div class="line">    async_result submit(<span class="keyword">const</span> std::string&amp; task_name, container_module::value_container payload);</div>
<div class="line">};</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2186"></a>
Implementation Roadmap</h1>
<h2><a class="anchor" id="autotoc_md2187"></a>
Sprint 1: Core Task Infrastructure ✅</h2>
<ol type="1">
<li><code>task.h</code> / <code>task.cpp</code> - Task 클래스 구현 ✅</li>
<li><code>task_builder.h</code> - Task 빌더 ✅</li>
<li><code>task_handler.h</code> - 핸들러 인터페이스 ✅</li>
<li><code>task_context.h</code> - 실행 컨텍스트 ✅</li>
</ol>
<h2><a class="anchor" id="autotoc_md2188"></a>
Sprint 2: Queue &amp; Result Backend ✅</h2>
<ol type="1">
<li><code>task_queue.h</code> / <code>task_queue.cpp</code> - 작업 큐 (기존 확장) ✅</li>
<li><code>result_backend.h</code> - 결과 백엔드 인터페이스 ✅</li>
<li><code>memory_result_backend.h/.cpp</code> - 메모리 백엔드 ✅</li>
</ol>
<h2><a class="anchor" id="autotoc_md2189"></a>
Sprint 3: Worker System ✅</h2>
<ol type="1">
<li><code>worker_pool.h</code> / <code>worker_pool.cpp</code> - 워커 풀 ✅</li>
<li>Worker 실행 로직 ✅</li>
<li>재시도 메커니즘 (기존 <code>resilient_transport</code> 패턴 활용) ✅</li>
</ol>
<h2><a class="anchor" id="autotoc_md2190"></a>
Sprint 4: Client &amp; Async Result ✅</h2>
<ol type="1">
<li><code>async_result.h</code> / <code>async_result.cpp</code> - 비동기 결과 ✅</li>
<li><code>task_client.h</code> / <code>task_client.cpp</code> - 클라이언트 ✅</li>
<li>Chain/Chord 패턴 ✅</li>
</ol>
<h2><a class="anchor" id="autotoc_md2191"></a>
Sprint 5: Scheduler ✅</h2>
<ol type="1">
<li><code>scheduler.h</code> / <code>scheduler.cpp</code> - 스케줄러 ✅<ul>
<li>Periodic task scheduling with fixed intervals</li>
<li>Cron-based scheduling with 5-field expressions</li>
<li>Schedule management (add, remove, enable, disable)</li>
<li>Background scheduler loop with efficient waiting (#110)</li>
</ul>
</li>
<li>Cron 파싱 (간단한 구현 또는 라이브러리) ✅<ul>
<li><code>cron_parser.h</code> / <code>cron_parser.cpp</code> - Cron 표현식 파서 (#111)</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md2192"></a>
Sprint 6: Monitoring &amp; System Integration ✅</h2>
<ol type="1">
<li><code>monitor.h</code> / <code>monitor.cpp</code> - 모니터링 ✅</li>
<li><code>task_system.h</code> / <code>task_system.cpp</code> - 통합 파사드 ✅</li>
<li>이벤트 브리지 통합 ✅</li>
</ol>
<h2><a class="anchor" id="autotoc_md2193"></a>
Sprint 7: Testing &amp; Documentation ✅</h2>
<ol type="1">
<li>단위 테스트 (각 컴포넌트) ✅</li>
<li>통합 테스트 ✅</li>
<li>벤치마크 (Issue #119)</li>
<li>문서화 ✅</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md2195"></a>
File Structure</h1>
<div class="fragment"><div class="line">include/kcenon/messaging/</div>
<div class="line">├── task/</div>
<div class="line">│   ├── task.h                    # Task 정의</div>
<div class="line">│   ├── task_builder.h            # Task 빌더</div>
<div class="line">│   ├── task_handler.h            # 핸들러 인터페이스</div>
<div class="line">│   ├── task_context.h            # 실행 컨텍스트</div>
<div class="line">│   ├── task_queue.h              # 작업 큐</div>
<div class="line">│   ├── worker_pool.h             # 워커 풀</div>
<div class="line">│   ├── result_backend.h          # 결과 백엔드 인터페이스</div>
<div class="line">│   ├── memory_result_backend.h   # 메모리 백엔드</div>
<div class="line">│   ├── async_result.h            # 비동기 결과</div>
<div class="line">│   ├── task_client.h             # 클라이언트</div>
<div class="line">│   ├── scheduler.h               # 스케줄러</div>
<div class="line">│   ├── monitor.h                 # 모니터링</div>
<div class="line">│   └── task_system.h             # 통합 파사드</div>
<div class="line">│</div>
<div class="line">src/impl/</div>
<div class="line">├── task/</div>
<div class="line">│   ├── task.cpp</div>
<div class="line">│   ├── task_queue.cpp</div>
<div class="line">│   ├── worker_pool.cpp</div>
<div class="line">│   ├── memory_result_backend.cpp</div>
<div class="line">│   ├── async_result.cpp</div>
<div class="line">│   ├── task_client.cpp</div>
<div class="line">│   ├── scheduler.cpp</div>
<div class="line">│   ├── monitor.cpp</div>
<div class="line">│   └── task_system.cpp</div>
<div class="line">│</div>
<div class="line">test/unit/task/</div>
<div class="line">├── test_task.cpp</div>
<div class="line">├── test_task_queue.cpp</div>
<div class="line">├── test_worker_pool.cpp</div>
<div class="line">├── test_result_backend.cpp</div>
<div class="line">├── test_async_result.cpp</div>
<div class="line">├── test_task_client.cpp</div>
<div class="line">├── test_scheduler.cpp</div>
<div class="line">└── test_monitor.cpp</div>
<div class="line">│</div>
<div class="line">examples/task/</div>
<div class="line">├── simple_worker.cpp             # 기본 워커 예제</div>
<div class="line">├── priority_tasks.cpp            # 우선순위 작업</div>
<div class="line">├── scheduled_tasks.cpp           # 예약 작업</div>
<div class="line">├── chain_workflow.cpp            # 체인 워크플로우</div>
<div class="line">└── monitoring_dashboard.cpp      # 모니터링 예제</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2197"></a>
Usage Example</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/task/task_system.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">using namespace </span>kcenon::messaging::task;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 시스템 초기화</span></div>
<div class="line">    task_system_config config;</div>
<div class="line">    config.worker.concurrency = 4;</div>
<div class="line">    config.worker.queues = {<span class="stringliteral">&quot;default&quot;</span>, <span class="stringliteral">&quot;high-priority&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    task_system system(config);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 핸들러 등록</span></div>
<div class="line">    system.register_handler(<span class="stringliteral">&quot;email.send&quot;</span>, [](<span class="keyword">const</span> task&amp; t, task_context&amp; ctx) {</div>
<div class="line">        <span class="keyword">auto</span> email = t.payload().get&lt;std::string&gt;(<span class="stringliteral">&quot;to&quot;</span>);</div>
<div class="line">        <span class="keyword">auto</span> subject = t.payload().get&lt;std::string&gt;(<span class="stringliteral">&quot;subject&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        ctx.update_progress(0.5, <span class="stringliteral">&quot;Sending email...&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// 이메일 전송 로직</span></div>
<div class="line">        send_email(email, subject);</div>
<div class="line"> </div>
<div class="line">        ctx.update_progress(1.0, <span class="stringliteral">&quot;Done&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        container_module::value_container result;</div>
<div class="line">        result.set(<span class="stringliteral">&quot;status&quot;</span>, <span class="stringliteral">&quot;sent&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> common::Result&lt;container_module::value_container&gt;::success(result);</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 시스템 시작</span></div>
<div class="line">    system.start();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 작업 제출</span></div>
<div class="line">    <span class="keyword">auto</span> result = system.submit(<span class="stringliteral">&quot;email.send&quot;</span>, {</div>
<div class="line">        {<span class="stringliteral">&quot;to&quot;</span>, <span class="stringliteral">&quot;user@example.com&quot;</span>},</div>
<div class="line">        {<span class="stringliteral">&quot;subject&quot;</span>, <span class="stringliteral">&quot;Hello!&quot;</span>}</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 결과 대기</span></div>
<div class="line">    <span class="keyword">auto</span> outcome = result.get(std::chrono::seconds(30));</div>
<div class="line">    <span class="keywordflow">if</span> (outcome.is_ok()) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Email sent: &quot;</span> &lt;&lt; outcome.value().get&lt;std::string&gt;(<span class="stringliteral">&quot;status&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 예약 작업</span></div>
<div class="line">    system.scheduler().add_periodic(</div>
<div class="line">        <span class="stringliteral">&quot;daily-report&quot;</span>,</div>
<div class="line">        task_builder(<span class="stringliteral">&quot;report.generate&quot;</span>).build().value(),</div>
<div class="line">        std::chrono::hours(24)</div>
<div class="line">    );</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// 종료 대기</span></div>
<div class="line">    std::cin.get();</div>
<div class="line">    system.stop();</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md2199"></a>
Reusing Existing Components</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">신규 컴포넌트   </th><th class="markdownTableHeadNone">기존 컴포넌트 활용    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>task</code>   </td><td class="markdownTableBodyNone"><code>message</code> 상속/확장    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>task_queue</code>   </td><td class="markdownTableBodyNone"><code>message_queue</code> + <code>message_bus</code> 확장    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>worker_pool</code>   </td><td class="markdownTableBodyNone"><code>standalone_backend</code> 패턴 참조    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">재시도 로직   </td><td class="markdownTableBodyNone"><code>resilient_transport</code> 로직 재사용    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">배치 처리   </td><td class="markdownTableBodyNone"><code>event_batch_processor</code> 패턴 참조    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">파이프라인   </td><td class="markdownTableBodyNone"><code>message_pipeline</code> 패턴 참조    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">통계   </td><td class="markdownTableBodyNone"><code>message_bus::statistics</code> 패턴 확장    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">이벤트   </td><td class="markdownTableBodyNone"><code>event_bridge</code> 통합   </td></tr>
</table>
<hr  />
<h1><a class="anchor" id="autotoc_md2201"></a>
Key Design Decisions</h1>
<h2><a class="anchor" id="autotoc_md2202"></a>
1. Task는 Message를 상속</h2>
<ul>
<li>기존 메시징 인프라 재사용</li>
<li>pub/sub, routing 등 기존 기능 활용 가능</li>
</ul>
<h2><a class="anchor" id="autotoc_md2203"></a>
2. Result Backend 분리</h2>
<ul>
<li>인메모리 → 분산 (Redis) 교체 용이</li>
<li>테스트 용이성 확보</li>
</ul>
<h2><a class="anchor" id="autotoc_md2204"></a>
3. 핸들러 등록 방식</h2>
<ul>
<li>인터페이스 기반: 복잡한 핸들러</li>
<li>Lambda 기반: 간단한 핸들러</li>
</ul>
<h2><a class="anchor" id="autotoc_md2205"></a>
4. 비동기 우선 설계</h2>
<ul>
<li>모든 작업은 기본적으로 비동기</li>
<li><code>async_result</code>로 결과 조회</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md2207"></a>
Version</h1>
<ul>
<li><b>Plan Version</b>: 0.1.1.0</li>
<li><b>Created</b>: 2025-12-07</li>
<li><b>Completed</b>: 2025-12-10</li>
<li><b>Target messaging_system Version</b>: 0.2.0.0</li>
<li><b>Status</b>: All sprints completed </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
