<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: Troubleshooting Guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d6/dab/md_docs_2guides_2TROUBLESHOOTING.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Troubleshooting Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1009"></a> </p>
<h1><a class="anchor" id="autotoc_md1010"></a>
Table of Contents</h1>
<ol type="1">
<li>FAQ</li>
<li>Debug Techniques</li>
<li>Performance Optimization</li>
<li>Known Issues</li>
<li>Error Messages</li>
<li>Common Problems</li>
</ol>
<h1><a class="anchor" id="autotoc_md1011"></a>
FAQ</h1>
<h2><a class="anchor" id="autotoc_md1012"></a>
General Questions</h2>
<p><b>Q: What are the minimum system requirements?</b> A: The messaging system requires at least 2 CPU cores, 4GB RAM, and 10GB disk space. For production, we recommend 8+ cores, 16GB+ RAM, and SSD storage.</p>
<p><b>Q: Which operating systems are supported?</b> A: Full support for Ubuntu 20.04+, Debian 11+, RHEL/CentOS 8+, macOS 11+. Partial support for Windows 10/11.</p>
<p><b>Q: Can I use this without PostgreSQL?</b> A: Yes, compile with <code>-DUSE_DATABASE=OFF</code>. However, you'll lose persistence and some features.</p>
<p><b>Q: How do I enable Python bindings?</b> A: Build with <code>-DUSE_PYTHON_BINDING=ON</code> and ensure Python 3.8+ development headers are installed.</p>
<p><b>Q: What's the maximum message size?</b> A: Default is 1MB, configurable up to 100MB via <code>max_message_size</code> setting.</p>
<h2><a class="anchor" id="autotoc_md1013"></a>
Performance Questions</h2>
<p><b>Q: How many concurrent connections can it handle?</b> A: Default configuration supports 10,000 connections. With tuning, it can handle 100,000+.</p>
<p><b>Q: What's the typical message throughput?</b> A: On modern hardware: 2.48M messages/sec with lock-free queues, 1.16M/sec with mutex-based queues.</p>
<p><b>Q: How much latency does the system add?</b> A: Sub-microsecond for in-memory operations, 1-5ms for network operations, 5-20ms with persistence.</p>
<p><b>Q: Can it scale horizontally?</b> A: Yes, supports clustering with automatic load balancing and failover.</p>
<h2><a class="anchor" id="autotoc_md1014"></a>
Configuration Questions</h2>
<p><b>Q: Where are configuration files located?</b> A: Default location is <code>/etc/messaging/config.ini</code>. Override with <code>MESSAGING_CONFIG_PATH</code> environment variable.</p>
<p><b>Q: How do I change the listening port?</b> A: Set <code>listen_port</code> in config file or use <code>MESSAGING_PORT</code> environment variable.</p>
<p><b>Q: Can I use environment variables for secrets?</b> A: Yes, use <code>${VAR_NAME}</code> syntax in config files to reference environment variables.</p>
<h1><a class="anchor" id="autotoc_md1015"></a>
Debug Techniques</h1>
<h2><a class="anchor" id="autotoc_md1016"></a>
Enable Debug Logging</h2>
<h3><a class="anchor" id="autotoc_md1017"></a>
Runtime Configuration</h3>
<div class="fragment"><div class="line"># config.ini</div>
<div class="line">[logging]</div>
<div class="line">level = debug</div>
<div class="line">verbose = true</div>
<div class="line">include_source_location = true</div>
<div class="line">include_thread_id = true</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1018"></a>
Environment Variables</h3>
<div class="fragment"><div class="line">export MESSAGING_LOG_LEVEL=debug</div>
<div class="line">export MESSAGING_LOG_VERBOSE=1</div>
<div class="line">export MESSAGING_LOG_FILE=/tmp/messaging_debug.log</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1019"></a>
Programmatic</h3>
<div class="fragment"><div class="line">logger_manager::instance().set_level(log_level::debug);</div>
<div class="line">logger_manager::instance().enable_verbose(<span class="keyword">true</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1020"></a>
Using GDB for Debugging</h2>
<h3><a class="anchor" id="autotoc_md1021"></a>
Attach to Running Process</h3>
<div class="fragment"><div class="line"># Find process ID</div>
<div class="line">ps aux | grep messaging</div>
<div class="line"> </div>
<div class="line"># Attach GDB</div>
<div class="line">sudo gdb -p &lt;pid&gt;</div>
<div class="line"> </div>
<div class="line"># Common GDB commands</div>
<div class="line">(gdb) info threads                    # List all threads</div>
<div class="line">(gdb) thread apply all bt             # Backtrace all threads</div>
<div class="line">(gdb) break MessageProcessor::process # Set breakpoint</div>
<div class="line">(gdb) watch message_count_            # Watch variable</div>
<div class="line">(gdb) print *this                     # Print object state</div>
<div class="line">(gdb) call dump_state()               # Call debug function</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1022"></a>
Debug Core Dumps</h3>
<div class="fragment"><div class="line"># Enable core dumps</div>
<div class="line">ulimit -c unlimited</div>
<div class="line">echo &quot;/tmp/core.%e.%p&quot; | sudo tee /proc/sys/kernel/core_pattern</div>
<div class="line"> </div>
<div class="line"># Run application</div>
<div class="line">./messaging_server</div>
<div class="line"> </div>
<div class="line"># If it crashes, analyze core dump</div>
<div class="line">gdb ./messaging_server /tmp/core.messaging_server.12345</div>
<div class="line">(gdb) bt full                         # Full backtrace</div>
<div class="line">(gdb) info registers                  # Register state</div>
<div class="line">(gdb) frame 0                         # Select frame</div>
<div class="line">(gdb) list                           # Show source code</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1023"></a>
Memory Debugging</h2>
<h3><a class="anchor" id="autotoc_md1024"></a>
Using Valgrind</h3>
<div class="fragment"><div class="line"># Memory leak detection</div>
<div class="line">valgrind --leak-check=full \</div>
<div class="line">         --show-leak-kinds=all \</div>
<div class="line">         --track-origins=yes \</div>
<div class="line">         --verbose \</div>
<div class="line">         ./messaging_server 2&gt;&amp;1 | tee valgrind.log</div>
<div class="line"> </div>
<div class="line"># Analyze results</div>
<div class="line">grep &quot;definitely lost&quot; valgrind.log</div>
<div class="line">grep &quot;indirectly lost&quot; valgrind.log</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1025"></a>
Using AddressSanitizer</h3>
<div class="fragment"><div class="line"># Compile with ASAN</div>
<div class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug \</div>
<div class="line">         -DCMAKE_CXX_FLAGS=&quot;-fsanitize=address -fno-omit-frame-pointer&quot;</div>
<div class="line"> </div>
<div class="line"># Run with ASAN options</div>
<div class="line">ASAN_OPTIONS=verbosity=3:halt_on_error=0:print_stats=1 \</div>
<div class="line">./messaging_server</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1026"></a>
Using HeapTrack</h3>
<div class="fragment"><div class="line"># Record heap usage</div>
<div class="line">heaptrack ./messaging_server</div>
<div class="line"> </div>
<div class="line"># Analyze results</div>
<div class="line">heaptrack_gui heaptrack.messaging_server.12345.gz</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1027"></a>
Network Debugging</h2>
<h3><a class="anchor" id="autotoc_md1028"></a>
TCP Dump</h3>
<div class="fragment"><div class="line"># Capture all traffic on port 8080</div>
<div class="line">sudo tcpdump -i any -w capture.pcap port 8080</div>
<div class="line"> </div>
<div class="line"># Real-time monitoring with filters</div>
<div class="line">sudo tcpdump -i any -A -s0 &#39;port 8080 and (tcp[tcpflags] &amp; tcp-syn != 0)&#39;</div>
<div class="line"> </div>
<div class="line"># Analyze with Wireshark</div>
<div class="line">wireshark capture.pcap</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1029"></a>
Network Statistics</h3>
<div class="fragment"><div class="line"># Connection states</div>
<div class="line">ss -tan | grep :8080</div>
<div class="line"> </div>
<div class="line"># Network statistics</div>
<div class="line">netstat -s | grep -i tcp</div>
<div class="line"> </div>
<div class="line"># Connection tracking</div>
<div class="line">sudo conntrack -L -p tcp --dport 8080</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1030"></a>
Test Connectivity</h3>
<div class="fragment"><div class="line"># Test TCP connection</div>
<div class="line">nc -zv localhost 8080</div>
<div class="line"> </div>
<div class="line"># Test with timeout</div>
<div class="line">timeout 5 nc -zv localhost 8080</div>
<div class="line"> </div>
<div class="line"># Send test message</div>
<div class="line">echo &quot;test message&quot; | nc localhost 8080</div>
<div class="line"> </div>
<div class="line"># Performance test</div>
<div class="line">iperf3 -c localhost -p 8080 -t 10</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1031"></a>
Thread Debugging</h2>
<h3><a class="anchor" id="autotoc_md1032"></a>
Thread Analysis</h3>
<div class="fragment"><div class="line"># Thread count and states</div>
<div class="line">ps -eLf | grep messaging</div>
<div class="line"> </div>
<div class="line"># Thread CPU usage</div>
<div class="line">top -H -p $(pgrep messaging)</div>
<div class="line"> </div>
<div class="line"># Thread stacks</div>
<div class="line">pstack $(pgrep messaging)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1033"></a>
Detect Deadlocks</h3>
<div class="fragment"><div class="line"># Using GDB</div>
<div class="line">gdb -p $(pgrep messaging)</div>
<div class="line">(gdb) info threads</div>
<div class="line">(gdb) thread apply all bt</div>
<div class="line">(gdb) python</div>
<div class="line">&gt;import gdb</div>
<div class="line">&gt;for thread in gdb.inferiors()[0].threads():</div>
<div class="line">&gt;    thread.switch()</div>
<div class="line">&gt;    print(f&quot;Thread {thread.num}: {thread.is_stopped()}&quot;)</div>
<div class="line">&gt;end</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1034"></a>
ThreadSanitizer</h3>
<div class="fragment"><div class="line"># Compile with TSAN</div>
<div class="line">cmake .. -DCMAKE_BUILD_TYPE=Debug \</div>
<div class="line">         -DCMAKE_CXX_FLAGS=&quot;-fsanitize=thread&quot;</div>
<div class="line"> </div>
<div class="line"># Run with TSAN</div>
<div class="line">TSAN_OPTIONS=halt_on_error=0:history_size=7 ./messaging_server</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1035"></a>
Tracing and Profiling</h2>
<h3><a class="anchor" id="autotoc_md1036"></a>
System Tracing with strace</h3>
<div class="fragment"><div class="line"># Trace system calls</div>
<div class="line">strace -f -e trace=network ./messaging_server</div>
<div class="line"> </div>
<div class="line"># Trace file operations</div>
<div class="line">strace -f -e trace=file ./messaging_server</div>
<div class="line"> </div>
<div class="line"># Count system calls</div>
<div class="line">strace -c ./messaging_server</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1037"></a>
Performance Profiling with perf</h3>
<div class="fragment"><div class="line"># Record CPU profile</div>
<div class="line">sudo perf record -F 99 -g ./messaging_server</div>
<div class="line"> </div>
<div class="line"># Generate report</div>
<div class="line">sudo perf report</div>
<div class="line"> </div>
<div class="line"># Real-time monitoring</div>
<div class="line">sudo perf top -p $(pgrep messaging)</div>
<div class="line"> </div>
<div class="line"># Generate flame graph</div>
<div class="line">sudo perf record -F 99 -g --call-graph dwarf ./messaging_server</div>
<div class="line">sudo perf script | ./FlameGraph/stackcollapse-perf.pl | \</div>
<div class="line">    ./FlameGraph/flamegraph.pl &gt; flame.svg</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1038"></a>
Application Tracing</h3>
<div class="fragment"><div class="line"><span class="comment">// Add trace points in code</span></div>
<div class="line"><span class="keyword">class </span>Tracer {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Tracer(<span class="keyword">const</span> std::string&amp; name) : name_(name) {</div>
<div class="line">        start_ = std::chrono::high_resolution_clock::now();</div>
<div class="line">        logger_.trace(<span class="stringliteral">&quot;ENTER: {}&quot;</span>, name_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~Tracer() {</div>
<div class="line">        <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">            end - start_).count();</div>
<div class="line">        logger_.trace(<span class="stringliteral">&quot;EXIT: {} ({}Âµs)&quot;</span>, name_, duration);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::string name_;</div>
<div class="line">    std::chrono::high_resolution_clock::time_point start_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keywordtype">void</span> process_message(<span class="keyword">const</span> Message&amp; msg) {</div>
<div class="line">    Tracer trace(__FUNCTION__);</div>
<div class="line">    <span class="comment">// Function implementation</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1039"></a>
Performance Optimization</h1>
<h2><a class="anchor" id="autotoc_md1040"></a>
CPU Optimization</h2>
<h3><a class="anchor" id="autotoc_md1041"></a>
Identify CPU Bottlenecks</h3>
<div class="fragment"><div class="line"># CPU profiling</div>
<div class="line">perf stat -d ./messaging_server</div>
<div class="line"> </div>
<div class="line"># Cache misses</div>
<div class="line">perf stat -e cache-misses,cache-references ./messaging_server</div>
<div class="line"> </div>
<div class="line"># Branch prediction</div>
<div class="line">perf stat -e branch-misses,branches ./messaging_server</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1042"></a>
Optimization Techniques</h3>
<div class="fragment"><div class="line"><span class="comment">// 1. Use likely/unlikely hints</span></div>
<div class="line"><span class="keywordflow">if</span> (LIKELY(msg.type() == MessageType::NORMAL)) {</div>
<div class="line">    process_normal(msg);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    process_special(msg);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Align data structures</span></div>
<div class="line"><span class="keyword">struct </span><span class="keyword">alignas</span>(64) CacheLinePadded {</div>
<div class="line">    std::atomic&lt;uint64_t&gt; counter;</div>
<div class="line">    <span class="keywordtype">char</span> padding[56];  <span class="comment">// Avoid false sharing</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Prefetch data</span></div>
<div class="line">__builtin_prefetch(&amp;data[i + 1], 0, 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4. Use SIMD instructions</span></div>
<div class="line"><span class="keywordtype">void</span> process_batch(<span class="keywordtype">float</span>* data, <span class="keywordtype">size_t</span> count) {</div>
<div class="line">    <span class="keywordtype">size_t</span> simd_count = count &amp; ~3;  <span class="comment">// Process 4 at a time</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; simd_count; i += 4) {</div>
<div class="line">        __m128 vec = _mm_load_ps(&amp;data[i]);</div>
<div class="line">        vec = _mm_mul_ps(vec, _mm_set1_ps(2.0f));</div>
<div class="line">        _mm_store_ps(&amp;data[i], vec);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Handle remaining elements</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = simd_count; i &lt; count; ++i) {</div>
<div class="line">        data[i] *= 2.0f;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1043"></a>
Memory Optimization</h2>
<h3><a class="anchor" id="autotoc_md1044"></a>
Memory Usage Analysis</h3>
<div class="fragment"><div class="line"># Memory map</div>
<div class="line">pmap -x $(pgrep messaging)</div>
<div class="line"> </div>
<div class="line"># Memory statistics</div>
<div class="line">cat /proc/$(pgrep messaging)/status | grep -E &quot;Vm|Rss&quot;</div>
<div class="line"> </div>
<div class="line"># Heap profile</div>
<div class="line">gprof ./messaging_server gmon.out</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1045"></a>
Optimization Techniques</h3>
<div class="fragment"><div class="line"><span class="comment">// 1. Use memory pools</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>MemoryPool {</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;T[]&gt;&gt; blocks_;</div>
<div class="line">    std::stack&lt;T*&gt; free_list_;</div>
<div class="line">    <span class="keywordtype">size_t</span> block_size_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    T* allocate() {</div>
<div class="line">        <span class="keywordflow">if</span> (free_list_.empty()) {</div>
<div class="line">            allocate_block();</div>
<div class="line">        }</div>
<div class="line">        T* ptr = free_list_.top();</div>
<div class="line">        free_list_.pop();</div>
<div class="line">        <span class="keywordflow">return</span> ptr;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> deallocate(T* ptr) {</div>
<div class="line">        ptr-&gt;~T();</div>
<div class="line">        free_list_.push(ptr);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Reduce allocations</span></div>
<div class="line"><span class="keyword">class </span>MessageBuffer {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> std::vector&lt;char&gt; buffer_;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> std::vector&lt;char&gt;&amp; get() {</div>
<div class="line">        buffer_.clear();</div>
<div class="line">        <span class="keywordflow">return</span> buffer_;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Use string_view for read-only strings</span></div>
<div class="line"><span class="keywordtype">void</span> process(std::string_view data) {</div>
<div class="line">    <span class="comment">// No allocation, just reference</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1046"></a>
I/O Optimization</h2>
<h3><a class="anchor" id="autotoc_md1047"></a>
Disk I/O Analysis</h3>
<div class="fragment"><div class="line"># I/O statistics</div>
<div class="line">iostat -x 1</div>
<div class="line"> </div>
<div class="line"># I/O by process</div>
<div class="line">iotop -p $(pgrep messaging)</div>
<div class="line"> </div>
<div class="line"># File system cache</div>
<div class="line">free -h</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1048"></a>
Optimization Techniques</h3>
<div class="fragment"><div class="line"><span class="comment">// 1. Async I/O</span></div>
<div class="line">boost::asio::async_write(socket, buffer,</div>
<div class="line">    [](error_code ec, <span class="keywordtype">size_t</span> bytes) {</div>
<div class="line">        <span class="comment">// Handle completion</span></div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Buffered I/O</span></div>
<div class="line"><span class="keyword">class </span>BufferedWriter {</div>
<div class="line">    std::vector&lt;char&gt; buffer_;</div>
<div class="line">    <span class="keywordtype">size_t</span> pos_ = 0;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> BUFFER_SIZE = 65536;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> write(<span class="keyword">const</span> <span class="keywordtype">void</span>* data, <span class="keywordtype">size_t</span> size) {</div>
<div class="line">        <span class="keywordflow">if</span> (pos_ + size &gt; BUFFER_SIZE) {</div>
<div class="line">            flush();</div>
<div class="line">        }</div>
<div class="line">        memcpy(&amp;buffer_[pos_], data, size);</div>
<div class="line">        pos_ += size;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> flush() {</div>
<div class="line">        <span class="keywordflow">if</span> (pos_ &gt; 0) {</div>
<div class="line">            ::write(fd_, buffer_.data(), pos_);</div>
<div class="line">            pos_ = 0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Memory-mapped files</span></div>
<div class="line"><span class="keyword">class </span>MappedFile {</div>
<div class="line">    <span class="keywordtype">void</span>* addr_;</div>
<div class="line">    <span class="keywordtype">size_t</span> size_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MappedFile(<span class="keyword">const</span> std::string&amp; path) {</div>
<div class="line">        <span class="keywordtype">int</span> fd = open(path.c_str(), O_RDONLY);</div>
<div class="line">        <span class="keyword">struct </span>stat st;</div>
<div class="line">        fstat(fd, &amp;st);</div>
<div class="line">        size_ = st.st_size;</div>
<div class="line">        addr_ = mmap(<span class="keyword">nullptr</span>, size_, PROT_READ, MAP_PRIVATE, fd, 0);</div>
<div class="line">        close(fd);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~MappedFile() {</div>
<div class="line">        munmap(addr_, size_);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1049"></a>
Network Optimization</h2>
<h3><a class="anchor" id="autotoc_md1050"></a>
Network Analysis</h3>
<div class="fragment"><div class="line"># TCP tuning parameters</div>
<div class="line">sysctl net.ipv4.tcp_wmem</div>
<div class="line">sysctl net.ipv4.tcp_rmem</div>
<div class="line">sysctl net.core.netdev_max_backlog</div>
<div class="line"> </div>
<div class="line"># Network statistics</div>
<div class="line">netstat -s | grep -i tcp</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1051"></a>
Optimization Techniques</h3>
<div class="fragment"><div class="line"><span class="comment">// 1. TCP_NODELAY for low latency</span></div>
<div class="line"><span class="keywordtype">int</span> flag = 1;</div>
<div class="line">setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, &amp;flag, <span class="keyword">sizeof</span>(flag));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Batch messages</span></div>
<div class="line"><span class="keyword">class </span>MessageBatcher {</div>
<div class="line">    std::vector&lt;Message&gt; batch_;</div>
<div class="line">    <span class="keywordtype">size_t</span> max_batch_size_ = 100;</div>
<div class="line">    std::chrono::milliseconds max_wait_{10};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> add(Message msg) {</div>
<div class="line">        batch_.push_back(std::move(msg));</div>
<div class="line">        <span class="keywordflow">if</span> (batch_.size() &gt;= max_batch_size_) {</div>
<div class="line">            send_batch();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> send_batch() {</div>
<div class="line">        <span class="keywordflow">if</span> (!batch_.empty()) {</div>
<div class="line">            network_.send_batch(batch_);</div>
<div class="line">            batch_.clear();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Connection pooling</span></div>
<div class="line"><span class="keyword">class </span>ConnectionPool {</div>
<div class="line">    std::queue&lt;std::unique_ptr&lt;Connection&gt;&gt; idle_;</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::unique_ptr&lt;Connection&gt; acquire() {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        <span class="keywordflow">if</span> (idle_.empty()) {</div>
<div class="line">            <span class="keywordflow">return</span> create_connection();</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">auto</span> conn = std::move(idle_.front());</div>
<div class="line">        idle_.pop();</div>
<div class="line">        <span class="keywordflow">return</span> conn;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> release(std::unique_ptr&lt;Connection&gt; conn) {</div>
<div class="line">        <span class="keywordflow">if</span> (conn-&gt;is_healthy()) {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">            idle_.push(std::move(conn));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1052"></a>
Known Issues</h1>
<h2><a class="anchor" id="autotoc_md1053"></a>
Issue 1: High CPU Usage with Small Messages</h2>
<p><b>Symptoms</b>: CPU usage near 100% when processing many small messages.</p>
<p><b>Cause</b>: Overhead of processing individual messages exceeds payload processing time.</p>
<p><b>Workaround</b>: </p><div class="fragment"><div class="line">[performance]</div>
<div class="line">enable_batching = true</div>
<div class="line">batch_size = 1000</div>
<div class="line">batch_timeout_ms = 10</div>
</div><!-- fragment --><p><b>Fix</b>: Implement message coalescing: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MessageCoalescer {</div>
<div class="line">    std::vector&lt;Message&gt; buffer_;</div>
<div class="line">    std::chrono::steady_clock::time_point last_flush_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> add(Message msg) {</div>
<div class="line">        buffer_.push_back(std::move(msg));</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keywordflow">if</span> (buffer_.size() &gt;= 1000 ||</div>
<div class="line">            now - last_flush_ &gt; std::chrono::milliseconds(10)) {</div>
<div class="line">            flush();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> flush() {</div>
<div class="line">        <span class="keywordflow">if</span> (!buffer_.empty()) {</div>
<div class="line">            process_batch(buffer_);</div>
<div class="line">            buffer_.clear();</div>
<div class="line">            last_flush_ = std::chrono::steady_clock::now();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1054"></a>
Issue 2: Memory Leak in Long-Running Connections</h2>
<p><b>Symptoms</b>: Memory usage grows over time with persistent connections.</p>
<p><b>Cause</b>: Connection buffers not properly cleared on partial reads.</p>
<p><b>Workaround</b>: Restart service periodically or limit connection lifetime.</p>
<p><b>Fix</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Connection {</div>
<div class="line">    <span class="keywordtype">void</span> on_read(<span class="keywordtype">size_t</span> bytes_transferred) {</div>
<div class="line">        <span class="comment">// Process data</span></div>
<div class="line">        process_buffer(read_buffer_, bytes_transferred);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Clear processed data</span></div>
<div class="line">        read_buffer_.consume(bytes_transferred);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Shrink buffer if too large</span></div>
<div class="line">        <span class="keywordflow">if</span> (read_buffer_.capacity() &gt; MAX_BUFFER_SIZE &amp;&amp;</div>
<div class="line">            read_buffer_.size() &lt; MAX_BUFFER_SIZE / 4) {</div>
<div class="line">            read_buffer_.shrink_to_fit();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1055"></a>
Issue 3: Database Connection Pool Exhaustion</h2>
<p><b>Symptoms</b>: "Connection pool exhausted" errors under load.</p>
<p><b>Cause</b>: Connections not returned to pool due to exceptions.</p>
<p><b>Workaround</b>: Increase pool size and add connection timeout.</p>
<p><b>Fix</b>: Use RAII for connection management: </p><div class="fragment"><div class="line"><span class="keyword">class </span>PooledConnection {</div>
<div class="line">    ConnectionPool* pool_;</div>
<div class="line">    std::unique_ptr&lt;Connection&gt; conn_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PooledConnection(ConnectionPool* pool)</div>
<div class="line">        : pool_(pool), conn_(pool-&gt;acquire()) {}</div>
<div class="line"> </div>
<div class="line">    ~PooledConnection() {</div>
<div class="line">        <span class="keywordflow">if</span> (conn_ &amp;&amp; pool_) {</div>
<div class="line">            pool_-&gt;release(std::move(conn_));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Connection* operator-&gt;() { <span class="keywordflow">return</span> conn_.get(); }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">{</div>
<div class="line">    PooledConnection conn(&amp;pool);</div>
<div class="line">    conn-&gt;execute(<span class="stringliteral">&quot;SELECT * FROM messages&quot;</span>);</div>
<div class="line">}  <span class="comment">// Connection automatically returned</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1056"></a>
Issue 4: Deadlock in Message Processing</h2>
<p><b>Symptoms</b>: System hangs, threads waiting on locks.</p>
<p><b>Cause</b>: Lock ordering violation between queue and handler locks.</p>
<p><b>Workaround</b>: Increase lock timeout and add deadlock detection.</p>
<p><b>Fix</b>: Use lock-free queue or consistent lock ordering: </p><div class="fragment"><div class="line"><span class="comment">// Lock ordering: always acquire in this order</span></div>
<div class="line"><span class="comment">// 1. queue_mutex_</span></div>
<div class="line"><span class="comment">// 2. handler_mutex_</span></div>
<div class="line"><span class="comment">// 3. state_mutex_</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MessageProcessor {</div>
<div class="line">    <span class="keywordtype">void</span> process() {</div>
<div class="line">        Message msg;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Acquire and release queue lock</span></div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">            <span class="keywordflow">if</span> (queue_.empty()) <span class="keywordflow">return</span>;</div>
<div class="line">            msg = queue_.front();</div>
<div class="line">            queue_.pop();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Process without holding queue lock</span></div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(handler_mutex_);</div>
<div class="line">            handler_-&gt;process(msg);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1057"></a>
Issue 5: Performance Degradation with Many Topics</h2>
<p><b>Symptoms</b>: Slow message routing with 1000+ topics.</p>
<p><b>Cause</b>: Linear search through topic list for pattern matching.</p>
<p><b>Workaround</b>: Limit number of topics or use exact matching.</p>
<p><b>Fix</b>: Use trie for efficient topic matching: </p><div class="fragment"><div class="line"><span class="keyword">class </span>TopicTrie {</div>
<div class="line">    <span class="keyword">struct </span>Node {</div>
<div class="line">        std::unordered_map&lt;std::string, std::unique_ptr&lt;Node&gt;&gt; children;</div>
<div class="line">        std::vector&lt;Handler&gt; handlers;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;Node&gt; root_ = std::make_unique&lt;Node&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> subscribe(<span class="keyword">const</span> std::string&amp; topic, Handler handler) {</div>
<div class="line">        <span class="keyword">auto</span> parts = split(topic, <span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line">        Node* node = root_.get();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; part : parts) {</div>
<div class="line">            <span class="keywordflow">if</span> (!node-&gt;children[part]) {</div>
<div class="line">                node-&gt;children[part] = std::make_unique&lt;Node&gt;();</div>
<div class="line">            }</div>
<div class="line">            node = node-&gt;children[part].get();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        node-&gt;handlers.push_back(handler);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Handler&gt; match(<span class="keyword">const</span> std::string&amp; topic) {</div>
<div class="line">        <span class="comment">// Efficient O(n) matching where n is topic length</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1058"></a>
Error Messages</h1>
<h2><a class="anchor" id="autotoc_md1059"></a>
Connection Errors</h2>
<h3><a class="anchor" id="autotoc_md1060"></a>
"Connection refused"</h3>
<div class="fragment"><div class="line">Error: Connection refused to localhost:8080</div>
</div><!-- fragment --><p><b>Causes</b>:</p><ul>
<li>Service not running</li>
<li>Wrong port number</li>
<li>Firewall blocking connection</li>
</ul>
<p><b>Solutions</b>: </p><div class="fragment"><div class="line"># Check if service is running</div>
<div class="line">systemctl status messaging-system</div>
<div class="line"> </div>
<div class="line"># Check if port is listening</div>
<div class="line">netstat -tlnp | grep 8080</div>
<div class="line"> </div>
<div class="line"># Check firewall</div>
<div class="line">sudo iptables -L -n | grep 8080</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1061"></a>
"Connection timeout"</h3>
<div class="fragment"><div class="line">Error: Connection timeout after 5000ms</div>
</div><!-- fragment --><p><b>Causes</b>:</p><ul>
<li>Network issues</li>
<li>Server overloaded</li>
<li>Timeout too short</li>
</ul>
<p><b>Solutions</b>: </p><div class="fragment"><div class="line">[network]</div>
<div class="line">connection_timeout_ms = 30000</div>
<div class="line">keepalive_enabled = true</div>
<div class="line">keepalive_interval_s = 30</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1062"></a>
Database Errors</h2>
<h3><a class="anchor" id="autotoc_md1063"></a>
"Database connection failed"</h3>
<div class="fragment"><div class="line">Error: Failed to connect to database: FATAL: password authentication failed</div>
</div><!-- fragment --><p><b>Solutions</b>: </p><div class="fragment"><div class="line"># Check PostgreSQL is running</div>
<div class="line">systemctl status postgresql</div>
<div class="line"> </div>
<div class="line"># Test connection</div>
<div class="line">psql -h localhost -U messaging_user -d messaging</div>
<div class="line"> </div>
<div class="line"># Check pg_hba.conf</div>
<div class="line">sudo vi /etc/postgresql/14/main/pg_hba.conf</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1064"></a>
"Deadlock detected"</h3>
<div class="fragment"><div class="line">Error: Database deadlock detected, transaction rolled back</div>
</div><!-- fragment --><p><b>Solutions</b>: </p><div class="fragment"><div class="line"><span class="comment">// Retry with exponential backoff</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> retry = 0; retry &lt; 3; ++retry) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        db.execute_transaction([]() {</div>
<div class="line">            <span class="comment">// Transaction code</span></div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> deadlock_exception&amp; e) {</div>
<div class="line">        std::this_thread::sleep_for(</div>
<div class="line">            std::chrono::milliseconds(100 * (1 &lt;&lt; retry)));</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1065"></a>
Memory Errors</h2>
<h3><a class="anchor" id="autotoc_md1066"></a>
"Out of memory"</h3>
<div class="fragment"><div class="line">Error: Failed to allocate 1048576 bytes</div>
</div><!-- fragment --><p><b>Solutions</b>: </p><div class="fragment"><div class="line"># Check memory usage</div>
<div class="line">free -h</div>
<div class="line">ps aux --sort=-rss | head</div>
<div class="line"> </div>
<div class="line"># Increase limits</div>
<div class="line">ulimit -v unlimited</div>
<div class="line"> </div>
<div class="line"># Adjust configuration</div>
<div class="line">echo &quot;vm.overcommit_memory = 1&quot; &gt;&gt; /etc/sysctl.conf</div>
<div class="line">sysctl -p</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1067"></a>
"Segmentation fault"</h3>
<div class="fragment"><div class="line">Segmentation fault (core dumped)</div>
</div><!-- fragment --><p><b>Debugging</b>: </p><div class="fragment"><div class="line"># Enable core dumps</div>
<div class="line">ulimit -c unlimited</div>
<div class="line"> </div>
<div class="line"># Analyze core dump</div>
<div class="line">gdb ./messaging_server core</div>
<div class="line">(gdb) bt</div>
<div class="line">(gdb) info registers</div>
<div class="line">(gdb) x/10x $rsp</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1068"></a>
Common Problems</h1>
<h2><a class="anchor" id="autotoc_md1069"></a>
Problem: Service Won't Start</h2>
<p><b>Symptoms</b>: Service fails to start, exits immediately.</p>
<p><b>Diagnosis</b>: </p><div class="fragment"><div class="line"># Check logs</div>
<div class="line">journalctl -u messaging-system -n 50</div>
<div class="line"> </div>
<div class="line"># Run manually</div>
<div class="line">/usr/local/bin/messaging_server --debug</div>
<div class="line"> </div>
<div class="line"># Validate configuration</div>
<div class="line">/usr/local/bin/messaging_server --validate-config</div>
</div><!-- fragment --><p><b>Common Causes</b>:</p><ol type="1">
<li>Port already in use</li>
<li>Invalid configuration</li>
<li>Missing dependencies</li>
<li>Permission issues</li>
</ol>
<p><b>Solutions</b>: </p><div class="fragment"><div class="line"># Kill process using port</div>
<div class="line">sudo fuser -k 8080/tcp</div>
<div class="line"> </div>
<div class="line"># Fix permissions</div>
<div class="line">sudo chown -R messaging:messaging /var/lib/messaging</div>
<div class="line">sudo chmod 755 /var/lib/messaging</div>
<div class="line"> </div>
<div class="line"># Install missing dependencies</div>
<div class="line">ldd /usr/local/bin/messaging_server | grep &quot;not found&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1070"></a>
Problem: Slow Message Processing</h2>
<p><b>Symptoms</b>: High latency, messages queuing up.</p>
<p><b>Diagnosis</b>: </p><div class="fragment"><div class="line"># Check queue size</div>
<div class="line">curl http://localhost:9090/metrics | grep queue_size</div>
<div class="line"> </div>
<div class="line"># Monitor processing rate</div>
<div class="line">watch -n 1 &#39;curl -s http://localhost:9090/metrics | grep processed&#39;</div>
<div class="line"> </div>
<div class="line"># Profile CPU usage</div>
<div class="line">perf top -p $(pgrep messaging)</div>
</div><!-- fragment --><p><b>Solutions</b>: </p><div class="fragment"><div class="line">[performance]</div>
<div class="line">worker_threads = 16              # Increase workers</div>
<div class="line">queue_size = 100000             # Larger queue</div>
<div class="line">batch_processing = true         # Enable batching</div>
<div class="line">batch_size = 100</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1071"></a>
Problem: Connection Drops</h2>
<p><b>Symptoms</b>: Clients disconnecting frequently.</p>
<p><b>Diagnosis</b>: </p><div class="fragment"><div class="line"># Check network errors</div>
<div class="line">netstat -s | grep -i error</div>
<div class="line"> </div>
<div class="line"># Monitor connections</div>
<div class="line">watch -n 1 &#39;ss -tan | grep :8080 | wc -l&#39;</div>
<div class="line"> </div>
<div class="line"># Check logs for errors</div>
<div class="line">grep -i &quot;connection.*error&quot; /var/log/messaging/messaging.log</div>
</div><!-- fragment --><p><b>Solutions</b>: </p><div class="fragment"><div class="line">[network]</div>
<div class="line">keepalive_enabled = true</div>
<div class="line">keepalive_interval_s = 30</div>
<div class="line">keepalive_probes = 3</div>
<div class="line">connection_timeout_ms = 60000</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1072"></a>
Problem: High Memory Usage</h2>
<p><b>Symptoms</b>: Memory usage continuously growing.</p>
<p><b>Diagnosis</b>: </p><div class="fragment"><div class="line"># Monitor memory growth</div>
<div class="line">while true; do</div>
<div class="line">    ps aux | grep messaging | grep -v grep</div>
<div class="line">    sleep 10</div>
<div class="line">done</div>
<div class="line"> </div>
<div class="line"># Check for leaks</div>
<div class="line">valgrind --leak-check=full ./messaging_server</div>
</div><!-- fragment --><p><b>Solutions</b>: </p><div class="fragment"><div class="line"><span class="comment">// Enable memory limits</span></div>
<div class="line"><span class="keyword">class </span>MemoryManager {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> MAX_MEMORY = 4UL * 1024 * 1024 * 1024;  <span class="comment">// 4GB</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> check_memory() {</div>
<div class="line">        <span class="keywordflow">if</span> (get_current_usage() &gt; MAX_MEMORY) {</div>
<div class="line">            trigger_cleanup();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1073"></a>
Problem: Database Bottleneck</h2>
<p><b>Symptoms</b>: Database queries slow, connection pool exhausted.</p>
<p><b>Diagnosis</b>: </p><div class="fragment"><div class="line"><span class="comment">-- Check slow queries</span></div>
<div class="line"><span class="keyword">SELECT</span> query, calls, mean_exec_time</div>
<div class="line"><span class="keyword">FROM</span> pg_stat_statements</div>
<div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> mean_exec_time DESC</div>
<div class="line">LIMIT <span class="stringliteral">10</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- Check connections</span></div>
<div class="line"><span class="keyword">SELECT</span> count(*) <span class="keyword">FROM</span> pg_stat_activity;</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- Check locks</span></div>
<div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pg_locks <span class="keyword">WHERE</span> granted = <span class="stringliteral">false</span>;</div>
</div><!-- fragment --><p><b>Solutions</b>:</p><ol type="1">
<li>Add indexes</li>
<li>Increase connection pool</li>
<li>Enable query caching</li>
<li>Use read replicas</li>
</ol>
<div class="fragment"><div class="line"><span class="comment">-- Add indexes</span></div>
<div class="line"><span class="keyword">CREATE</span> INDEX idx_messages_timestamp <span class="keyword">ON</span> messages(<span class="keywordtype">timestamp</span>);</div>
<div class="line"><span class="keyword">CREATE</span> INDEX idx_messages_topic <span class="keyword">ON</span> messages(topic);</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- Analyze tables</span></div>
<div class="line">ANALYZE messages;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
