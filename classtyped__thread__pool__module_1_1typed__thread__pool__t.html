<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: typed_thread_pool_module::typed_thread_pool_t&lt; job_type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-performance messaging system with lock-free thread pools</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classtyped__thread__pool__module_1_1typed__thread__pool__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classtyped__thread__pool__module_1_1typed__thread__pool__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">typed_thread_pool_module::typed_thread_pool_t&lt; job_type &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A thread pool that schedules and executes jobs based on their priority levels.  
 <a href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="typed__thread__pool_8h_source.html">typed_thread_pool.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for typed_thread_pool_module::typed_thread_pool_t&lt; job_type &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtyped__thread__pool__module_1_1typed__thread__pool__t.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af67bf203272157f39cb877e064c96457" id="r_af67bf203272157f39cb877e064c96457"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#af67bf203272157f39cb877e064c96457">typed_thread_pool_t</a> (const std::string &amp;thread_title=&quot;typed_thread_pool&quot;, const <a class="el" href="classthread__module_1_1thread__context.html">thread_context</a> &amp;context=<a class="el" href="classthread__module_1_1thread__context.html">thread_context</a>())</td></tr>
<tr class="memdesc:af67bf203272157f39cb877e064c96457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html" title="A thread pool that schedules and executes jobs based on their priority levels.">typed_thread_pool_t</a> instance.  <br /></td></tr>
<tr class="separator:af67bf203272157f39cb877e064c96457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bff9ee6c0bb5a30c6f02c152835465" id="r_a74bff9ee6c0bb5a30c6f02c152835465"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#a74bff9ee6c0bb5a30c6f02c152835465">~typed_thread_pool_t</a> (void)</td></tr>
<tr class="memdesc:a74bff9ee6c0bb5a30c6f02c152835465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html" title="A thread pool that schedules and executes jobs based on their priority levels.">typed_thread_pool_t</a> object.  <br /></td></tr>
<tr class="separator:a74bff9ee6c0bb5a30c6f02c152835465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66103fba1d3ba8d90051c1d692cbf45" id="r_ac66103fba1d3ba8d90051c1d692cbf45"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#ac66103fba1d3ba8d90051c1d692cbf45">get_ptr</a> (void) -&gt; std::shared_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_t</a>&lt; job_type &gt; &gt;</td></tr>
<tr class="memdesc:ac66103fba1d3ba8d90051c1d692cbf45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a shared pointer to the current <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html" title="A thread pool that schedules and executes jobs based on their priority levels.">typed_thread_pool_t</a>.  <br /></td></tr>
<tr class="separator:ac66103fba1d3ba8d90051c1d692cbf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c83030818a61aa827fb454aec77202" id="r_ad1c83030818a61aa827fb454aec77202"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#ad1c83030818a61aa827fb454aec77202">start</a> (void) -&gt; <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:ad1c83030818a61aa827fb454aec77202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the thread pool by creating worker threads and initializing internal structures.  <br /></td></tr>
<tr class="separator:ad1c83030818a61aa827fb454aec77202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b87bf57ff48f577f97a267429a31045" id="r_a2b87bf57ff48f577f97a267429a31045"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#a2b87bf57ff48f577f97a267429a31045">get_job_queue</a> (void) -&gt; std::shared_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__queue__t.html">typed_job_queue_t</a>&lt; job_type &gt; &gt;</td></tr>
<tr class="memdesc:a2b87bf57ff48f577f97a267429a31045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the underlying priority job queue managed by this thread pool.  <br /></td></tr>
<tr class="separator:a2b87bf57ff48f577f97a267429a31045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e50f01d4b411619b6e3aa67dd6d505" id="r_af1e50f01d4b411619b6e3aa67dd6d505"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#af1e50f01d4b411619b6e3aa67dd6d505">enqueue</a> (std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__t.html">typed_job_t</a>&lt; job_type &gt; &gt; &amp;&amp;<a class="el" href="classthread__module_1_1job.html">job</a>) -&gt; <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:af1e50f01d4b411619b6e3aa67dd6d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a priority job into the thread pool's job queue.  <br /></td></tr>
<tr class="separator:af1e50f01d4b411619b6e3aa67dd6d505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a99efe16d557ccc1b0105d512400de" id="r_ad9a99efe16d557ccc1b0105d512400de"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#ad9a99efe16d557ccc1b0105d512400de">enqueue_batch</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__t.html">typed_job_t</a>&lt; job_type &gt; &gt; &gt; &amp;&amp;jobs) -&gt; <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:ad9a99efe16d557ccc1b0105d512400de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a batch of priority jobs into the thread pool's job queue.  <br /></td></tr>
<tr class="separator:ad9a99efe16d557ccc1b0105d512400de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e2734721f98ba405a74466361841da" id="r_af7e2734721f98ba405a74466361841da"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#af7e2734721f98ba405a74466361841da">enqueue</a> (std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_worker_t</a>&lt; job_type &gt; &gt; &amp;&amp;worker) -&gt; <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:af7e2734721f98ba405a74466361841da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a new worker thread for this thread pool.  <br /></td></tr>
<tr class="separator:af7e2734721f98ba405a74466361841da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e53650aa1dcdfb5d411a0ea56477c6" id="r_ab6e53650aa1dcdfb5d411a0ea56477c6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#ab6e53650aa1dcdfb5d411a0ea56477c6">enqueue_batch</a> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_worker_t</a>&lt; job_type &gt; &gt; &gt; &amp;&amp;workers) -&gt; <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:ab6e53650aa1dcdfb5d411a0ea56477c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a batch of new worker threads for this thread pool.  <br /></td></tr>
<tr class="separator:ab6e53650aa1dcdfb5d411a0ea56477c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0e6df52fd731ad33b6b59a3f886821" id="r_aed0e6df52fd731ad33b6b59a3f886821"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#aed0e6df52fd731ad33b6b59a3f886821">stop</a> (bool clear_queue=false) -&gt; <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:aed0e6df52fd731ad33b6b59a3f886821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the thread pool and optionally waits for currently running jobs to finish.  <br /></td></tr>
<tr class="separator:aed0e6df52fd731ad33b6b59a3f886821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44080ec87b7429cfeb1f6f98b496ef02" id="r_a44080ec87b7429cfeb1f6f98b496ef02"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#a44080ec87b7429cfeb1f6f98b496ef02">to_string</a> (void) const -&gt; std::string</td></tr>
<tr class="memdesc:a44080ec87b7429cfeb1f6f98b496ef02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a string representation of the thread pool's internal state.  <br /></td></tr>
<tr class="separator:a44080ec87b7429cfeb1f6f98b496ef02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7e240d738cedb02e0c9cd114ece46b" id="r_acb7e240d738cedb02e0c9cd114ece46b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#acb7e240d738cedb02e0c9cd114ece46b">set_job_queue</a> (std::shared_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__queue__t.html">typed_job_queue_t</a>&lt; job_type &gt; &gt; <a class="el" href="classthread__module_1_1job__queue.html">job_queue</a>) -&gt; void</td></tr>
<tr class="memdesc:acb7e240d738cedb02e0c9cd114ece46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the job queue for this thread pool and its workers.  <br /></td></tr>
<tr class="separator:acb7e240d738cedb02e0c9cd114ece46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfc2127e0f344cca9f186ce683e56e2" id="r_a8bfc2127e0f344cca9f186ce683e56e2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#a8bfc2127e0f344cca9f186ce683e56e2">get_context</a> (void) const -&gt; const <a class="el" href="classthread__module_1_1thread__context.html">thread_context</a> &amp;</td></tr>
<tr class="memdesc:a8bfc2127e0f344cca9f186ce683e56e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the thread context for this pool.  <br /></td></tr>
<tr class="separator:a8bfc2127e0f344cca9f186ce683e56e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7ea302397138cfac16521be8fbb4feb3" id="r_a7ea302397138cfac16521be8fbb4feb3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#a7ea302397138cfac16521be8fbb4feb3">thread_title_</a></td></tr>
<tr class="memdesc:a7ea302397138cfac16521be8fbb4feb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A descriptive name or title for this thread pool, useful for logging.  <br /></td></tr>
<tr class="separator:a7ea302397138cfac16521be8fbb4feb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec9006819ed746b89d797f6f98fb7b1" id="r_a1ec9006819ed746b89d797f6f98fb7b1"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#a1ec9006819ed746b89d797f6f98fb7b1">start_pool_</a></td></tr>
<tr class="memdesc:a1ec9006819ed746b89d797f6f98fb7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the thread pool has been started.  <br /></td></tr>
<tr class="separator:a1ec9006819ed746b89d797f6f98fb7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a41e2a07b63770b5c5e5c1045b1ee8" id="r_a78a41e2a07b63770b5c5e5c1045b1ee8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__queue__t.html">typed_job_queue_t</a>&lt; job_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#a78a41e2a07b63770b5c5e5c1045b1ee8">job_queue_</a></td></tr>
<tr class="memdesc:a78a41e2a07b63770b5c5e5c1045b1ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shared priority job queue from which workers fetch jobs.  <br /></td></tr>
<tr class="separator:a78a41e2a07b63770b5c5e5c1045b1ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5018167ca3833a3e59687dd67b0985b" id="r_aa5018167ca3833a3e59687dd67b0985b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_worker_t</a>&lt; job_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#aa5018167ca3833a3e59687dd67b0985b">workers_</a></td></tr>
<tr class="memdesc:aa5018167ca3833a3e59687dd67b0985b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection of worker threads responsible for processing jobs.  <br /></td></tr>
<tr class="separator:aa5018167ca3833a3e59687dd67b0985b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d61cb6ac27e91ce373ebaa8f3e548" id="r_a419d61cb6ac27e91ce373ebaa8f3e548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthread__module_1_1thread__context.html">thread_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#a419d61cb6ac27e91ce373ebaa8f3e548">context_</a></td></tr>
<tr class="memdesc:a419d61cb6ac27e91ce373ebaa8f3e548"><td class="mdescLeft">&#160;</td><td class="mdescRight">The thread context providing optional services.  <br /></td></tr>
<tr class="separator:a419d61cb6ac27e91ce373ebaa8f3e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename job_type = job_types&gt;<br />
class typed_thread_pool_module::typed_thread_pool_t&lt; job_type &gt;</div><p>A thread pool that schedules and executes jobs based on their priority levels. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">job_type</td><td>The type representing job types (e.g., enum or integral type).</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html" title="A thread pool that schedules and executes jobs based on their priority levels.">typed_thread_pool_t</a> template class provides a thread pool implementation that processes jobs according to their assigned types rather than just submission order. This allows more important work to be processed ahead of less important work, improving responsiveness for critical tasks.</p>
<h3><a class="anchor" id="autotoc_md174"></a>
Key Features</h3>
<ul>
<li><b>Type-Based Scheduling</b>: Jobs with higher priority are processed first.</li>
<li><b>Customizable Type Types</b>: Supports custom priority types through templates.</li>
<li><b>Worker Thread Model</b>: Each worker runs in its own thread, processing jobs.</li>
<li><b>Type Job Queue</b>: Thread-safe queue that orders jobs by priority.</li>
<li><b>Dynamic Thread Management</b>: Add/remove workers at runtime.</li>
<li><b>Graceful Shutdown</b>: Option to complete current jobs before stopping.</li>
</ul>
<h3><a class="anchor" id="autotoc_md175"></a>
Use Cases</h3>
<ul>
<li><b>Mixed Workloads</b>: Applications that process both critical and non-critical tasks.</li>
<li><b>Responsive User Interfaces</b>: Prioritize UI-related tasks over background work.</li>
<li><b>Resource Management</b>: Ensure important work gets resources when contention occurs.</li>
<li><b>Service Level Guarantees</b>: Meet varying response time requirements for different request types.</li>
</ul>
<h3><a class="anchor" id="autotoc_md176"></a>
Thread Safety</h3>
<p>All public methods of this class are thread-safe and can be called from any thread.</p>
<h3><a class="anchor" id="autotoc_md177"></a>
Performance Considerations</h3>
<ul>
<li>Type queue operations are more expensive than simple FIFO queues.</li>
<li>In high-throughput scenarios with all equal-priority jobs, consider using the non-prioritized thread_pool instead for better performance.</li>
<li>For scenarios with mixed types, this implementation can significantly improve response time for high-priority tasks.</li>
</ul>
<h3><a class="anchor" id="autotoc_md178"></a>
Example Usage</h3>
<div class="fragment"><div class="line"><span class="keyword">using </span>my_thread_pool = <a class="code hl_class" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_t&lt;my_priority_enum&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> pool = std::make_shared&lt;my_thread_pool&gt;(<span class="stringliteral">&quot;My Thread Pool&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> start_result = pool-&gt;start();</div>
<div class="line"><span class="keywordflow">if</span> (start_result.has_error())</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle error starting the pool</span></div>
<div class="line">    std::cerr &lt;&lt; start_result.get_error().message() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enqueue a job</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classthread__module_1_1job.html">job</a> = std::make_unique&lt;typed_job_t&lt;my_priority_enum&gt;&gt;(</div>
<div class="line">    my_priority_enum::HIGH,</div>
<div class="line">    [](){ std::cout &lt;&lt; <span class="stringliteral">&quot;RealTime priority job executed\n&quot;</span>; }</div>
<div class="line">);</div>
<div class="line">pool-&gt;enqueue(std::move(job));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stop the pool</span></div>
<div class="line">pool-&gt;stop();</div>
<div class="ttc" id="aclassthread__module_1_1job_html"><div class="ttname"><a href="classthread__module_1_1job.html">thread_module::job</a></div><div class="ttdoc">Represents a unit of work (task) to be executed, typically by a job queue.</div><div class="ttdef"><b>Definition</b> <a href="job_8h_source.html#l00101">job.h:102</a></div></div>
<div class="ttc" id="aclasstyped__thread__pool__module_1_1typed__thread__pool__t_html"><div class="ttname"><a href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a></div><div class="ttdoc">A thread pool that schedules and executes jobs based on their priority levels.</div><div class="ttdef"><b>Definition</b> <a href="typed__thread__pool_8h_source.html#l00142">typed_thread_pool.h:144</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__worker__t.html" title="A template-based worker thread class that processes jobs from a priority job queue.">typed_thread_worker_t</a> The worker thread class used by the pool </dd>
<dd>
<a class="el" href="classtyped__thread__pool__module_1_1typed__job__t.html" title="Represents a job that carries a specific priority level.">typed_job_t</a> Jobs with priority information </dd>
<dd>
<a class="el" href="classtyped__thread__pool__module_1_1typed__job__queue__t.html" title="A template-based queue that manages jobs with distinct priority levels.">typed_job_queue_t</a> The queue that orders jobs by priority </dd>
<dd>
<a class="el" href="classthread__pool__module_1_1thread__pool.html" title="A thread pool for concurrent execution of jobs using multiple worker threads.">thread_pool_module::thread_pool</a> The non-prioritized thread pool implementation </dd></dl>

<p class="definition">Definition at line <a class="el" href="typed__thread__pool_8h_source.html#l00142">142</a> of file <a class="el" href="typed__thread__pool_8h_source.html">typed_thread_pool.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af67bf203272157f39cb877e064c96457" name="af67bf203272157f39cb877e064c96457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67bf203272157f39cb877e064c96457">&#9670;&#160;</a></span>typed_thread_pool_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::typed_thread_pool_t </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thread_title</em> = <code>&quot;typed_thread_pool&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classthread__module_1_1thread__context.html">thread_context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em> = <code><a class="el" href="classthread__module_1_1thread__context.html">thread_context</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html" title="A thread pool that schedules and executes jobs based on their priority levels.">typed_thread_pool_t</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_title</td><td>A human-readable title or name for the thread pool. This can help in debugging or logging. </td></tr>
    <tr><td class="paramname">context</td><td>Thread context providing optional logging and monitoring services </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74bff9ee6c0bb5a30c6f02c152835465" name="a74bff9ee6c0bb5a30c6f02c152835465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74bff9ee6c0bb5a30c6f02c152835465">&#9670;&#160;</a></span>~typed_thread_pool_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::~<a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_t</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html" title="A thread pool that schedules and executes jobs based on their priority levels.">typed_thread_pool_t</a> object. </p>
<p>The destructor will invoke <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#aed0e6df52fd731ad33b6b59a3f886821" title="Stops the thread pool and optionally waits for currently running jobs to finish.">stop()</a> if the pool is still running, ensuring that all threads are properly terminated before destruction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af1e50f01d4b411619b6e3aa67dd6d505" name="af1e50f01d4b411619b6e3aa67dd6d505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e50f01d4b411619b6e3aa67dd6d505">&#9670;&#160;</a></span>enqueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__t.html">typed_job_t</a>&lt; job_type &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a priority job into the thread pool's job queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">job</td><td>A unique pointer to the priority job to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result_void<ul>
<li>Contains an error if the enqueue operation fails.</li>
<li>Otherwise, returns a success value.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md181"></a>
Thread Safety</h3>
<p>This method is thread-safe; multiple threads can safely enqueue jobs concurrently. </p>

</div>
</div>
<a id="af7e2734721f98ba405a74466361841da" name="af7e2734721f98ba405a74466361841da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e2734721f98ba405a74466361841da">&#9670;&#160;</a></span>enqueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_worker_t</a>&lt; job_type &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a new worker thread for this thread pool. </p>
<p>This allows dynamic addition of worker threads while the pool is running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker</td><td>A unique pointer to the priority thread worker to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result_void<ul>
<li>Contains an error if the enqueue operation fails.</li>
<li>Otherwise, returns a success value.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md183"></a>
Note</h3>
<p>Typically, most applications create a fixed number of workers at startup. However, if your workload changes significantly, adding more workers at runtime can help handle increased job load.</p>
<h3><a class="anchor" id="autotoc_md184"></a>
Thread Safety</h3>
<p>This method is thread-safe. </p>

</div>
</div>
<a id="ad9a99efe16d557ccc1b0105d512400de" name="ad9a99efe16d557ccc1b0105d512400de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a99efe16d557ccc1b0105d512400de">&#9670;&#160;</a></span>enqueue_batch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::enqueue_batch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__t.html">typed_job_t</a>&lt; job_type &gt; &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>jobs</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a batch of priority jobs into the thread pool's job queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jobs</td><td>A vector of unique pointers to priority jobs to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result_void<ul>
<li>Contains an error if the enqueue operation fails.</li>
<li>Otherwise, returns a success value.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md182"></a>
Thread Safety</h3>
<p>This method is thread-safe; multiple threads can safely enqueue jobs concurrently. </p>

</div>
</div>
<a id="ab6e53650aa1dcdfb5d411a0ea56477c6" name="ab6e53650aa1dcdfb5d411a0ea56477c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e53650aa1dcdfb5d411a0ea56477c6">&#9670;&#160;</a></span>enqueue_batch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::enqueue_batch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_worker_t</a>&lt; job_type &gt; &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>workers</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a batch of new worker threads for this thread pool. </p>
<p>This allows dynamic addition of multiple worker threads while the pool is running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workers</td><td>A vector of unique pointers to priority thread workers to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result_void<ul>
<li>Contains an error if the enqueue operation fails.</li>
<li>Otherwise, returns a success value.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md185"></a>
Note</h3>
<p>Typically, most applications create a fixed number of workers at startup. However, if your workload changes significantly, adding more workers at runtime can help handle increased job load.</p>
<h3><a class="anchor" id="autotoc_md186"></a>
Thread Safety</h3>
<p>This method is thread-safe. </p>

</div>
</div>
<a id="a8bfc2127e0f344cca9f186ce683e56e2" name="a8bfc2127e0f344cca9f186ce683e56e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfc2127e0f344cca9f186ce683e56e2">&#9670;&#160;</a></span>get_context()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::get_context </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt;  const <a class="el" href="classthread__module_1_1thread__context.html">thread_context</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the thread context for this pool. </p>
<dl class="section return"><dt>Returns</dt><dd>const thread_context&amp; Reference to the thread context </dd></dl>

</div>
</div>
<a id="a2b87bf57ff48f577f97a267429a31045" name="a2b87bf57ff48f577f97a267429a31045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b87bf57ff48f577f97a267429a31045">&#9670;&#160;</a></span>get_job_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::get_job_queue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  std::shared_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__queue__t.html">typed_job_queue_t</a>&lt; job_type &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the underlying priority job queue managed by this thread pool. </p>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;typed_job_queue_t&lt;job_type&gt;&gt; A shared pointer to the thread-safe priority job queue.</dd></dl>
<h3><a class="anchor" id="autotoc_md180"></a>
Thread Safety</h3>
<p>This queue is shared and used by worker threads, so care should be taken if you modify or replace the queue. Typically, external code only needs to enqueue new jobs via <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#af1e50f01d4b411619b6e3aa67dd6d505" title="Enqueues a priority job into the thread pool&#39;s job queue.">enqueue()</a>, rather than directly accessing the queue. </p>

</div>
</div>
<a id="ac66103fba1d3ba8d90051c1d692cbf45" name="ac66103fba1d3ba8d90051c1d692cbf45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66103fba1d3ba8d90051c1d692cbf45">&#9670;&#160;</a></span>get_ptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::get_ptr </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  std::shared_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_t</a>&lt; job_type &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a shared pointer to the current <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html" title="A thread pool that schedules and executes jobs based on their priority levels.">typed_thread_pool_t</a>. </p>
<p>This is a convenience method when you only have a raw pointer to the pool but need a std::shared_ptr.</p>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;typed_thread_pool_t&lt;job_type&gt;&gt; A shared pointer to this thread pool. </dd></dl>

</div>
</div>
<a id="acb7e240d738cedb02e0c9cd114ece46b" name="acb7e240d738cedb02e0c9cd114ece46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7e240d738cedb02e0c9cd114ece46b">&#9670;&#160;</a></span>set_job_queue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::set_job_queue </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classtyped__thread__pool__module_1_1typed__job__queue__t.html">typed_job_queue_t</a>&lt; job_type &gt; &gt;&#160;</td>
          <td class="paramname"><em>job_queue</em></td><td>)</td>
          <td> -&gt;  void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the job queue for this thread pool and its workers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">job_queue</td><td>A shared pointer to the job queue to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1c83030818a61aa827fb454aec77202" name="ad1c83030818a61aa827fb454aec77202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c83030818a61aa827fb454aec77202">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the thread pool by creating worker threads and initializing internal structures. </p>
<dl class="section return"><dt>Returns</dt><dd>result_void<ul>
<li>If an error occurs during start-up, the returned result will contain an error object.</li>
<li>If no error occurs, the result will be a success value.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md179"></a>
Thread Safety</h3>
<p>This method is typically called once, before using other methods such as <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#af1e50f01d4b411619b6e3aa67dd6d505" title="Enqueues a priority job into the thread pool&#39;s job queue.">enqueue()</a>. Calling <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#ad1c83030818a61aa827fb454aec77202" title="Starts the thread pool by creating worker threads and initializing internal structures.">start()</a> multiple times without stopping is not recommended. </p>

</div>
</div>
<a id="aed0e6df52fd731ad33b6b59a3f886821" name="aed0e6df52fd731ad33b6b59a3f886821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0e6df52fd731ad33b6b59a3f886821">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::stop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_queue</em> = <code>false</code></td><td>)</td>
          <td> -&gt;  <a class="el" href="classthread__module_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the thread pool and optionally waits for currently running jobs to finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_queue</td><td>If <code>true</code>, any queued jobs are removed. If <code>false</code> (default), the pool stops accepting new jobs but allows currently running jobs to complete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result_void<ul>
<li>Contains an error if the stop operation fails.</li>
<li>Otherwise, returns a success value.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="autotoc_md187"></a>
Thread Safety</h3>
<p>Calling <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#aed0e6df52fd731ad33b6b59a3f886821" title="Stops the thread pool and optionally waits for currently running jobs to finish.">stop()</a> from multiple threads simultaneously is safe, but redundant calls to <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html#aed0e6df52fd731ad33b6b59a3f886821" title="Stops the thread pool and optionally waits for currently running jobs to finish.">stop()</a> will have no additional effect after the first. </p>

</div>
</div>
<a id="a44080ec87b7429cfeb1f6f98b496ef02" name="a44080ec87b7429cfeb1f6f98b496ef02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44080ec87b7429cfeb1f6f98b496ef02">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::to_string </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt;  std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a string representation of the thread pool's internal state. </p>
<dl class="section return"><dt>Returns</dt><dd>std::string A human-readable string containing pool details, such as whether the pool is running, the thread title, and potentially the number of workers.</dd></dl>
<h3><a class="anchor" id="autotoc_md188"></a>
Example</h3>
<div class="fragment"><div class="line">std::cout &lt;&lt; pool.to_string() &lt;&lt; std::endl;</div>
<div class="line"><span class="comment">// Output might look like:</span></div>
<div class="line"><span class="comment">// &quot;typed_thread_pool [Title: typed_thread_pool, Started: true, Workers: 4]&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a419d61cb6ac27e91ce373ebaa8f3e548" name="a419d61cb6ac27e91ce373ebaa8f3e548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419d61cb6ac27e91ce373ebaa8f3e548">&#9670;&#160;</a></span>context_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthread__module_1_1thread__context.html">thread_context</a> <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::context_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The thread context providing optional services. </p>

<p class="definition">Definition at line <a class="el" href="typed__thread__pool_8h_source.html#l00341">341</a> of file <a class="el" href="typed__thread__pool_8h_source.html">typed_thread_pool.h</a>.</p>

</div>
</div>
<a id="a78a41e2a07b63770b5c5e5c1045b1ee8" name="a78a41e2a07b63770b5c5e5c1045b1ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a41e2a07b63770b5c5e5c1045b1ee8">&#9670;&#160;</a></span>job_queue_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classtyped__thread__pool__module_1_1typed__job__queue__t.html">typed_job_queue_t</a>&lt;job_type&gt; &gt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::job_queue_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The shared priority job queue from which workers fetch jobs. </p>

<p class="definition">Definition at line <a class="el" href="typed__thread__pool_8h_source.html#l00335">335</a> of file <a class="el" href="typed__thread__pool_8h_source.html">typed_thread_pool.h</a>.</p>

</div>
</div>
<a id="a1ec9006819ed746b89d797f6f98fb7b1" name="a1ec9006819ed746b89d797f6f98fb7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec9006819ed746b89d797f6f98fb7b1">&#9670;&#160;</a></span>start_pool_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::start_pool_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the thread pool has been started. </p>

<p class="definition">Definition at line <a class="el" href="typed__thread__pool_8h_source.html#l00332">332</a> of file <a class="el" href="typed__thread__pool_8h_source.html">typed_thread_pool.h</a>.</p>

</div>
</div>
<a id="a7ea302397138cfac16521be8fbb4feb3" name="a7ea302397138cfac16521be8fbb4feb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea302397138cfac16521be8fbb4feb3">&#9670;&#160;</a></span>thread_title_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::thread_title_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A descriptive name or title for this thread pool, useful for logging. </p>

<p class="definition">Definition at line <a class="el" href="typed__thread__pool_8h_source.html#l00329">329</a> of file <a class="el" href="typed__thread__pool_8h_source.html">typed_thread_pool.h</a>.</p>

</div>
</div>
<a id="aa5018167ca3833a3e59687dd67b0985b" name="aa5018167ca3833a3e59687dd67b0985b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5018167ca3833a3e59687dd67b0985b">&#9670;&#160;</a></span>workers_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename job_type  = job_types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_worker_t</a>&lt;job_type&gt; &gt; &gt; <a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_module::typed_thread_pool_t</a>&lt; job_type &gt;::workers_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The collection of worker threads responsible for processing jobs. </p>

<p class="definition">Definition at line <a class="el" href="typed__thread__pool_8h_source.html#l00338">338</a> of file <a class="el" href="typed__thread__pool_8h_source.html">typed_thread_pool.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>thread_system/sources/typed_thread_pool/detail/<a class="el" href="typed__thread__pool_2detail_2forward__declarations_8h_source.html">forward_declarations.h</a></li>
<li>thread_system/sources/typed_thread_pool/pool/<a class="el" href="typed__thread__pool_8h_source.html">typed_thread_pool.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetyped__thread__pool__module.html">typed_thread_pool_module</a></li><li class="navelem"><a class="el" href="classtyped__thread__pool__module_1_1typed__thread__pool__t.html">typed_thread_pool_t</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
