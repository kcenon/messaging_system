<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: API Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('db/d91/md_docs_2API__REFERENCE.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">API Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md264"></a> </p>
<h1><a class="anchor" id="autotoc_md265"></a>
Table of Contents</h1>
<ol type="1">
<li>Container System API</li>
<li>Network System API</li>
<li>Database System API</li>
<li>Message Bus API</li>
<li>Service Container API</li>
<li>Thread System API</li>
<li>Logger System API</li>
<li>Error Codes</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md267"></a>
Container System API</h1>
<h2><a class="anchor" id="autotoc_md268"></a>
Namespace: &lt;tt&gt;container_module&lt;/tt&gt;</h2>
<h2><a class="anchor" id="autotoc_md269"></a>
Class: &lt;tt&gt;value_container&lt;/tt&gt;</h2>
<p>Thread-safe container for storing typed values with serialization support.</p>
<h3><a class="anchor" id="autotoc_md270"></a>
Constructor</h3>
<div class="fragment"><div class="line">value_container();</div>
<div class="line">value_container(<span class="keyword">const</span> std::string&amp; serialized_data);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md271"></a>
Core Methods</h3>
<h4><a class="anchor" id="autotoc_md272"></a>
Setting Values</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_source(<span class="keyword">const</span> std::string&amp; source_id, <span class="keyword">const</span> std::string&amp; source_sub = <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keywordtype">void</span> set_target(<span class="keyword">const</span> std::string&amp; target_id, <span class="keyword">const</span> std::string&amp; target_sub = <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"><span class="keywordtype">void</span> set_message_type(<span class="keyword">const</span> std::string&amp; type);</div>
<div class="line"><span class="keywordtype">void</span> set_message_id(<span class="keyword">const</span> std::string&amp; <span class="keywordtype">id</span>);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md273"></a>
Adding Values</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> add_value(<span class="keyword">const</span> std::string&amp; key, value_types type, <span class="keyword">const</span> std::string&amp; value);</div>
<div class="line"><span class="keywordtype">void</span> add_value(<span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> variant&amp; value);</div>
<div class="line"><span class="keywordtype">void</span> add_values(<span class="keyword">const</span> std::vector&lt;std::pair&lt;std::string, variant&gt;&gt;&amp; values);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md274"></a>
Retrieving Values</h4>
<div class="fragment"><div class="line">std::optional&lt;variant&gt; get_value(<span class="keyword">const</span> std::string&amp; key) <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; std::optional&lt;T&gt; get_value_as(<span class="keyword">const</span> std::string&amp; key) <span class="keyword">const</span>;</div>
<div class="line">std::vector&lt;std::string&gt; get_keys() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> has_key(<span class="keyword">const</span> std::string&amp; key) <span class="keyword">const</span>;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md275"></a>
Serialization</h4>
<div class="fragment"><div class="line">std::string serialize(serialization_format format = serialization_format::binary) <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> deserialize(<span class="keyword">const</span> std::string&amp; data, serialization_format format = serialization_format::binary);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md276"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;container/container.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>container_module;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create container</span></div>
<div class="line"><span class="keyword">auto</span> container = std::make_shared&lt;value_container&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set metadata</span></div>
<div class="line">container-&gt;set_source(<span class="stringliteral">&quot;client_01&quot;</span>, <span class="stringliteral">&quot;session_123&quot;</span>);</div>
<div class="line">container-&gt;set_target(<span class="stringliteral">&quot;server&quot;</span>, <span class="stringliteral">&quot;main&quot;</span>);</div>
<div class="line">container-&gt;set_message_type(<span class="stringliteral">&quot;data_update&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add typed values</span></div>
<div class="line">container-&gt;add_value(<span class="stringliteral">&quot;user_id&quot;</span>, value_types::int32_type, <span class="stringliteral">&quot;12345&quot;</span>);</div>
<div class="line">container-&gt;add_value(<span class="stringliteral">&quot;temperature&quot;</span>, value_types::float_type, <span class="stringliteral">&quot;23.5&quot;</span>);</div>
<div class="line">container-&gt;add_value(<span class="stringliteral">&quot;message&quot;</span>, value_types::string_type, <span class="stringliteral">&quot;Hello World&quot;</span>);</div>
<div class="line">container-&gt;add_value(<span class="stringliteral">&quot;binary_data&quot;</span>, value_types::bytes_type, binary_string);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Retrieve values</span></div>
<div class="line"><span class="keyword">auto</span> user_id = container-&gt;get_value_as&lt;int32_t&gt;(<span class="stringliteral">&quot;user_id&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span> (user_id.has_value()) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;User ID: &quot;</span> &lt;&lt; user_id.value() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Serialize for transmission</span></div>
<div class="line">std::string serialized = container-&gt;serialize();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Deserialize received data</span></div>
<div class="line"><span class="keyword">auto</span> received = std::make_shared&lt;value_container&gt;();</div>
<div class="line">received-&gt;deserialize(serialized);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md277"></a>
Class: &lt;tt&gt;variant&lt;/tt&gt;</h2>
<p>Type-safe variant for storing different value types.</p>
<h3><a class="anchor" id="autotoc_md278"></a>
Supported Types</h3>
<ul>
<li><code>bool</code></li>
<li><code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code></li>
<li><code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, <code>uint64_t</code></li>
<li><code>float</code>, <code>double</code></li>
<li><code>std::string</code></li>
<li><code>std::vector&lt;uint8_t&gt;</code> (bytes)</li>
<li><code>std::shared_ptr&lt;value_container&gt;</code> (nested)</li>
</ul>
<h3><a class="anchor" id="autotoc_md279"></a>
Methods</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T get() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keywordtype">bool</span> is() <span class="keyword">const</span>;</div>
<div class="line">value_types type() <span class="keyword">const</span>;</div>
<div class="line">std::string to_string() <span class="keyword">const</span>;</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md281"></a>
Network System API</h1>
<h2><a class="anchor" id="autotoc_md282"></a>
Namespace: &lt;tt&gt;network_module&lt;/tt&gt;</h2>
<h2><a class="anchor" id="autotoc_md283"></a>
Class: &lt;tt&gt;messaging_server&lt;/tt&gt;</h2>
<p>Asynchronous TCP server for handling client connections.</p>
<h3><a class="anchor" id="autotoc_md284"></a>
Constructor</h3>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> messaging_server(<span class="keyword">const</span> std::string&amp; server_id);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md285"></a>
Methods</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> start_server(uint16_t port, <span class="keyword">const</span> std::string&amp; address = <span class="stringliteral">&quot;0.0.0.0&quot;</span>);</div>
<div class="line"><span class="keywordtype">void</span> stop_server();</div>
<div class="line"><span class="keywordtype">bool</span> is_running() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Session management</span></div>
<div class="line">std::vector&lt;std::string&gt; get_connected_clients() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> send_to_client(<span class="keyword">const</span> std::string&amp; client_id, <span class="keyword">const</span> message_ptr&amp; msg);</div>
<div class="line"><span class="keywordtype">bool</span> broadcast(<span class="keyword">const</span> message_ptr&amp; msg, <span class="keyword">const</span> std::string&amp; exclude_client = <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Callbacks</span></div>
<div class="line"><span class="keywordtype">void</span> set_message_handler(message_callback handler);</div>
<div class="line"><span class="keywordtype">void</span> set_connection_handler(connection_callback handler);</div>
<div class="line"><span class="keywordtype">void</span> set_disconnection_handler(disconnection_callback handler);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md286"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network/messaging_server.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>network_module;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create server</span></div>
<div class="line"><span class="keyword">auto</span> server = std::make_shared&lt;messaging_server&gt;(<span class="stringliteral">&quot;main_server&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set up handlers</span></div>
<div class="line">server-&gt;set_message_handler([](<span class="keyword">const</span> std::string&amp; client_id, <span class="keyword">const</span> message_ptr&amp; msg) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received from &quot;</span> &lt;&lt; client_id &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; msg-&gt;serialize() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">server-&gt;set_connection_handler([](<span class="keyword">const</span> std::string&amp; client_id) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Client connected: &quot;</span> &lt;&lt; client_id &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start server</span></div>
<div class="line"><span class="keywordflow">if</span> (server-&gt;start_server(8080)) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Server running on port 8080&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Broadcast message</span></div>
<div class="line"><span class="keyword">auto</span> msg = std::make_shared&lt;value_container&gt;();</div>
<div class="line">msg-&gt;set_message_type(<span class="stringliteral">&quot;announcement&quot;</span>);</div>
<div class="line">msg-&gt;add_value(<span class="stringliteral">&quot;text&quot;</span>, value_types::string_type, <span class="stringliteral">&quot;Server maintenance in 5 minutes&quot;</span>);</div>
<div class="line">server-&gt;broadcast(msg);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Graceful shutdown</span></div>
<div class="line">server-&gt;stop_server();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md287"></a>
Class: &lt;tt&gt;messaging_client&lt;/tt&gt;</h2>
<p>Asynchronous TCP client for connecting to servers.</p>
<h3><a class="anchor" id="autotoc_md288"></a>
Constructor</h3>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> messaging_client(<span class="keyword">const</span> std::string&amp; client_id);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md289"></a>
Methods</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> start_client(<span class="keyword">const</span> std::string&amp; host, uint16_t port);</div>
<div class="line"><span class="keywordtype">void</span> stop_client();</div>
<div class="line"><span class="keywordtype">bool</span> is_connected() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Message operations</span></div>
<div class="line"><span class="keywordtype">bool</span> send_message(<span class="keyword">const</span> message_ptr&amp; msg);</div>
<div class="line">std::future&lt;message_ptr&gt; request(<span class="keyword">const</span> message_ptr&amp; request,</div>
<div class="line">                                 std::chrono::milliseconds timeout = std::chrono::milliseconds(5000));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Callbacks</span></div>
<div class="line"><span class="keywordtype">void</span> set_message_handler(message_callback handler);</div>
<div class="line"><span class="keywordtype">void</span> set_connection_handler(connection_callback handler);</div>
<div class="line"><span class="keywordtype">void</span> set_disconnection_handler(disconnection_callback handler);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md290"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;network/messaging_client.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>network_module;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create client</span></div>
<div class="line"><span class="keyword">auto</span> client = std::make_shared&lt;messaging_client&gt;(<span class="stringliteral">&quot;client_01&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set up handlers</span></div>
<div class="line">client-&gt;set_message_handler([](<span class="keyword">const</span> std::string&amp; server_id, <span class="keyword">const</span> message_ptr&amp; msg) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; msg-&gt;serialize() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Connect to server</span></div>
<div class="line"><span class="keywordflow">if</span> (client-&gt;start_client(<span class="stringliteral">&quot;localhost&quot;</span>, 8080)) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to server&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send message</span></div>
<div class="line"><span class="keyword">auto</span> msg = std::make_shared&lt;value_container&gt;();</div>
<div class="line">msg-&gt;set_message_type(<span class="stringliteral">&quot;query&quot;</span>);</div>
<div class="line">msg-&gt;add_value(<span class="stringliteral">&quot;query_type&quot;</span>, value_types::string_type, <span class="stringliteral">&quot;get_status&quot;</span>);</div>
<div class="line">client-&gt;send_message(msg);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Request-response pattern</span></div>
<div class="line"><span class="keyword">auto</span> request = std::make_shared&lt;value_container&gt;();</div>
<div class="line">request-&gt;set_message_type(<span class="stringliteral">&quot;request&quot;</span>);</div>
<div class="line">request-&gt;add_value(<span class="stringliteral">&quot;action&quot;</span>, value_types::string_type, <span class="stringliteral">&quot;get_user_info&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> future = client-&gt;request(request);</div>
<div class="line"><span class="keywordflow">if</span> (future.wait_for(std::chrono::seconds(5)) == std::future_status::ready) {</div>
<div class="line">    <span class="keyword">auto</span> response = future.get();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Response: &quot;</span> &lt;&lt; response-&gt;serialize() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Disconnect</span></div>
<div class="line">client-&gt;stop_client();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md292"></a>
Database System API</h1>
<h2><a class="anchor" id="autotoc_md293"></a>
Namespace: &lt;tt&gt;database&lt;/tt&gt;</h2>
<h2><a class="anchor" id="autotoc_md294"></a>
Class: &lt;tt&gt;database_manager&lt;/tt&gt;</h2>
<p>Thread-safe database connection manager with pooling support.</p>
<h3><a class="anchor" id="autotoc_md295"></a>
Constructor</h3>
<div class="fragment"><div class="line">database_manager();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md296"></a>
Configuration</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_mode(database_types mode);</div>
<div class="line"><span class="keywordtype">void</span> set_pool_size(<span class="keywordtype">size_t</span> size);</div>
<div class="line"><span class="keywordtype">void</span> set_connection_timeout(std::chrono::milliseconds timeout);</div>
<div class="line"><span class="keywordtype">void</span> enable_prepared_statements(<span class="keywordtype">bool</span> enable);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md297"></a>
Connection Management</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect(<span class="keyword">const</span> std::string&amp; connection_string);</div>
<div class="line"><span class="keywordtype">void</span> disconnect();</div>
<div class="line"><span class="keywordtype">bool</span> is_connected() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> check_connection();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md298"></a>
Query Execution</h3>
<div class="fragment"><div class="line"><span class="comment">// SELECT queries</span></div>
<div class="line">query_result select_query(<span class="keyword">const</span> std::string&amp; query,</div>
<div class="line">                         <span class="keyword">const</span> std::vector&lt;query_parameter&gt;&amp; params = {});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// INSERT/UPDATE/DELETE</span></div>
<div class="line"><span class="keywordtype">bool</span> execute_query(<span class="keyword">const</span> std::string&amp; query,</div>
<div class="line">                  <span class="keyword">const</span> std::vector&lt;query_parameter&gt;&amp; params = {});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Batch operations</span></div>
<div class="line"><span class="keywordtype">bool</span> execute_batch(<span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; queries);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepared statements</span></div>
<div class="line">prepared_statement prepare(<span class="keyword">const</span> std::string&amp; query);</div>
<div class="line">query_result execute_prepared(<span class="keyword">const</span> prepared_statement&amp; stmt,</div>
<div class="line">                             <span class="keyword">const</span> std::vector&lt;query_parameter&gt;&amp; params);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md299"></a>
Transaction Support</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> begin_transaction();</div>
<div class="line"><span class="keywordtype">bool</span> commit_transaction();</div>
<div class="line"><span class="keywordtype">bool</span> rollback_transaction();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Transaction with callback</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keywordtype">bool</span> transaction(Func&amp;&amp; func);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md300"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;database/database_manager.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>database;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and configure manager</span></div>
<div class="line">database_manager db;</div>
<div class="line">db.set_mode(database_types::postgres);</div>
<div class="line">db.set_pool_size(10);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Connect to database</span></div>
<div class="line"><span class="keywordflow">if</span> (db.connect(<span class="stringliteral">&quot;host=localhost dbname=myapp user=admin password=secret&quot;</span>)) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to database&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Execute SELECT query</span></div>
<div class="line"><span class="keyword">auto</span> result = db.select_query(<span class="stringliteral">&quot;SELECT * FROM users WHERE age &gt; $1&quot;</span>, {25});</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; row : result) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;User: &quot;</span> &lt;&lt; row[<span class="stringliteral">&quot;name&quot;</span>].as&lt;std::string&gt;()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;, Age: &quot;</span> &lt;&lt; row[<span class="stringliteral">&quot;age&quot;</span>].as&lt;int&gt;() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Execute INSERT with prepared statement</span></div>
<div class="line"><span class="keyword">auto</span> stmt = db.prepare(<span class="stringliteral">&quot;INSERT INTO users (name, email, age) VALUES ($1, $2, $3)&quot;</span>);</div>
<div class="line">db.execute_prepared(stmt, {<span class="stringliteral">&quot;John Doe&quot;</span>, <span class="stringliteral">&quot;john@example.com&quot;</span>, 30});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Transaction example</span></div>
<div class="line"><span class="keywordtype">bool</span> success = db.transaction([&amp;db]() {</div>
<div class="line">    db.execute_query(<span class="stringliteral">&quot;UPDATE accounts SET balance = balance - 100 WHERE id = 1&quot;</span>);</div>
<div class="line">    db.execute_query(<span class="stringliteral">&quot;UPDATE accounts SET balance = balance + 100 WHERE id = 2&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// Commit</span></div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Batch operations</span></div>
<div class="line">std::vector&lt;std::string&gt; batch = {</div>
<div class="line">    <span class="stringliteral">&quot;INSERT INTO logs (message, timestamp) VALUES (&#39;Start&#39;, NOW())&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;UPDATE stats SET count = count + 1&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;INSERT INTO logs (message, timestamp) VALUES (&#39;End&#39;, NOW())&quot;</span></div>
<div class="line">};</div>
<div class="line">db.execute_batch(batch);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Disconnect</span></div>
<div class="line">db.disconnect();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md302"></a>
Message Bus API</h1>
<h2><a class="anchor" id="autotoc_md303"></a>
Namespace: &lt;tt&gt;kcenon::messaging&lt;/tt&gt;</h2>
<h2><a class="anchor" id="autotoc_md304"></a>
Enum: &lt;tt&gt;transport_mode&lt;/tt&gt;</h2>
<p>Defines how message_bus handles message routing.</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> transport_mode {</div>
<div class="line">    local,   <span class="comment">// Local-only: messages are routed only to local subscribers</span></div>
<div class="line">    remote,  <span class="comment">// Remote-only: messages are sent only via transport</span></div>
<div class="line">    hybrid   <span class="comment">// Hybrid: messages are routed both locally and remotely</span></div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md305"></a>
Class: &lt;tt&gt;message_bus&lt;/tt&gt;</h2>
<p>Central message routing and distribution system with optional distributed messaging support.</p>
<h3><a class="anchor" id="autotoc_md306"></a>
Constructor</h3>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> message_bus(</div>
<div class="line">    std::shared_ptr&lt;backend_interface&gt; backend,</div>
<div class="line">    message_bus_config config = {}</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md307"></a>
Configuration Structure</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>message_bus_config {</div>
<div class="line">    <span class="keywordtype">size_t</span> queue_capacity = 10000;</div>
<div class="line">    <span class="keywordtype">size_t</span> worker_threads = 4;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_priority_queue = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_dead_letter_queue = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_metrics = <span class="keyword">true</span>;</div>
<div class="line">    std::chrono::milliseconds processing_timeout{5000};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Transport configuration</span></div>
<div class="line">    transport_mode mode = transport_mode::local;</div>
<div class="line">    std::shared_ptr&lt;adapters::transport_interface&gt; transport = <span class="keyword">nullptr</span>;</div>
<div class="line">    std::string local_node_id;  <span class="comment">// Unique identifier for distributed routing</span></div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md308"></a>
Lifecycle Methods</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> initialize();</div>
<div class="line"><span class="keywordtype">void</span> shutdown();</div>
<div class="line"><span class="keywordtype">bool</span> is_running() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md309"></a>
Publishing</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> publish(<span class="keyword">const</span> message&amp; msg);</div>
<div class="line"><span class="keywordtype">bool</span> publish(<span class="keyword">const</span> std::string&amp; topic, <span class="keyword">const</span> message_payload&amp; payload,</div>
<div class="line">            <span class="keyword">const</span> std::string&amp; sender = <span class="stringliteral">&quot;&quot;</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md310"></a>
Subscription</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> subscribe(<span class="keyword">const</span> std::string&amp; topic, message_handler handler);</div>
<div class="line"><span class="keywordtype">void</span> unsubscribe(<span class="keyword">const</span> std::string&amp; topic, <span class="keyword">const</span> message_handler&amp; handler);</div>
<div class="line"><span class="keywordtype">void</span> unsubscribe_all(<span class="keyword">const</span> std::string&amp; topic);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md311"></a>
Request-Response</h3>
<div class="fragment"><div class="line">std::future&lt;message&gt; request(<span class="keyword">const</span> message&amp; request_msg);</div>
<div class="line"><span class="keywordtype">void</span> respond(<span class="keyword">const</span> message&amp; original_msg, <span class="keyword">const</span> message&amp; response_msg);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md312"></a>
Monitoring</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>statistics_snapshot {</div>
<div class="line">    uint64_t messages_published;</div>
<div class="line">    uint64_t messages_processed;</div>
<div class="line">    uint64_t messages_failed;</div>
<div class="line">    uint64_t messages_dropped;</div>
<div class="line">    uint64_t messages_sent_remote;      <span class="comment">// Messages sent via transport</span></div>
<div class="line">    uint64_t messages_received_remote;  <span class="comment">// Messages received from transport</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">statistics_snapshot get_statistics() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">void</span> reset_statistics();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md313"></a>
Transport Accessors</h3>
<div class="fragment"><div class="line">transport_mode get_transport_mode() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> has_transport() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> is_transport_connected() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md314"></a>
Usage Example (Local Mode)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/core/message_bus.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/backends/standalone_backend.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>kcenon::messaging;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create backend</span></div>
<div class="line"><span class="keyword">auto</span> backend = std::make_shared&lt;standalone_backend&gt;(4);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure message bus (local-only mode, default)</span></div>
<div class="line">message_bus_config config;</div>
<div class="line">config.worker_threads = 4;</div>
<div class="line">config.queue_capacity = 10000;</div>
<div class="line"> </div>
<div class="line">message_bus bus(backend, config);</div>
<div class="line">bus.start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subscribe to topics</span></div>
<div class="line">bus.subscribe(<span class="stringliteral">&quot;user.created&quot;</span>, [](<span class="keyword">const</span> message&amp; msg) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;New user event received&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> common::ok();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Publish messages</span></div>
<div class="line">message msg(<span class="stringliteral">&quot;user.created&quot;</span>);</div>
<div class="line">bus.publish(msg);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get statistics</span></div>
<div class="line"><span class="keyword">auto</span> stats = bus.get_statistics();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Messages processed: &quot;</span> &lt;&lt; stats.messages_processed &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Shutdown</span></div>
<div class="line">bus.stop();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md315"></a>
Usage Example (Hybrid Mode with Transport)</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/core/message_bus.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/backends/standalone_backend.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/adapters/websocket_transport.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>kcenon::messaging;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create backend and transport</span></div>
<div class="line"><span class="keyword">auto</span> backend = std::make_shared&lt;standalone_backend&gt;(4);</div>
<div class="line"><span class="keyword">auto</span> transport = std::make_shared&lt;adapters::websocket_transport&gt;(</div>
<div class="line">    adapters::websocket_transport_config{<span class="stringliteral">&quot;localhost&quot;</span>, 8080}</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure message bus for hybrid mode</span></div>
<div class="line">message_bus_config config;</div>
<div class="line">config.worker_threads = 4;</div>
<div class="line">config.mode = transport_mode::hybrid;  <span class="comment">// Route to both local and remote</span></div>
<div class="line">config.transport = transport;</div>
<div class="line">config.local_node_id = <span class="stringliteral">&quot;node-1&quot;</span>;</div>
<div class="line"> </div>
<div class="line">message_bus bus(backend, config);</div>
<div class="line">bus.start();  <span class="comment">// Connects transport automatically</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Messages now route to local subscribers AND remote nodes</span></div>
<div class="line">message msg(<span class="stringliteral">&quot;user.created&quot;</span>);</div>
<div class="line">bus.publish(msg);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> stats = bus.get_statistics();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Sent remote: &quot;</span> &lt;&lt; stats.messages_sent_remote &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Received remote: &quot;</span> &lt;&lt; stats.messages_received_remote &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">bus.stop();  <span class="comment">// Disconnects transport automatically</span></div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md317"></a>
Service Container API</h1>
<h2><a class="anchor" id="autotoc_md318"></a>
Namespace: &lt;tt&gt;kcenon::messaging::services&lt;/tt&gt;</h2>
<h2><a class="anchor" id="autotoc_md319"></a>
Class: &lt;tt&gt;service_container&lt;/tt&gt;</h2>
<p>Dependency injection container for service management.</p>
<h3><a class="anchor" id="autotoc_md320"></a>
Methods</h3>
<div class="fragment"><div class="line"><span class="comment">// Service registration</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Interface, <span class="keyword">typename</span> Implementation&gt;</div>
<div class="line"><span class="keywordtype">void</span> register_service(service_lifetime lifetime = service_lifetime::singleton);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Interface&gt;</div>
<div class="line"><span class="keywordtype">void</span> register_factory(std::function&lt;std::shared_ptr&lt;Interface&gt;()&gt; factory,</div>
<div class="line">                     service_lifetime lifetime = service_lifetime::singleton);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Service resolution</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Interface&gt;</div>
<div class="line">std::shared_ptr&lt;Interface&gt; resolve();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Interface&gt;</div>
<div class="line">std::vector&lt;std::shared_ptr&lt;Interface&gt;&gt; resolve_all();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Lifecycle management</span></div>
<div class="line"><span class="keywordtype">void</span> initialize_all();</div>
<div class="line"><span class="keywordtype">void</span> shutdown_all();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md321"></a>
Service Lifetimes</h3>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> service_lifetime {</div>
<div class="line">    singleton,   <span class="comment">// Single instance for application lifetime</span></div>
<div class="line">    transient,   <span class="comment">// New instance for each request</span></div>
<div class="line">    scoped       <span class="comment">// Single instance per scope</span></div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md322"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/services/service_container.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>kcenon::messaging::services;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define interfaces</span></div>
<div class="line"><span class="keyword">class </span>ILogger {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> log(<span class="keyword">const</span> std::string&amp; message) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~ILogger() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>IDatabase {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> connect() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~IDatabase() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Implement services</span></div>
<div class="line"><span class="keyword">class </span>ConsoleLogger : <span class="keyword">public</span> ILogger {</div>
<div class="line">    <span class="keywordtype">void</span> log(<span class="keyword">const</span> std::string&amp; message)<span class="keyword"> override </span>{</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[LOG] &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PostgresDatabase : <span class="keyword">public</span> IDatabase {</div>
<div class="line">    <span class="keywordtype">bool</span> connect()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Database connection logic</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure container</span></div>
<div class="line">service_container container;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register services</span></div>
<div class="line">container.register_service&lt;ILogger, ConsoleLogger&gt;(service_lifetime::singleton);</div>
<div class="line">container.register_service&lt;IDatabase, PostgresDatabase&gt;(service_lifetime::singleton);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register factory</span></div>
<div class="line">container.register_factory&lt;ILogger&gt;([]() {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_shared&lt;ConsoleLogger&gt;();</div>
<div class="line">}, service_lifetime::transient);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Resolve services</span></div>
<div class="line"><span class="keyword">auto</span> logger = container.resolve&lt;ILogger&gt;();</div>
<div class="line">logger-&gt;log(<span class="stringliteral">&quot;Application started&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> db = container.resolve&lt;IDatabase&gt;();</div>
<div class="line"><span class="keywordflow">if</span> (db-&gt;connect()) {</div>
<div class="line">    logger-&gt;log(<span class="stringliteral">&quot;Database connected&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize all services</span></div>
<div class="line">container.initialize_all();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Shutdown when done</span></div>
<div class="line">container.shutdown_all();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md324"></a>
Thread System API</h1>
<h2><a class="anchor" id="autotoc_md325"></a>
Namespace: &lt;tt&gt;thread_system&lt;/tt&gt;</h2>
<h2><a class="anchor" id="autotoc_md326"></a>
Class: &lt;tt&gt;thread_pool&lt;/tt&gt;</h2>
<p>Lock-free thread pool with priority scheduling.</p>
<h3><a class="anchor" id="autotoc_md327"></a>
Constructor</h3>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> thread_pool(<span class="keywordtype">size_t</span> num_threads = std::thread::hardware_concurrency());</div>
<div class="line">thread_pool(<span class="keywordtype">size_t</span> num_threads, pool_priority priority);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md328"></a>
Job Submission</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> submit(Func&amp;&amp; func) -&gt; std::future&lt;<span class="keyword">decltype</span>(func())&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> submit_with_priority(Func&amp;&amp; func, job_priority priority)</div>
<div class="line">    -&gt; std::future&lt;<span class="keyword">decltype</span>(func())&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keywordtype">void</span> submit_detached(Func&amp;&amp; func);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md329"></a>
Pool Management</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> start();</div>
<div class="line"><span class="keywordtype">void</span> stop();</div>
<div class="line"><span class="keywordtype">void</span> wait_for_all();</div>
<div class="line"><span class="keywordtype">size_t</span> pending_jobs() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">size_t</span> active_threads() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md330"></a>
Priority Levels</h3>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> job_priority {</div>
<div class="line">    real_time = 0,</div>
<div class="line">    high = 1,</div>
<div class="line">    normal = 2,</div>
<div class="line">    low = 3,</div>
<div class="line">    background = 4</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> pool_priority {</div>
<div class="line">    real_time,</div>
<div class="line">    batch,</div>
<div class="line">    background</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md331"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thread_system/thread_pool.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>thread_system;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create thread pool</span></div>
<div class="line">thread_pool pool(8, pool_priority::batch);</div>
<div class="line">pool.start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit jobs with futures</span></div>
<div class="line"><span class="keyword">auto</span> future1 = pool.submit([]() {</div>
<div class="line">    <span class="comment">// Compute intensive task</span></div>
<div class="line">    <span class="keywordflow">return</span> calculate_result();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> future2 = pool.submit_with_priority([]() {</div>
<div class="line">    <span class="comment">// High priority task</span></div>
<div class="line">    <span class="keywordflow">return</span> process_urgent_data();</div>
<div class="line">}, job_priority::high);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit fire-and-forget jobs</span></div>
<div class="line">pool.submit_detached([]() {</div>
<div class="line">    <span class="comment">// Background task</span></div>
<div class="line">    cleanup_temporary_files();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Batch processing</span></div>
<div class="line">std::vector&lt;std::future&lt;int&gt;&gt; futures;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i) {</div>
<div class="line">    futures.push_back(pool.submit([i]() {</div>
<div class="line">        return process_item(i);</div>
<div class="line">    }));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for results</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; f : futures) {</div>
<div class="line">    <span class="keywordtype">int</span> result = f.get();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for all jobs to complete</span></div>
<div class="line">pool.wait_for_all();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Shutdown pool</span></div>
<div class="line">pool.stop();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md332"></a>
Class: &lt;tt&gt;lock_free_queue&lt;/tt&gt;</h2>
<p>Multi-producer, multi-consumer lock-free queue.</p>
<h3><a class="anchor" id="autotoc_md333"></a>
Constructor</h3>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> lock_free_queue(<span class="keywordtype">size_t</span> capacity = 1024);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md334"></a>
Methods</h3>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> push(<span class="keyword">const</span> T&amp; item);</div>
<div class="line"><span class="keywordtype">bool</span> pop(T&amp; item);</div>
<div class="line"><span class="keywordtype">bool</span> try_pop(T&amp; item);</div>
<div class="line"><span class="keywordtype">size_t</span> size() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md335"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;thread_system/lock_free_queue.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>thread_system;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create queue</span></div>
<div class="line">lock_free_queue&lt;int&gt; queue(10000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Producer thread</span></div>
<div class="line">std::thread producer([&amp;queue]() {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">        queue.push(i);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Consumer threads</span></div>
<div class="line">std::vector&lt;std::thread&gt; consumers;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">    consumers.emplace_back([&amp;queue]() {</div>
<div class="line">        <span class="keywordtype">int</span> item;</div>
<div class="line">        <span class="keywordflow">while</span> (queue.pop(item)) {</div>
<div class="line">            process_item(item);</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Join threads</span></div>
<div class="line">producer.join();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; t : consumers) {</div>
<div class="line">    t.join();</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md337"></a>
Logger System API</h1>
<h2><a class="anchor" id="autotoc_md338"></a>
Namespace: &lt;tt&gt;logger&lt;/tt&gt;</h2>
<h2><a class="anchor" id="autotoc_md339"></a>
Class: &lt;tt&gt;logger_manager&lt;/tt&gt;</h2>
<p>High-performance asynchronous logging system.</p>
<h3><a class="anchor" id="autotoc_md340"></a>
Configuration</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>logger_config {</div>
<div class="line">    log_level min_level = log_level::info;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_console = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_file = <span class="keyword">true</span>;</div>
<div class="line">    std::string log_directory = <span class="stringliteral">&quot;./logs&quot;</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> max_file_size = 10 * 1024 * 1024;  <span class="comment">// 10MB</span></div>
<div class="line">    <span class="keywordtype">size_t</span> max_files = 10;</div>
<div class="line">    <span class="keywordtype">bool</span> async_logging = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">size_t</span> buffer_size = 8192;</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md341"></a>
Log Levels</h3>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> log_level {</div>
<div class="line">    trace = 0,</div>
<div class="line">    debug = 1,</div>
<div class="line">    info = 2,</div>
<div class="line">    warning = 3,</div>
<div class="line">    error = 4,</div>
<div class="line">    critical = 5</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md342"></a>
Methods</h3>
<div class="fragment"><div class="line"><span class="keyword">static</span> logger_manager&amp; instance();</div>
<div class="line"><span class="keywordtype">void</span> configure(<span class="keyword">const</span> logger_config&amp; config);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> trace(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"><span class="keywordtype">void</span> debug(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"><span class="keywordtype">void</span> info(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"><span class="keywordtype">void</span> warning(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"><span class="keywordtype">void</span> error(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"><span class="keywordtype">void</span> critical(<span class="keyword">const</span> std::string&amp; message);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keywordtype">void</span> log(log_level level, <span class="keyword">const</span> std::string&amp; format, Args&amp;&amp;... args);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md343"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;logger/logger_manager.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>logger;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure logger</span></div>
<div class="line">logger_config config;</div>
<div class="line">config.min_level = log_level::debug;</div>
<div class="line">config.enable_file = <span class="keyword">true</span>;</div>
<div class="line">config.log_directory = <span class="stringliteral">&quot;/var/log/myapp&quot;</span>;</div>
<div class="line">config.async_logging = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span>&amp; logger = logger_manager::instance();</div>
<div class="line">logger.configure(config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simple logging</span></div>
<div class="line">logger.info(<span class="stringliteral">&quot;Application started&quot;</span>);</div>
<div class="line">logger.debug(<span class="stringliteral">&quot;Debug mode enabled&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Formatted logging</span></div>
<div class="line"><span class="keywordtype">int</span> user_id = 12345;</div>
<div class="line">std::string action = <span class="stringliteral">&quot;login&quot;</span>;</div>
<div class="line">logger.log(log_level::info, <span class="stringliteral">&quot;User {} performed action: {}&quot;</span>, user_id, action);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Error logging with context</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    perform_operation();</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">    logger.error(<span class="stringliteral">&quot;Operation failed: &quot;</span> + std::string(e.what()));</div>
<div class="line">    logger.debug(<span class="stringliteral">&quot;Stack trace: &quot;</span> + get_stack_trace());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Performance logging</span></div>
<div class="line"><span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">process_data();</div>
<div class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line"><span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start);</div>
<div class="line">logger.info(<span class="stringliteral">&quot;Processing completed in {} ms&quot;</span>, duration.count());</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md345"></a>
Error Codes</h1>
<h2><a class="anchor" id="autotoc_md346"></a>
System Error Codes</h2>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> error_code {</div>
<div class="line">    <span class="comment">// Success</span></div>
<div class="line">    success = 0,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// General errors (1-99)</span></div>
<div class="line">    unknown_error = 1,</div>
<div class="line">    invalid_parameter = 2,</div>
<div class="line">    null_pointer = 3,</div>
<div class="line">    out_of_memory = 4,</div>
<div class="line">    not_implemented = 5,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Container errors (100-199)</span></div>
<div class="line">    serialization_failed = 100,</div>
<div class="line">    deserialization_failed = 101,</div>
<div class="line">    invalid_type = 102,</div>
<div class="line">    key_not_found = 103,</div>
<div class="line">    container_full = 104,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Network errors (200-299)</span></div>
<div class="line">    connection_failed = 200,</div>
<div class="line">    connection_timeout = 201,</div>
<div class="line">    connection_closed = 202,</div>
<div class="line">    bind_failed = 203,</div>
<div class="line">    send_failed = 204,</div>
<div class="line">    receive_failed = 205,</div>
<div class="line">    protocol_error = 206,</div>
<div class="line">    ssl_error = 207,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Database errors (300-399)</span></div>
<div class="line">    database_connection_failed = 300,</div>
<div class="line">    query_failed = 301,</div>
<div class="line">    transaction_failed = 302,</div>
<div class="line">    deadlock_detected = 303,</div>
<div class="line">    constraint_violation = 304,</div>
<div class="line">    duplicate_key = 305,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Thread/concurrency errors (400-499)</span></div>
<div class="line">    thread_creation_failed = 400,</div>
<div class="line">    lock_timeout = 401,</div>
<div class="line">    deadlock = 402,</div>
<div class="line">    race_condition = 403,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Service errors (500-599)</span></div>
<div class="line">    service_not_found = 500,</div>
<div class="line">    service_unavailable = 501,</div>
<div class="line">    service_timeout = 502,</div>
<div class="line">    circular_dependency = 503,</div>
<div class="line">    initialization_failed = 504,</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Message bus errors (600-699)</span></div>
<div class="line">    topic_not_found = 600,</div>
<div class="line">    handler_not_found = 601,</div>
<div class="line">    message_too_large = 602,</div>
<div class="line">    queue_full = 603,</div>
<div class="line">    publish_failed = 604</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md347"></a>
Error Handling</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>system_error : <span class="keyword">public</span> std::exception {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    system_error(error_code code, <span class="keyword">const</span> std::string&amp; message);</div>
<div class="line">    error_code code() <span class="keyword">const</span>;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* what() const noexcept override;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">try {</div>
<div class="line">    <span class="keywordflow">if</span> (!connection.is_connected()) {</div>
<div class="line">        <span class="keywordflow">throw</span> system_error(error_code::connection_failed,</div>
<div class="line">                          <span class="stringliteral">&quot;Unable to establish connection to server&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> system_error&amp; e) {</div>
<div class="line">    logger.error(<span class="stringliteral">&quot;Error {}: {}&quot;</span>, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(e.code()), e.what());</div>
<div class="line">    <span class="comment">// Handle specific error code</span></div>
<div class="line">    <span class="keywordflow">if</span> (e.code() == error_code::connection_timeout) {</div>
<div class="line">        retry_connection();</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md348"></a>
Error Recovery Strategies</h2>
<div class="fragment"><div class="line"><span class="comment">// Retry with exponential backoff</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> retry_with_backoff(Func&amp;&amp; func, <span class="keywordtype">size_t</span> max_retries = 3) {</div>
<div class="line">    <span class="keywordtype">size_t</span> delay_ms = 100;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; max_retries; ++i) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="keywordflow">return</span> func();</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> system_error&amp; e) {</div>
<div class="line">            <span class="keywordflow">if</span> (i == max_retries - 1) <span class="keywordflow">throw</span>;</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(delay_ms));</div>
<div class="line">            delay_ms *= 2;  <span class="comment">// Exponential backoff</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Circuit breaker pattern</span></div>
<div class="line"><span class="keyword">class </span>circuit_breaker {</div>
<div class="line">    <span class="keyword">enum</span> state { closed, open, half_open };</div>
<div class="line">    state current_state = closed;</div>
<div class="line">    <span class="keywordtype">size_t</span> failure_count = 0;</div>
<div class="line">    <span class="keywordtype">size_t</span> failure_threshold = 5;</div>
<div class="line">    std::chrono::steady_clock::time_point last_failure_time;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</div>
<div class="line">    <span class="keyword">auto</span> call(Func&amp;&amp; func) {</div>
<div class="line">        <span class="keywordflow">if</span> (current_state == open) {</div>
<div class="line">            <span class="keywordflow">if</span> (should_attempt_reset()) {</div>
<div class="line">                current_state = half_open;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">throw</span> system_error(error_code::service_unavailable,</div>
<div class="line">                                 <span class="stringliteral">&quot;Circuit breaker is open&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="keyword">auto</span> result = func();</div>
<div class="line">            on_success();</div>
<div class="line">            <span class="keywordflow">return</span> result;</div>
<div class="line">        } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">            on_failure();</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> on_success() {</div>
<div class="line">        failure_count = 0;</div>
<div class="line">        current_state = closed;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_failure() {</div>
<div class="line">        failure_count++;</div>
<div class="line">        last_failure_time = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keywordflow">if</span> (failure_count &gt;= failure_threshold) {</div>
<div class="line">            current_state = open;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> should_attempt_reset() {</div>
<div class="line">        <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> time_since_failure = now - last_failure_time;</div>
<div class="line">        <span class="keywordflow">return</span> time_since_failure &gt; std::chrono::seconds(30);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md349"></a>
Configuration Reference</h1>
<h2><a class="anchor" id="autotoc_md350"></a>
System Configuration File Format</h2>
<div class="fragment"><div class="line">; messaging_config.ini</div>
<div class="line"> </div>
<div class="line">[system]</div>
<div class="line">worker_threads = 8</div>
<div class="line">max_memory_mb = 4096</div>
<div class="line">enable_monitoring = true</div>
<div class="line">monitoring_port = 9090</div>
<div class="line"> </div>
<div class="line">[network]</div>
<div class="line">listen_address = 0.0.0.0</div>
<div class="line">listen_port = 8080</div>
<div class="line">max_connections = 10000</div>
<div class="line">connection_timeout_ms = 5000</div>
<div class="line">keepalive_interval_s = 30</div>
<div class="line">enable_ssl = true</div>
<div class="line">ssl_cert_file = /path/to/cert.pem</div>
<div class="line">ssl_key_file = /path/to/key.pem</div>
<div class="line"> </div>
<div class="line">[database]</div>
<div class="line">type = postgresql</div>
<div class="line">host = localhost</div>
<div class="line">port = 5432</div>
<div class="line">database = messaging_db</div>
<div class="line">username = app_user</div>
<div class="line">password = ${DB_PASSWORD}  ; Environment variable</div>
<div class="line">pool_size = 20</div>
<div class="line">connection_timeout_ms = 3000</div>
<div class="line"> </div>
<div class="line">[message_bus]</div>
<div class="line">worker_threads = 4</div>
<div class="line">queue_size = 50000</div>
<div class="line">enable_persistence = true</div>
<div class="line">persistence_path = /var/lib/messaging/queue</div>
<div class="line">enable_metrics = true</div>
<div class="line"> </div>
<div class="line">[logging]</div>
<div class="line">level = info</div>
<div class="line">console_enabled = true</div>
<div class="line">file_enabled = true</div>
<div class="line">log_directory = /var/log/messaging</div>
<div class="line">max_file_size_mb = 100</div>
<div class="line">max_files = 10</div>
<div class="line">async_logging = true</div>
<div class="line"> </div>
<div class="line">[security]</div>
<div class="line">enable_authentication = true</div>
<div class="line">auth_type = jwt</div>
<div class="line">jwt_secret = ${JWT_SECRET}</div>
<div class="line">token_expiry_minutes = 60</div>
<div class="line">enable_rate_limiting = true</div>
<div class="line">rate_limit_requests = 1000</div>
<div class="line">rate_limit_window_seconds = 60</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md351"></a>
Environment Variables</h2>
<div class="fragment"><div class="line"># Database configuration</div>
<div class="line">export DB_HOST=localhost</div>
<div class="line">export DB_PORT=5432</div>
<div class="line">export DB_NAME=messaging_db</div>
<div class="line">export DB_USER=app_user</div>
<div class="line">export DB_PASSWORD=secure_password</div>
<div class="line"> </div>
<div class="line"># Network configuration</div>
<div class="line">export MESSAGING_PORT=8080</div>
<div class="line">export MESSAGING_BIND_ADDRESS=0.0.0.0</div>
<div class="line"> </div>
<div class="line"># Security</div>
<div class="line">export JWT_SECRET=your_jwt_secret_key</div>
<div class="line">export SSL_CERT_PATH=/path/to/cert.pem</div>
<div class="line">export SSL_KEY_PATH=/path/to/key.pem</div>
<div class="line"> </div>
<div class="line"># Performance tuning</div>
<div class="line">export WORKER_THREADS=8</div>
<div class="line">export MAX_CONNECTIONS=10000</div>
<div class="line">export QUEUE_SIZE=50000</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
