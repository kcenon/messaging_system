<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: Thread System: Patterns, Best Practices, and Troubleshooting Guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d5/de2/md_libraries_2thread__system_2docs_2patterns.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Thread System: Patterns, Best Practices, and Troubleshooting Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md3108"></a> This comprehensive guide covers patterns, best practices, antipatterns to avoid, and solutions to common concurrency issues when working with Thread System. Following these guidelines will help you write efficient, maintainable, and bug-free concurrent applications.</p>
<h1><a class="anchor" id="autotoc_md3109"></a>
Table of Contents</h1>
<ol type="1">
<li>Best Practices</li>
<li>Common Patterns</li>
<li>Antipatterns to Avoid</li>
<li>Troubleshooting Common Issues</li>
<li>Advanced Concurrency Patterns</li>
<li>Debugging Concurrent Code</li>
<li>Performance Optimization</li>
<li>Integrating External Modules</li>
</ol>
<h1><a class="anchor" id="autotoc_md3110"></a>
Best Practices</h1>
<h2><a class="anchor" id="autotoc_md3111"></a>
1. Thread Base Usage</h2>
<h3><a class="anchor" id="autotoc_md3112"></a>
✅ DO:</h3>
<ul>
<li>Derive from <code>thread_base</code> when implementing custom worker threads</li>
<li>Override <code>before_start()</code>, <code>do_work()</code>, and <code>after_stop()</code> to customize behavior</li>
<li>Implement proper cleanup in your <code>after_stop()</code> method</li>
<li>Use the <code>set_wake_interval()</code> method for periodic operations</li>
<li>Check <code>should_continue_work()</code> regularly in long-running operations</li>
</ul>
<h3><a class="anchor" id="autotoc_md3113"></a>
❌ DON'T:</h3>
<ul>
<li>Call <code>start()</code> from within constructors</li>
<li>Directly manipulate the underlying thread</li>
<li>Implement tight loops without condition checks</li>
<li>Ignore return values from <code>start()</code> and <code>stop()</code></li>
<li>Use thread-unsafe operations inside <code>do_work()</code> without proper synchronization</li>
</ul>
<h2><a class="anchor" id="autotoc_md3114"></a>
2. Thread Pool Usage</h2>
<h3><a class="anchor" id="autotoc_md3115"></a>
✅ DO:</h3>
<ul>
<li>Use <code>thread_pool</code> for CPU-bound tasks</li>
<li>Create an appropriate number of worker threads (typically core count or core count + 1)</li>
<li>Batch-submit jobs when possible using <code>enqueue_batch()</code></li>
<li>Use callback jobs for most operations</li>
<li>Properly handle errors returned from job execution</li>
</ul>
<h3><a class="anchor" id="autotoc_md3116"></a>
❌ DON'T:</h3>
<ul>
<li>Create too many thread pools (one per application is often sufficient)</li>
<li>Create an excessive number of worker threads (can lead to context switching overhead)</li>
<li>Use thread pools for I/O-bound tasks without careful consideration</li>
<li>Submit individual jobs in a tight loop (use batch submission instead)</li>
<li>Block worker threads with long-running synchronous operations</li>
</ul>
<h2><a class="anchor" id="autotoc_md3117"></a>
3. Type Thread Pool Usage</h2>
<h3><a class="anchor" id="autotoc_md3118"></a>
✅ DO:</h3>
<ul>
<li>Use distinct type levels for different types of tasks</li>
<li>Create dedicated workers for critical type levels</li>
<li>Use lower type for background or maintenance tasks</li>
<li>Consider custom type types for domain-specific scheduling</li>
<li>Monitor queue sizes per type to ensure balanced execution</li>
</ul>
<h3><a class="anchor" id="autotoc_md3119"></a>
❌ DON'T:</h3>
<ul>
<li>Assign high type to all tasks (defeats the purpose)</li>
<li>Create too many type levels (3-5 levels are typically sufficient)</li>
<li>Ignore type inversion issues</li>
<li>Use types inconsistently across the application</li>
<li>Create type workers without assigning appropriate jobs</li>
</ul>
<h2><a class="anchor" id="autotoc_md3120"></a>
4. Error Handling</h2>
<h3><a class="anchor" id="autotoc_md3121"></a>
✅ DO:</h3>
<ul>
<li>Always check return values from Thread System functions</li>
<li>Use the <code>result&lt;T&gt;</code> or <code>std::optional&lt;std::string&gt;</code> error patterns</li>
<li>Implement custom error handlers when needed</li>
<li>Provide meaningful error messages with context</li>
<li>Handle errors appropriately at each layer</li>
</ul>
<h3><a class="anchor" id="autotoc_md3122"></a>
❌ DON'T:</h3>
<ul>
<li>Ignore error return values</li>
<li>Let exceptions propagate from worker threads without handling</li>
<li>Use generic error messages without context</li>
<li>Assume operations will always succeed</li>
<li>Mix different error handling patterns inconsistently</li>
</ul>
<h1><a class="anchor" id="autotoc_md3123"></a>
Common Patterns</h1>
<h2><a class="anchor" id="autotoc_md3124"></a>
1. Worker Thread Pattern</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyWorker : <span class="keyword">public</span> thread_module::thread_base {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">auto</span> before_start() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        <span class="comment">// Initialize resources</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> do_work() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        <span class="comment">// Perform work here</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> should_continue_work() const -&gt; <span class="keywordtype">bool</span><span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Logic to determine if more work is needed</span></div>
<div class="line">        <span class="keywordflow">return</span> !work_queue_.empty();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> after_stop() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        <span class="comment">// Cleanup resources</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Worker-specific members</span></div>
<div class="line">    std::queue&lt;WorkItem&gt; work_queue_;</div>
<div class="line">};</div>
<div class="ttc" id="abenchmarks_2thread__pool__benchmarks_2benchmark__common_8h_html_a13fa946184c58584adc65e45561d6772"><div class="ttname"><a href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a></div><div class="ttdeci">thread_module::result_void result_void</div><div class="ttdef"><b>Definition</b> <a href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h_source.html#l00012">benchmark_common.h:12</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3125"></a>
2. Thread Pool Task Processing Pattern</h2>
<div class="fragment"><div class="line"><span class="comment">// Create a thread pool</span></div>
<div class="line"><span class="keyword">auto</span> [pool, error] = <a class="code hl_function" href="../../da/dfb/benchmarks_2thread__pool__benchmarks_2comparison__benchmark_8cpp.html#a75b6b3ce3590f7f29e3a71cc698bb69a">create_default</a>(<a class="code hl_variable" href="../../d5/de9/thread__pool__sample_8cpp.html#a9a50567581c61a4eaf50dce126dadac6">thread_counts_</a>);</div>
<div class="line"><span class="keywordflow">if</span> (error.has_value()) {</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a batch of jobs</span></div>
<div class="line">std::vector&lt;std::unique_ptr&lt;thread_module::job&gt;&gt; jobs;</div>
<div class="line">jobs.reserve(task_count);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; task_count; ++i) {</div>
<div class="line">    jobs.push_back(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">        [i]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">            <span class="comment">// Process task</span></div>
<div class="line">            <span class="keywordflow">return</span> std::nullopt; <span class="comment">// Success</span></div>
<div class="line">        }</div>
<div class="line">    ));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit jobs as a batch for efficiency</span></div>
<div class="line"><a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = pool-&gt;enqueue_batch(std::move(jobs));</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start processing</span></div>
<div class="line"><a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = pool-&gt;start();</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When done, stop the pool</span></div>
<div class="line">pool-&gt;stop();</div>
<div class="ttc" id="abenchmarks_2thread__pool__benchmarks_2comparison__benchmark_8cpp_html_a75b6b3ce3590f7f29e3a71cc698bb69a"><div class="ttname"><a href="../../da/dfb/benchmarks_2thread__pool__benchmarks_2comparison__benchmark_8cpp.html#a75b6b3ce3590f7f29e3a71cc698bb69a">create_default</a></div><div class="ttdeci">auto create_default(const uint16_t &amp;worker_counts) -&gt; std::tuple&lt; std::shared_ptr&lt; kcenon::thread::thread_pool &gt;, std::optional&lt; std::string &gt; &gt;</div><div class="ttdef"><b>Definition</b> <a href="../../da/dfb/benchmarks_2thread__pool__benchmarks_2comparison__benchmark_8cpp_source.html#l00068">comparison_benchmark.cpp:68</a></div></div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1integrations_html_a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282"><div class="ttname"><a href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">kcenon::messaging::integrations::external_system_status::error</a></div><div class="ttdeci">@ error</div></div>
<div class="ttc" id="athread__pool__sample_8cpp_html_a9a50567581c61a4eaf50dce126dadac6"><div class="ttname"><a href="../../d5/de9/thread__pool__sample_8cpp.html#a9a50567581c61a4eaf50dce126dadac6">thread_counts_</a></div><div class="ttdeci">uint16_t thread_counts_</div><div class="ttdef"><b>Definition</b> <a href="../../d5/de9/thread__pool__sample_8cpp_source.html#l00052">thread_pool_sample.cpp:52</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3126"></a>
3. Type-Based Job Execution Pattern</h2>
<div class="fragment"><div class="line"><span class="comment">// Create a type thread pool with different type workers</span></div>
<div class="line"><span class="keyword">auto</span> [pool, error] = create_type_pool(</div>
<div class="line">    high_type_workers_,</div>
<div class="line">    normal_type_workers_,</div>
<div class="line">    low_type_workers_</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creating jobs with different types</span></div>
<div class="line">std::vector&lt;std::unique_ptr&lt;typed_thread_pool_module::typed_job&gt;&gt; jobs;</div>
<div class="line">jobs.reserve(job_count);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// High type critical tasks</span></div>
<div class="line">jobs.push_back(std::make_unique&lt;typed_thread_pool_module::callback_typed_job&gt;(</div>
<div class="line">    []() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> {</div>
<div class="line">        <span class="comment">// Critical operation</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    },</div>
<div class="line">    typed_thread_pool_module::job_types::High</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Normal type regular tasks</span></div>
<div class="line">jobs.push_back(std::make_unique&lt;typed_thread_pool_module::callback_typed_job&gt;(</div>
<div class="line">    []() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> {</div>
<div class="line">        <span class="comment">// Regular operation</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    },</div>
<div class="line">    typed_thread_pool_module::job_types::Normal</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Low type background tasks</span></div>
<div class="line">jobs.push_back(std::make_unique&lt;typed_thread_pool_module::callback_typed_job&gt;(</div>
<div class="line">    []() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> {</div>
<div class="line">        <span class="comment">// Background operation</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    },</div>
<div class="line">    typed_thread_pool_module::job_types::Low</div>
<div class="line">));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3127"></a>
4. Error Handler Pattern</h2>
<div class="fragment"><div class="line"><span class="comment">// Implement a custom error handler for thread operations</span></div>
<div class="line"><span class="keyword">class </span>ApplicationErrorHandler : <span class="keyword">public</span> thread_module::error_handler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> handle_error(<span class="keyword">const</span> std::string&amp; error_message)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Handle errors according to your application needs</span></div>
<div class="line">        <span class="comment">// Could write to a log file, send to monitoring system, etc.</span></div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Thread error: &quot;</span> &lt;&lt; error_message &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// If using external logger module:</span></div>
<div class="line">        <span class="comment">// if (logger_) {</span></div>
<div class="line">        <span class="comment">//     logger_-&gt;write_error(&quot;Thread error: {}&quot;, error_message);</span></div>
<div class="line">        <span class="comment">// }</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Optional: reference to external logger</span></div>
<div class="line">    <span class="comment">// std::shared_ptr&lt;logger_interface&gt; logger_;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use the error handler</span></div>
<div class="line"><span class="keyword">auto</span> error_handler = std::make_shared&lt;ApplicationErrorHandler&gt;();</div>
<div class="line">thread_pool-&gt;set_error_handler(error_handler);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3128"></a>
5. Producer-Consumer Pattern</h2>
<div class="fragment"><div class="line"><span class="comment">// Consumer thread worker</span></div>
<div class="line"><span class="keyword">class </span>ConsumerWorker : <span class="keyword">public</span> thread_module::thread_base {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">auto</span> do_work() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Wait for data or stop signal</span></div>
<div class="line">        data_condition_.wait(lock, [<span class="keyword">this</span>]() {</div>
<div class="line">            <span class="keywordflow">return</span> !data_queue_.empty() || !should_continue_work();</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Check if should terminate</span></div>
<div class="line">        <span class="keywordflow">if</span> (!should_continue_work()) {</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Process data</span></div>
<div class="line">        <span class="keyword">auto</span> data = std::move(data_queue_.front());</div>
<div class="line">        data_queue_.pop();</div>
<div class="line">        </div>
<div class="line">        lock.unlock();</div>
<div class="line">        process_data(data);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::mutex queue_mutex_;</div>
<div class="line">    std::condition_variable data_condition_;</div>
<div class="line">    std::queue&lt;Data&gt; data_queue_;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> process_data(<span class="keyword">const</span> Data&amp; data) {</div>
<div class="line">        <span class="comment">// Process the data</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3129"></a>
6. Task Partitioning Pattern</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> process_large_dataset(<span class="keyword">const</span> std::vector&lt;Data&gt;&amp; dataset) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> thread_count = std::thread::hardware_concurrency();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size = (dataset.size() + thread_count - 1) / thread_count;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create thread pool</span></div>
<div class="line">    <span class="keyword">auto</span> [pool, error] = <a class="code hl_function" href="../../da/dfb/benchmarks_2thread__pool__benchmarks_2comparison__benchmark_8cpp.html#a75b6b3ce3590f7f29e3a71cc698bb69a">create_default</a>(thread_count);</div>
<div class="line">    <span class="keywordflow">if</span> (error.has_value()) {</div>
<div class="line">        <span class="comment">// Handle error appropriately - could use external logger if available</span></div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create thread pool: &quot;</span> &lt;&lt; error.value() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Submit chunks as separate jobs</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_module::job&gt;&gt; jobs;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; thread_count; ++i) {</div>
<div class="line">        <span class="keywordtype">size_t</span> start_idx = i * chunk_size;</div>
<div class="line">        <span class="keywordtype">size_t</span> end_idx = std::min(start_idx + chunk_size, dataset.size());</div>
<div class="line">        </div>
<div class="line">        jobs.push_back(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [&amp;dataset, start_idx, end_idx]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = start_idx; j &lt; end_idx; ++j) {</div>
<div class="line">                    process_item(dataset[j]);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pool-&gt;enqueue_batch(std::move(jobs));</div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    pool-&gt;stop(); <span class="comment">// Wait for all jobs to complete</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3130"></a>
Antipatterns to Avoid</h1>
<h2><a class="anchor" id="autotoc_md3131"></a>
1. The Thread Explosion Antipattern</h2>
<p>❌ <b>Problematic Approach</b>: </p><div class="fragment"><div class="line"><span class="comment">// Creating a new thread for each small task</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">    <span class="keyword">auto</span> thread = std::make_unique&lt;thread_module::thread_base&gt;();</div>
<div class="line">    thread-&gt;start();</div>
<div class="line">    <span class="comment">// Process item in thread</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>✅ <b>Better Approach</b>: </p><div class="fragment"><div class="line"><span class="comment">// Create a single thread pool</span></div>
<div class="line"><span class="keyword">auto</span> thread_pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit all items as jobs</span></div>
<div class="line">std::vector&lt;std::unique_ptr&lt;thread_module::job&gt;&gt; jobs;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">    jobs.push_back(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">        [item]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">            <span class="comment">// Process item</span></div>
<div class="line">            <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">        }</div>
<div class="line">    ));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Process all items with the thread pool</span></div>
<div class="line">thread_pool-&gt;enqueue_batch(std::move(jobs));</div>
<div class="line">thread_pool-&gt;start();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3132"></a>
2. The Busy Waiting Antipattern</h2>
<p>❌ <b>Problematic Approach</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> do_work() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">    <span class="comment">// Continuously check if work is available without yielding</span></div>
<div class="line">    <span class="keywordflow">while</span> (!work_available()) {</div>
<div class="line">        <span class="comment">// Tight loop consuming CPU</span></div>
<div class="line">    }</div>
<div class="line">    process_work();</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --><p>✅ <b>Better Approach</b>: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> do_work() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">    <span class="comment">// Use condition variables and wake intervals</span></div>
<div class="line">    <span class="keywordflow">if</span> (!work_available()) {</div>
<div class="line">        <span class="comment">// Return and let the thread sleep until next wake interval</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">    process_work();</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3133"></a>
3. The Type Abuse Antipattern</h2>
<p>❌ <b>Problematic Approach</b>: </p><div class="fragment"><div class="line"><span class="comment">// Marking all jobs as high type</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; job_count; ++i) {</div>
<div class="line">    jobs.push_back(std::make_unique&lt;callback_typed_job&gt;(</div>
<div class="line">        [i]() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> {</div>
<div class="line">            <span class="comment">// Regular task</span></div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        },</div>
<div class="line">        job_types::High <span class="comment">// All jobs set to high type</span></div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --><p>✅ <b>Better Approach</b>: </p><div class="fragment"><div class="line"><span class="comment">// Assign appropriate types based on task importance</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> i = 0; i &lt; job_count; ++i) {</div>
<div class="line">    <span class="comment">// Determine appropriate type based on task characteristics</span></div>
<div class="line">    <span class="keyword">auto</span> type = determine_appropriate_type(i);</div>
<div class="line">    </div>
<div class="line">    jobs.push_back(std::make_unique&lt;callback_typed_job&gt;(</div>
<div class="line">        [i]() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> {</div>
<div class="line">            <span class="comment">// Regular task</span></div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        },</div>
<div class="line">        type</div>
<div class="line">    ));</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3134"></a>
4. The Blocking Thread Pool Antipattern</h2>
<p>❌ <b>Problematic Approach</b>: </p><div class="fragment"><div class="line"><span class="comment">// Submitting I/O-bound or blocking operations to thread pool</span></div>
<div class="line">pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    []() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        <span class="comment">// Perform long-running I/O operation that blocks</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(10));</div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    }</div>
<div class="line">));</div>
</div><!-- fragment --><p>✅ <b>Better Approach</b>: </p><div class="fragment"><div class="line"><span class="comment">// Use asynchronous I/O or dedicated threads for blocking operations</span></div>
<div class="line"><span class="comment">// For I/O-bound operations, consider async I/O or a dedicated thread pool</span></div>
<div class="line"><span class="keyword">auto</span> io_thread = std::make_unique&lt;thread_module::thread_base&gt;(<span class="stringliteral">&quot;io_thread&quot;</span>);</div>
<div class="line">io_thread-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use the main thread pool for CPU-bound work only</span></div>
<div class="line">pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    []() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        <span class="comment">// CPU-bound computation</span></div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    }</div>
<div class="line">));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3135"></a>
5. The Performance Monitoring Antipattern</h2>
<p>❌ <b>Problematic Approach</b>: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; i++) {</div>
<div class="line">    <span class="comment">// Recording metrics for every single operation</span></div>
<div class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div>
<div class="line">    <span class="comment">// Process item</span></div>
<div class="line">    <span class="keyword">auto</span> end = std::chrono::steady_clock::now();</div>
<div class="line">    <span class="comment">// Recording every single operation creates overhead</span></div>
<div class="line">    record_metric(<span class="stringliteral">&quot;item_processed&quot;</span>, end - start);</div>
<div class="line">}</div>
</div><!-- fragment --><p>✅ <b>Better Approach</b>: </p><div class="fragment"><div class="line"><span class="comment">// Record metrics at appropriate intervals or aggregated</span></div>
<div class="line">std::atomic&lt;size_t&gt; processed_count{0};</div>
<div class="line"><span class="keyword">auto</span> batch_start = std::chrono::steady_clock::now();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; i++) {</div>
<div class="line">    <span class="comment">// Process item</span></div>
<div class="line">    processed_count++;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Record metrics periodically</span></div>
<div class="line">    <span class="keywordflow">if</span> (i % 10000 == 0) {</div>
<div class="line">        <span class="keyword">auto</span> now = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> elapsed = now - batch_start;</div>
<div class="line">        <span class="comment">// Record aggregated metrics</span></div>
<div class="line">        record_batch_metrics(10000, elapsed);</div>
<div class="line">        batch_start = now;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3136"></a>
Troubleshooting Common Issues</h1>
<h2><a class="anchor" id="autotoc_md3137"></a>
1. Race Conditions</h2>
<h3><a class="anchor" id="autotoc_md3138"></a>
Symptoms</h3>
<ul>
<li>Inconsistent or unexpected results</li>
<li>Program behavior varies between runs</li>
<li>Results depend on timing or system load</li>
<li>Intermittent crashes or data corruption</li>
</ul>
<h3><a class="anchor" id="autotoc_md3139"></a>
Solution Approaches</h3>
<ol type="1">
<li><b>Use mutex protection:</b> <div class="fragment"><div class="line">std::mutex counter_mutex_;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In thread code</span></div>
<div class="line">std::lock_guard&lt;std::mutex&gt; lock(counter_mutex_);</div>
<div class="line">counter_++;</div>
</div><!-- fragment --></li>
<li><b>Use atomic variables:</b> <div class="fragment"><div class="line">std::atomic&lt;int&gt; counter_{0};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// In thread code (no mutex needed)</span></div>
<div class="line">counter_++;</div>
</div><!-- fragment --></li>
<li><b>Use job-based design:</b> <div class="fragment"><div class="line"><span class="comment">// Define a counter modification job</span></div>
<div class="line"><span class="keyword">auto</span> increment_job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    [<span class="keyword">this</span>]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        counter_++;</div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit to thread pool</span></div>
<div class="line">thread_pool-&gt;enqueue(std::move(increment_job));</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md3140"></a>
2. Deadlocks</h2>
<h3><a class="anchor" id="autotoc_md3141"></a>
Symptoms</h3>
<ul>
<li>Program freezes or hangs</li>
<li>Multiple threads become unresponsive</li>
<li>No CPU usage despite program appearing to run</li>
<li>Deadlock detection tools report lock cycles</li>
</ul>
<h3><a class="anchor" id="autotoc_md3142"></a>
Solution Approaches</h3>
<ol type="1">
<li><b>Consistent lock ordering:</b> <div class="fragment"><div class="line"><span class="comment">// Always acquire locks in the same order</span></div>
<div class="line">std::lock_guard&lt;std::mutex&gt; lock1(mutex_a_); <span class="comment">// Always first</span></div>
<div class="line">std::lock_guard&lt;std::mutex&gt; lock2(mutex_b_); <span class="comment">// Always second</span></div>
</div><!-- fragment --></li>
<li><b>Use std::lock for multiple locks:</b> <div class="fragment"><div class="line">std::unique_lock&lt;std::mutex&gt; lock_a(mutex_a_, std::defer_lock);</div>
<div class="line">std::unique_lock&lt;std::mutex&gt; lock_b(mutex_b_, std::defer_lock);</div>
<div class="line">std::lock(lock_a, lock_b); <span class="comment">// Atomic acquisition of both locks</span></div>
</div><!-- fragment --></li>
<li><b>Avoid nested locks where possible:</b> <div class="fragment"><div class="line"><span class="comment">// Instead of nested locks, acquire all needed locks upfront</span></div>
<div class="line">{</div>
<div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">    <span class="comment">// Do all work requiring the lock here</span></div>
<div class="line">}</div>
<div class="line"><span class="comment">// Then do work not requiring the lock</span></div>
</div><!-- fragment --></li>
<li><b>Use lock timeouts to detect deadlocks:</b> <div class="fragment"><div class="line">std::unique_lock&lt;std::mutex&gt; lock(mutex_, std::chrono::seconds(5));</div>
<div class="line"><span class="keywordflow">if</span> (!lock) {</div>
<div class="line">    <span class="comment">// Handle potential deadlock - log error if logger is available</span></div>
<div class="line">    handle_error(<span class="stringliteral">&quot;Potential deadlock detected - could not acquire lock within timeout&quot;</span>);</div>
<div class="line">    <span class="comment">// Implement recovery strategy</span></div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md3143"></a>
3. Type Inversion</h2>
<h3><a class="anchor" id="autotoc_md3144"></a>
Symptoms</h3>
<ul>
<li>High-type tasks experience unexpected delays</li>
<li>System responsiveness is inconsistent</li>
<li>Critical jobs take longer than lower-type ones</li>
</ul>
<h3><a class="anchor" id="autotoc_md3145"></a>
Solution Approaches</h3>
<ol type="1">
<li><b>Minimize resource sharing across type boundaries:</b> <div class="fragment"><div class="line"><span class="comment">// Design your system to minimize cases where high and low type</span></div>
<div class="line"><span class="comment">// threads need to share resources. Use separate resources when possible.</span></div>
<div class="line"><span class="keyword">auto</span> high_type_resources = std::make_unique&lt;ResourcePool&gt;(<span class="stringliteral">&quot;high&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> low_type_resources = std::make_unique&lt;ResourcePool&gt;(<span class="stringliteral">&quot;low&quot;</span>);</div>
</div><!-- fragment --></li>
<li><b>Use type ceilings:</b> <div class="fragment"><div class="line"><span class="comment">// When a low-type thread acquires a critical resource,</span></div>
<div class="line"><span class="comment">// temporarily boost its type</span></div>
<div class="line"><span class="keyword">auto</span> original_type = get_current_type();</div>
<div class="line">set_current_type(high_type);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Critical section with shared resource</span></div>
<div class="line">{</div>
<div class="line">    std::lock_guard&lt;std::mutex&gt; lock(shared_mutex_);</div>
<div class="line">    <span class="comment">// Work with shared resource</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Restore original type</span></div>
<div class="line">set_current_type(original_type);</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md3146"></a>
4. Thread Starvation</h2>
<h3><a class="anchor" id="autotoc_md3147"></a>
Symptoms</h3>
<ul>
<li>Certain tasks never complete or experience extreme delays</li>
<li>Some threads never get CPU time</li>
<li>System seems to focus on a subset of available work</li>
</ul>
<h3><a class="anchor" id="autotoc_md3148"></a>
Solution Approaches</h3>
<ol type="1">
<li><b>Dedicate workers to each type level:</b> <div class="fragment"><div class="line"><span class="comment">// Create workers specifically for low-type tasks</span></div>
<div class="line"><span class="keyword">auto</span> low_worker = std::make_unique&lt;typed_thread_worker&gt;(</div>
<div class="line">    std::vector&lt;job_types&gt;{job_types::Low},</div>
<div class="line">    <span class="stringliteral">&quot;low_type_worker&quot;</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">type_pool-&gt;enqueue(std::move(low_worker));</div>
</div><!-- fragment --></li>
<li><b>Implement aging for low-type tasks:</b> <div class="fragment"><div class="line"><span class="keyword">class </span>AgingJob : <span class="keyword">public</span> typed_job {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AgingJob(std::function&lt;<a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a>()&gt; func)</div>
<div class="line">        : typed_job(job_types::<a class="code hl_enumvalue" href="../../d6/dbc/benchmarks_2thread__pool__benchmarks_2stress__test__benchmark_8cpp.html#a1d1cfd8ffb84e947f82999c682b666a7a28d0edd045e05cf5af64e35ae0c4c6ef">Low</a>), func_(func), </div>
<div class="line">          creation_time_(std::chrono::steady_clock::now()) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> get_type() const -&gt; job_types<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keyword">auto</span> age = std::chrono::steady_clock::now() - creation_time_;</div>
<div class="line">        <span class="keywordflow">if</span> (age &gt; std::chrono::minutes(5)) {</div>
<div class="line">            <span class="keywordflow">return</span> job_types::High;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (age &gt; std::chrono::minutes(1)) {</div>
<div class="line">            <span class="keywordflow">return</span> job_types::Normal;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> job_types::Low;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::function&lt;<a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a>()&gt; func_;</div>
<div class="line">    std::chrono::steady_clock::time_point creation_time_;</div>
<div class="line">};</div>
<div class="ttc" id="abenchmarks_2thread__pool__benchmarks_2stress__test__benchmark_8cpp_html_a1d1cfd8ffb84e947f82999c682b666a7a28d0edd045e05cf5af64e35ae0c4c6ef"><div class="ttname"><a href="../../d6/dbc/benchmarks_2thread__pool__benchmarks_2stress__test__benchmark_8cpp.html#a1d1cfd8ffb84e947f82999c682b666a7a28d0edd045e05cf5af64e35ae0c4c6ef">Type::Low</a></div><div class="ttdeci">@ Low</div></div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md3149"></a>
5. False Sharing</h2>
<h3><a class="anchor" id="autotoc_md3150"></a>
Symptoms</h3>
<ul>
<li>Unexpectedly poor performance in multi-threaded code</li>
<li>Performance degrades as more cores are used</li>
<li>CPU cache profiling shows high cache coherence traffic</li>
</ul>
<h3><a class="anchor" id="autotoc_md3151"></a>
Solution Approaches</h3>
<ol type="1">
<li><b>Pad data structures to avoid false sharing:</b> <div class="fragment"><div class="line"><span class="keyword">struct </span><span class="keyword">alignas</span>(64) PaddedCounter {</div>
<div class="line">    std::atomic&lt;int&gt; value{0};</div>
<div class="line">    <span class="keywordtype">char</span> padding[64 - <span class="keyword">sizeof</span>(std::atomic&lt;int&gt;)];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">PaddedCounter counter1_;</div>
<div class="line">PaddedCounter counter2_;</div>
</div><!-- fragment --></li>
<li><b>Use thread-local storage for counters:</b> <div class="fragment"><div class="line"><span class="keyword">thread_local</span> <span class="keywordtype">int</span> local_counter_ = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Each thread updates its own counter</span></div>
<div class="line"><span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    []() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        local_counter_++;</div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md3152"></a>
6. Memory Visibility Issues</h2>
<h3><a class="anchor" id="autotoc_md3153"></a>
Symptoms</h3>
<ul>
<li>Threads don't "see" updates made by other threads</li>
<li>Stale data is used in calculations</li>
<li>Non-atomic operations on shared variables cause corruption</li>
</ul>
<h3><a class="anchor" id="autotoc_md3154"></a>
Solution Approaches</h3>
<ol type="1">
<li><b>Use atomic variables for flags:</b> <div class="fragment"><div class="line">std::atomic&lt;bool&gt; done_{<span class="keyword">false</span>};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Thread 1</span></div>
<div class="line">done_.store(<span class="keyword">true</span>, std::memory_order_release);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Thread 2</span></div>
<div class="line"><span class="keywordflow">while</span> (!done_.load(std::memory_order_acquire)) {</div>
<div class="line">    std::this_thread::yield();</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Use proper synchronization primitives:</b> <div class="fragment"><div class="line">std::mutex mutex_;</div>
<div class="line"><span class="keywordtype">bool</span> done_ = <span class="keyword">false</span>;</div>
<div class="line">std::condition_variable cv_;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Thread 1</span></div>
<div class="line">{</div>
<div class="line">    std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">    done_ = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line">cv_.notify_all();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Thread 2</span></div>
<div class="line">{</div>
<div class="line">    std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">    cv_.wait(lock, [<span class="keyword">this</span>]() { <span class="keywordflow">return</span> done_; });</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="autotoc_md3155"></a>
Advanced Concurrency Patterns</h1>
<h2><a class="anchor" id="autotoc_md3156"></a>
1. Event-Based Communication</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>EventSystem {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>EventHandler = std::function&lt;void(<span class="keyword">const</span> Event&amp;)&gt;;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> subscribe(EventType type, EventHandler handler) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        handlers_[type].push_back(handler);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> publish(<span class="keyword">const</span> Event&amp; event) {</div>
<div class="line">        std::vector&lt;EventHandler&gt; handlers_to_call;</div>
<div class="line">        </div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">            <span class="keyword">auto</span> it = handlers_.find(event.type);</div>
<div class="line">            <span class="keywordflow">if</span> (it != handlers_.end()) {</div>
<div class="line">                handlers_to_call = it-&gt;second;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Submit each handler to the thread pool</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; handler : handlers_to_call) {</div>
<div class="line">            thread_pool_-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">                [handler, event]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">                    handler(event);</div>
<div class="line">                    <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">                }</div>
<div class="line">            ));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    std::map&lt;EventType, std::vector&lt;EventHandler&gt;&gt; handlers_;</div>
<div class="line">    std::shared_ptr&lt;thread_pool_module::thread_pool&gt; thread_pool_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3157"></a>
2. Work Stealing Pattern</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>WorkStealingPool {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    WorkStealingPool(<span class="keywordtype">size_t</span> worker_count) {</div>
<div class="line">        <span class="comment">// Create per-worker queues</span></div>
<div class="line">        queues_.resize(worker_count);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Create workers</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; worker_count; ++i) {</div>
<div class="line">            workers_.push_back(std::make_unique&lt;WorkStealingWorker&gt;(</div>
<div class="line">                i, queues_, *<span class="keyword">this</span></div>
<div class="line">            ));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> enqueue(std::unique_ptr&lt;thread_module::job&gt; job, <span class="keywordtype">size_t</span> preferred_worker) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">        <span class="keywordflow">if</span> (preferred_worker &gt;= queues_.size()) {</div>
<div class="line">            preferred_worker = 0;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        queues_[preferred_worker].enqueue(std::move(job));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;WorkStealingWorker&gt;&gt; workers_;</div>
<div class="line">    std::vector&lt;JobQueue&gt; queues_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>WorkStealingWorker : <span class="keyword">public</span> thread_module::thread_base {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">auto</span> do_work() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        <span class="comment">// Try to get job from own queue</span></div>
<div class="line">        <span class="keyword">auto</span> job = queues_[worker_id_].dequeue();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// If no job, try to steal from other queues</span></div>
<div class="line">        <span class="keywordflow">if</span> (!job) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; queues_.size(); ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (i == worker_id_) <span class="keywordflow">continue</span>;</div>
<div class="line">                </div>
<div class="line">                job = queues_[i].try_steal();</div>
<div class="line">                <span class="keywordflow">if</span> (job) <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// If we got a job, execute it</span></div>
<div class="line">        <span class="keywordflow">if</span> (job) {</div>
<div class="line">            job-&gt;execute();</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// No job found, let the thread sleep</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">size_t</span> worker_id_;</div>
<div class="line">    std::vector&lt;JobQueue&gt;&amp; queues_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3158"></a>
3. Read-Write Lock Pattern</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>ReadWriteLock {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> read_lock() {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        <span class="keywordflow">while</span> (write_count_ &gt; 0 || write_waiting_ &gt; 0) {</div>
<div class="line">            read_cv_.wait(lock);</div>
<div class="line">        }</div>
<div class="line">        read_count_++;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> read_unlock() {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        read_count_--;</div>
<div class="line">        <span class="keywordflow">if</span> (read_count_ == 0 &amp;&amp; write_waiting_ &gt; 0) {</div>
<div class="line">            write_cv_.notify_one();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> write_lock() {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        write_waiting_++;</div>
<div class="line">        <span class="keywordflow">while</span> (read_count_ &gt; 0 || write_count_ &gt; 0) {</div>
<div class="line">            write_cv_.wait(lock);</div>
<div class="line">        }</div>
<div class="line">        write_waiting_--;</div>
<div class="line">        write_count_++;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> write_unlock() {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        write_count_--;</div>
<div class="line">        <span class="keywordflow">if</span> (write_waiting_ &gt; 0) {</div>
<div class="line">            write_cv_.notify_one();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            read_cv_.notify_all();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    std::condition_variable read_cv_;</div>
<div class="line">    std::condition_variable write_cv_;</div>
<div class="line">    <span class="keywordtype">int</span> read_count_ = 0;</div>
<div class="line">    <span class="keywordtype">int</span> write_count_ = 0;</div>
<div class="line">    <span class="keywordtype">int</span> write_waiting_ = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3159"></a>
Debugging Concurrent Code</h1>
<h2><a class="anchor" id="autotoc_md3160"></a>
Using Diagnostics Effectively</h2>
<ol type="1">
<li><b>Track thread IDs for debugging:</b> <div class="fragment"><div class="line"><span class="comment">// Custom diagnostic helper</span></div>
<div class="line"><span class="keyword">class </span>ThreadDiagnostics {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> record_event(<span class="keyword">const</span> std::string&amp; event) {</div>
<div class="line">        <span class="keyword">auto</span> thread_id = std::this_thread::get_id();</div>
<div class="line">        <span class="keyword">auto</span> timestamp = std::chrono::steady_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Store or output diagnostic information</span></div>
<div class="line">        std::ostringstream oss;</div>
<div class="line">        oss &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; timestamp.time_since_epoch().count() </div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;][Thread &quot;</span> &lt;&lt; thread_id &lt;&lt; <span class="stringliteral">&quot;] &quot;</span> &lt;&lt; event;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Output to console, file, or external logger if available</span></div>
<div class="line">        std::cout &lt;&lt; oss.str() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li><b>Track state transitions:</b> <div class="fragment"><div class="line"><span class="keyword">auto</span> do_work() -&gt; <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">    ThreadDiagnostics::record_event(<span class="stringliteral">&quot;Worker state: entering critical section&quot;</span>);</div>
<div class="line">    {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        <span class="comment">// Critical section</span></div>
<div class="line">        ThreadDiagnostics::record_event(</div>
<div class="line">            <span class="stringliteral">&quot;Worker state: in critical section, count=&quot;</span> + std::to_string(count_)</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">    ThreadDiagnostics::record_event(<span class="stringliteral">&quot;Worker state: exited critical section&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Use sequence numbers for ordering events:</b> <div class="fragment"><div class="line">std::atomic&lt;uint64_t&gt; global_seq_{0};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> record_sequenced_event(<span class="keyword">const</span> std::string&amp; event) {</div>
<div class="line">    uint64_t seq = global_seq_++;</div>
<div class="line">    std::ostringstream oss;</div>
<div class="line">    oss &lt;&lt; <span class="stringliteral">&quot;[SEQ:&quot;</span> &lt;&lt; seq &lt;&lt; <span class="stringliteral">&quot;] &quot;</span> &lt;&lt; event;</div>
<div class="line">    ThreadDiagnostics::record_event(oss.str());</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md3161"></a>
Using Thread Sanitizers</h2>
<ol type="1">
<li><b>Enable ThreadSanitizer in your build:</b> <div class="fragment"><div class="line"># For GCC/Clang</div>
<div class="line">g++ -fsanitize=thread -g mycode.cpp</div>
<div class="line"> </div>
<div class="line"># For MSVC</div>
<div class="line"># Use /fsanitize=address in recent versions</div>
</div><!-- fragment --></li>
<li><b>Common issues detected by thread sanitizers:</b><ul>
<li>Data races</li>
<li>Deadlocks</li>
<li>Double-locking</li>
<li>Use-after-free in concurrent contexts</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md3162"></a>
Common Thread System Debugging Steps</h2>
<ol type="1">
<li><b>Verify thread pool startup:</b> <div class="fragment"><div class="line"><span class="keyword">auto</span> error = pool-&gt;start();</div>
<div class="line"><span class="keywordflow">if</span> (error.has_value()) {</div>
<div class="line">    <span class="comment">// Handle startup error</span></div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Thread pool failed to start: &quot;</span> </div>
<div class="line">              &lt;&lt; error.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Record successful startup</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Thread pool started successfully with &quot;</span> </div>
<div class="line">              &lt;&lt; pool-&gt;get_worker_count() &lt;&lt; <span class="stringliteral">&quot; workers&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li><b>Check job execution:</b> <div class="fragment"><div class="line"><span class="comment">// Add debugging to your job</span></div>
<div class="line"><span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    [](<span class="keywordtype">void</span>) -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        ThreadDiagnostics::record_event(<span class="stringliteral">&quot;Job started&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Your job logic here</span></div>
<div class="line">        </div>
<div class="line">        ThreadDiagnostics::record_event(<span class="stringliteral">&quot;Job completed&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="autotoc_md3163"></a>
Performance Optimization</h1>
<h2><a class="anchor" id="autotoc_md3164"></a>
Thread Pool Sizing Guidelines</h2>
<ol type="1">
<li><b>For CPU-bound tasks:</b> <div class="fragment"><div class="line"><span class="comment">// Use hardware concurrency as a baseline</span></div>
<div class="line"><span class="keyword">auto</span> thread_count = std::thread::hardware_concurrency();</div>
</div><!-- fragment --></li>
<li><b>For I/O-bound tasks:</b> <div class="fragment"><div class="line"><span class="comment">// Consider using more threads than cores</span></div>
<div class="line"><span class="keyword">auto</span> thread_count = std::thread::hardware_concurrency() * 2;</div>
</div><!-- fragment --></li>
<li><b>For mixed workloads:</b> <div class="fragment"><div class="line"><span class="comment">// Create separate pools for different workload types</span></div>
<div class="line"><span class="keyword">auto</span> cpu_pool = <a class="code hl_function" href="../../da/dfb/benchmarks_2thread__pool__benchmarks_2comparison__benchmark_8cpp.html#a75b6b3ce3590f7f29e3a71cc698bb69a">create_default</a>(std::thread::hardware_concurrency());</div>
<div class="line"><span class="keyword">auto</span> io_pool = <a class="code hl_function" href="../../da/dfb/benchmarks_2thread__pool__benchmarks_2comparison__benchmark_8cpp.html#a75b6b3ce3590f7f29e3a71cc698bb69a">create_default</a>(std::thread::hardware_concurrency() * 2);</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md3165"></a>
Batch Job Submission</h2>
<p>Always prefer batch submission over individual job enqueueing:</p>
<div class="fragment"><div class="line"><span class="comment">// ❌ Inefficient</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a> : tasks) {</div>
<div class="line">    pool-&gt;enqueue(create_job(<a class="code hl_struct" href="../../db/da2/structtask.html">task</a>));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ Efficient</span></div>
<div class="line">std::vector&lt;std::unique_ptr&lt;thread_module::job&gt;&gt; jobs;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a> : tasks) {</div>
<div class="line">    jobs.push_back(create_job(<a class="code hl_struct" href="../../db/da2/structtask.html">task</a>));</div>
<div class="line">}</div>
<div class="line">pool-&gt;enqueue_batch(std::move(jobs));</div>
<div class="ttc" id="astructtask_html"><div class="ttname"><a href="../../db/da2/structtask.html">task</a></div><div class="ttdef"><b>Definition</b> <a href="../../d4/daa/distributed__worker_8cpp_source.html#l00033">distributed_worker.cpp:33</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3166"></a>
Wake Interval Optimization</h2>
<p>Configure wake intervals based on your workload:</p>
<div class="fragment"><div class="line"><span class="comment">// For high-frequency tasks</span></div>
<div class="line">worker.set_wake_interval(std::chrono::milliseconds(10));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For periodic maintenance</span></div>
<div class="line">worker.set_wake_interval(std::chrono::seconds(1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For rare events</span></div>
<div class="line">worker.set_wake_interval(std::chrono::minutes(1));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3167"></a>
Integrating External Modules</h1>
<h2><a class="anchor" id="autotoc_md3168"></a>
Logger Integration Pattern</h2>
<p>Thread System is designed to work with external logging libraries. Here's how to integrate them:</p>
<div class="fragment"><div class="line"><span class="comment">// Example: Integrating an external logger</span></div>
<div class="line"><span class="keyword">class </span>LoggerAdapter : <span class="keyword">public</span> thread_module::error_handler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    LoggerAdapter(std::shared_ptr&lt;external::Logger&gt; logger) </div>
<div class="line">        : logger_(logger) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> handle_error(<span class="keyword">const</span> std::string&amp; error_message)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (logger_) {</div>
<div class="line">            logger_-&gt;error(<span class="stringliteral">&quot;Thread System: {}&quot;</span>, error_message);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;external::Logger&gt; logger_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> external_logger = external::Logger::create(<span class="stringliteral">&quot;app.log&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> logger_adapter = std::make_shared&lt;LoggerAdapter&gt;(external_logger);</div>
<div class="line">thread_pool-&gt;set_error_handler(logger_adapter);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3169"></a>
Monitoring Integration Pattern</h2>
<p>For performance monitoring and metrics collection:</p>
<div class="fragment"><div class="line"><span class="comment">// Example: Integrating external monitoring</span></div>
<div class="line"><span class="keyword">class </span>MonitoringAdapter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MonitoringAdapter(std::shared_ptr&lt;external::MetricsCollector&gt; collector)</div>
<div class="line">        : collector_(collector) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> record_job_execution(<span class="keyword">const</span> std::string&amp; job_type, </div>
<div class="line">                             std::chrono::nanoseconds duration) {</div>
<div class="line">        <span class="keywordflow">if</span> (collector_) {</div>
<div class="line">            collector_-&gt;record_histogram(<span class="stringliteral">&quot;thread_system.job_duration&quot;</span>, </div>
<div class="line">                                       duration.count(),</div>
<div class="line">                                       {{<span class="stringliteral">&quot;job_type&quot;</span>, job_type}});</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> record_pool_size(<span class="keywordtype">size_t</span> active_workers, <span class="keywordtype">size_t</span> total_workers) {</div>
<div class="line">        <span class="keywordflow">if</span> (collector_) {</div>
<div class="line">            collector_-&gt;record_gauge(<span class="stringliteral">&quot;thread_system.active_workers&quot;</span>, </div>
<div class="line">                                   active_workers);</div>
<div class="line">            collector_-&gt;record_gauge(<span class="stringliteral">&quot;thread_system.total_workers&quot;</span>, </div>
<div class="line">                                   total_workers);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;external::MetricsCollector&gt; collector_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3170"></a>
Best Practices for Modular Architecture</h2>
<ol type="1">
<li><b>Use Dependency Injection</b>: <div class="fragment"><div class="line"><span class="keyword">class </span>Application {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Application(std::shared_ptr&lt;thread_module::error_handler&gt; error_handler = <span class="keyword">nullptr</span>)</div>
<div class="line">        : error_handler_(error_handler) {</div>
<div class="line">        <span class="comment">// Create thread pool</span></div>
<div class="line">        <span class="keyword">auto</span> [pool, error] = <a class="code hl_function" href="../../da/dfb/benchmarks_2thread__pool__benchmarks_2comparison__benchmark_8cpp.html#a75b6b3ce3590f7f29e3a71cc698bb69a">create_default</a>(4);</div>
<div class="line">        <span class="keywordflow">if</span> (!error.has_value() &amp;&amp; error_handler_) {</div>
<div class="line">            pool-&gt;set_error_handler(error_handler_);</div>
<div class="line">        }</div>
<div class="line">        thread_pool_ = std::move(pool);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;thread_module::error_handler&gt; error_handler_;</div>
<div class="line">    std::unique_ptr&lt;thread_pool_module::thread_pool&gt; thread_pool_;</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li><b>Create Abstract Interfaces</b>: <div class="fragment"><div class="line"><span class="comment">// Define your own interfaces for optional dependencies</span></div>
<div class="line"><span class="keyword">class </span>ILogger {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~ILogger() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> log(<span class="keyword">const</span> std::string&amp; message) = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>IMonitor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> ~IMonitor() = <span class="keywordflow">default</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> record_metric(<span class="keyword">const</span> std::string&amp; name, <span class="keywordtype">double</span> value) = 0;</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li><b>Use Null Object Pattern for Optional Dependencies</b>: <div class="fragment"><div class="line"><span class="keyword">class </span>NullLogger : <span class="keyword">public</span> ILogger {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> log(<span class="keyword">const</span> std::string&amp;)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// No-op implementation</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use null logger when no real logger is provided</span></div>
<div class="line"><span class="keyword">auto</span> logger = external_logger ? external_logger : std::make_shared&lt;NullLogger&gt;();</div>
</div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="autotoc_md3171"></a>
Conclusion</h1>
<p>Following these patterns and avoiding the antipatterns will help you use Thread System effectively. The core principles to remember are:</p>
<ol type="1">
<li><b>Use the right tool for the job</b>: Choose the appropriate component based on your requirements</li>
<li><b>Design for concurrency</b>: Think about thread safety from the start</li>
<li><b>Avoid overengineering</b>: Use the simplest concurrency pattern that meets your needs</li>
<li><b>Monitor and measure</b>: Always validate the performance benefits of your threading design</li>
<li><b>Handle errors</b>: Always check return values and handle errors properly</li>
<li><b>Debug methodically</b>: Use diagnostics, debuggers, and thread sanitizers to identify issues</li>
<li><b>Keep it modular</b>: Design your system to work with or without external logging/monitoring</li>
</ol>
<p>By following these guidelines, you can create robust, efficient, and maintainable concurrent applications with Thread System. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
