<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: Design Patterns and Architectural Decisions</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d5/dca/md_docs_2DESIGN__PATTERNS.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Design Patterns and Architectural Decisions</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1771"></a> </p>
<h1><a class="anchor" id="autotoc_md1772"></a>
Overview</h1>
<p>This document catalogs the design patterns implemented throughout the Messaging System, explaining why each pattern was chosen and providing implementation examples. These patterns ensure scalability, maintainability, and performance in a distributed messaging environment.</p>
<h1><a class="anchor" id="autotoc_md1773"></a>
Creational Patterns</h1>
<h2><a class="anchor" id="autotoc_md1774"></a>
1. Singleton Pattern</h2>
<p><b>Purpose</b>: Ensure single instances of critical system components like loggers and configuration managers.</p>
<p><b>Why Chosen</b>: Prevents resource conflicts and ensures consistent state across the application.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ConfigurationManager {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> std::unique_ptr&lt;ConfigurationManager&gt; instance_;</div>
<div class="line">    <span class="keyword">static</span> std::mutex mutex_;</div>
<div class="line"> </div>
<div class="line">    ConfigurationManager() {</div>
<div class="line">        load_configuration();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> ConfigurationManager&amp; instance() {</div>
<div class="line">        std::call_once(init_flag_, []() {</div>
<div class="line">            instance_ = std::unique_ptr&lt;ConfigurationManager&gt;(</div>
<div class="line">                <span class="keyword">new</span> ConfigurationManager()</div>
<div class="line">            );</div>
<div class="line">        });</div>
<div class="line">        <span class="keywordflow">return</span> *instance_;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Delete copy/move operations</span></div>
<div class="line">    ConfigurationManager(<span class="keyword">const</span> ConfigurationManager&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">    ConfigurationManager&amp; operator=(<span class="keyword">const</span> ConfigurationManager&amp;) = <span class="keyword">delete</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> std::once_flag init_flag_;</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Logger manager</li>
<li>Database connection manager</li>
<li>System configuration</li>
<li>Metrics collector</li>
</ul>
<h2><a class="anchor" id="autotoc_md1775"></a>
2. Factory Pattern</h2>
<p><b>Purpose</b>: Create objects without specifying exact classes, enabling runtime polymorphism.</p>
<p><b>Why Chosen</b>: Allows flexible service creation based on configuration and supports plugin architecture.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ServiceFactory {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>ServiceCreator = std::function&lt;std::unique_ptr&lt;IService&gt;()&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> register_service(<span class="keyword">const</span> std::string&amp; type, ServiceCreator creator) {</div>
<div class="line">        creators_[type] = creator;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;IService&gt; create_service(<span class="keyword">const</span> std::string&amp; type) {</div>
<div class="line">        <span class="keyword">auto</span> it = creators_.find(type);</div>
<div class="line">        <span class="keywordflow">if</span> (it != creators_.end()) {</div>
<div class="line">            <span class="keywordflow">return</span> it-&gt;second();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unknown service type: &quot;</span> + type);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unordered_map&lt;std::string, ServiceCreator&gt; creators_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Registration</span></div>
<div class="line">factory.register_service(<span class="stringliteral">&quot;network&quot;</span>, []() {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;NetworkService&gt;();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">factory.register_service(<span class="stringliteral">&quot;database&quot;</span>, []() {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;DatabaseService&gt;();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> service = factory.create_service(config.service_type);</div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Message handler creation</li>
<li>Protocol adapter instantiation</li>
<li>Storage backend selection</li>
<li>Serializer selection</li>
</ul>
<h2><a class="anchor" id="autotoc_md1776"></a>
3. Builder Pattern</h2>
<p><b>Purpose</b>: Construct complex objects step by step with fluent interface.</p>
<p><b>Why Chosen</b>: Simplifies creation of messages and configurations with many optional parameters.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MessageBuilder {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;Message&gt; message_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MessageBuilder() : message_(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::make_unique&lt;Message&gt;()) {}</div>
<div class="line"> </div>
<div class="line">    MessageBuilder&amp; with_topic(<span class="keyword">const</span> std::string&amp; topic) {</div>
<div class="line">        message_-&gt;set_topic(topic);</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MessageBuilder&amp; with_payload(<span class="keyword">const</span> Payload&amp; payload) {</div>
<div class="line">        message_-&gt;set_payload(payload);</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MessageBuilder&amp; with_priority(Priority priority) {</div>
<div class="line">        message_-&gt;set_priority(priority);</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    MessageBuilder&amp; with_timeout(std::chrono::milliseconds timeout) {</div>
<div class="line">        message_-&gt;set_timeout(timeout);</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::unique_ptr&lt;Message&gt; build() {</div>
<div class="line">        <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320af9ab05454998236921a6b0e281fae632">validate</a>();</div>
<div class="line">        <span class="keywordflow">return</span> std::move(message_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320af9ab05454998236921a6b0e281fae632">validate</a>() {</div>
<div class="line">        <span class="keywordflow">if</span> (message_-&gt;topic().empty()) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Message must have a topic&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> message = MessageBuilder()</div>
<div class="line">    .with_topic(<span class="stringliteral">&quot;user.created&quot;</span>)</div>
<div class="line">    .with_payload({<span class="stringliteral">&quot;user_id&quot;</span>, 12345})</div>
<div class="line">    .with_priority(Priority::HIGH)</div>
<div class="line">    .with_timeout(5s)</div>
<div class="line">    .build();</div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1services_1_1container_html_a221266e349efd48a805f4d942db56320af9ab05454998236921a6b0e281fae632"><div class="ttname"><a href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320af9ab05454998236921a6b0e281fae632">kcenon::messaging::services::container::container_operation::validate</a></div><div class="ttdeci">@ validate</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="../../d8/dcc/namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Complex message construction</li>
<li>Database query builders</li>
<li>Configuration builders</li>
<li>Network request builders</li>
</ul>
<h2><a class="anchor" id="autotoc_md1777"></a>
4. Object Pool Pattern</h2>
<p><b>Purpose</b>: Reuse expensive objects to reduce allocation overhead.</p>
<p><b>Why Chosen</b>: Minimizes memory allocation in hot paths, crucial for high-performance messaging.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>ObjectPool {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::queue&lt;std::unique_ptr&lt;T&gt;&gt; pool_;</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    std::function&lt;std::unique_ptr&lt;T&gt;()&gt; creator_;</div>
<div class="line">    <span class="keywordtype">size_t</span> max_size_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">class </span>PooledObject {</div>
<div class="line">        ObjectPool* pool_;</div>
<div class="line">        std::unique_ptr&lt;T&gt; object_;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        PooledObject(ObjectPool* pool, std::unique_ptr&lt;T&gt; obj)</div>
<div class="line">            : pool_(pool), object_(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::move(obj)) {}</div>
<div class="line"> </div>
<div class="line">        ~PooledObject() {</div>
<div class="line">            <span class="keywordflow">if</span> (object_ &amp;&amp; pool_) {</div>
<div class="line">                pool_-&gt;return_object(std::move(object_));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        T* operator-&gt;() { <span class="keywordflow">return</span> object_.get(); }</div>
<div class="line">        T&amp; operator*() { <span class="keywordflow">return</span> *object_; }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    ObjectPool(<span class="keywordtype">size_t</span> max_size, std::function&lt;std::unique_ptr&lt;T&gt;()&gt; creator)</div>
<div class="line">        : max_size_(max_size), creator_(creator) {</div>
<div class="line">        <span class="comment">// Pre-allocate objects</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; max_size / 2; ++i) {</div>
<div class="line">            pool_.push(creator_());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    PooledObject <a class="code hl_enumvalue" href="../../de/d41/namespacethread__module_1_1lockfree.html#a07cdd7466a09a6c46b1f7a1121ab9037a86a4fa105ff51b8c3be84734797d8144">acquire</a>() {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (pool_.empty()) {</div>
<div class="line">            <span class="keywordflow">return</span> PooledObject(<span class="keyword">this</span>, creator_());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> obj = std::move(pool_.front());</div>
<div class="line">        pool_.pop();</div>
<div class="line">        <span class="keywordflow">return</span> PooledObject(<span class="keyword">this</span>, std::move(obj));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> return_object(std::unique_ptr&lt;T&gt; obj) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (pool_.size() &lt; max_size_) {</div>
<div class="line">            obj-&gt;reset();  <span class="comment">// Reset object state</span></div>
<div class="line">            pool_.push(std::move(obj));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">ObjectPool&lt;Buffer&gt; buffer_pool(100, []() {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;Buffer&gt;(4096);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> buffer = buffer_pool.acquire();</div>
<div class="line">buffer-&gt;write(data);</div>
<div class="line"><span class="comment">// Buffer automatically returned to pool when destroyed</span></div>
<div class="ttc" id="anamespacethread__module_1_1lockfree_html_a07cdd7466a09a6c46b1f7a1121ab9037a86a4fa105ff51b8c3be84734797d8144"><div class="ttname"><a href="../../de/d41/namespacethread__module_1_1lockfree.html#a07cdd7466a09a6c46b1f7a1121ab9037a86a4fa105ff51b8c3be84734797d8144">thread_module::lockfree::memory_ordering_policy::acquire</a></div><div class="ttdeci">@ acquire</div><div class="ttdoc">Use acquire-release semantics for correctness.</div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Message object pooling</li>
<li>Buffer management</li>
<li>Database connection pooling</li>
<li>Thread-local storage pools</li>
</ul>
<h1><a class="anchor" id="autotoc_md1778"></a>
Structural Patterns</h1>
<h2><a class="anchor" id="autotoc_md1779"></a>
5. Adapter Pattern</h2>
<p><b>Purpose</b>: Allow incompatible interfaces to work together.</p>
<p><b>Why Chosen</b>: Enables integration with various external systems and protocols.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="comment">// Target interface expected by our system</span></div>
<div class="line"><span class="keyword">class </span>IMessageQueue {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> send(<span class="keyword">const</span> Message&amp; msg) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> Message receive() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~IMessageQueue() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// External RabbitMQ library with different interface</span></div>
<div class="line"><span class="keyword">class </span>RabbitMQClient {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> publish(<span class="keyword">const</span> std::string&amp; exchange, <span class="keyword">const</span> std::string&amp; data);</div>
<div class="line">    std::string consume(<span class="keyword">const</span> std::string&amp; queue);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Adapter</span></div>
<div class="line"><span class="keyword">class </span>RabbitMQAdapter : <span class="keyword">public</span> IMessageQueue {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;RabbitMQClient&gt; client_;</div>
<div class="line">    std::string exchange_;</div>
<div class="line">    std::string queue_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    RabbitMQAdapter(<span class="keyword">const</span> std::string&amp; exchange, <span class="keyword">const</span> std::string&amp; queue)</div>
<div class="line">        : client_(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::make_unique&lt;RabbitMQClient&gt;())</div>
<div class="line">        , exchange_(exchange)</div>
<div class="line">        , queue_(queue) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> send(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        client_-&gt;publish(exchange_, msg.serialize());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Message receive()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keyword">auto</span> data = client_-&gt;consume(queue_);</div>
<div class="line">        <span class="keywordflow">return</span> Message::deserialize(data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">std::unique_ptr&lt;IMessageQueue&gt; queue =</div>
<div class="line">    std::make_unique&lt;RabbitMQAdapter&gt;(<span class="stringliteral">&quot;events&quot;</span>, <span class="stringliteral">&quot;worker_queue&quot;</span>);</div>
<div class="line">queue-&gt;send(message);</div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>External message queue adapters (RabbitMQ, Kafka)</li>
<li>Database adapters (PostgreSQL, MySQL)</li>
<li>Protocol adapters (HTTP, WebSocket)</li>
<li>Logging adapters (syslog, file, console)</li>
</ul>
<h2><a class="anchor" id="autotoc_md1780"></a>
6. Decorator Pattern</h2>
<p><b>Purpose</b>: Add responsibilities to objects dynamically without altering structure.</p>
<p><b>Why Chosen</b>: Allows flexible message processing pipelines with composable middleware.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>IMessageProcessor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> process(Message&amp; msg) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~IMessageProcessor() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>BaseProcessor : <span class="keyword">public</span> IMessageProcessor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Basic processing</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Decorator base</span></div>
<div class="line"><span class="keyword">class </span>ProcessorDecorator : <span class="keyword">public</span> IMessageProcessor {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    std::unique_ptr&lt;IMessageProcessor&gt; processor_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ProcessorDecorator(std::unique_ptr&lt;IMessageProcessor&gt; processor)</div>
<div class="line">        : processor_(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::move(processor)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        processor_-&gt;process(msg);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Concrete decorators</span></div>
<div class="line"><span class="keyword">class </span>LoggingDecorator : <span class="keyword">public</span> ProcessorDecorator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>ProcessorDecorator::ProcessorDecorator;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        logger_.info(<span class="stringliteral">&quot;Processing message: {}&quot;</span>, msg.id());</div>
<div class="line">        processor_-&gt;process(msg);</div>
<div class="line">        logger_.info(<span class="stringliteral">&quot;Processed message: {}&quot;</span>, msg.id());</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CompressionDecorator : <span class="keyword">public</span> ProcessorDecorator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>ProcessorDecorator::ProcessorDecorator;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a13efe76945dcdb1111672f358c230ab4">decompress</a>(msg);</div>
<div class="line">        processor_-&gt;process(msg);</div>
<div class="line">        <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a390626c545194d0f20a704589b190994">compress</a>(msg);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EncryptionDecorator : <span class="keyword">public</span> ProcessorDecorator {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>ProcessorDecorator::ProcessorDecorator;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        decrypt(msg);</div>
<div class="line">        processor_-&gt;process(msg);</div>
<div class="line">        encrypt(msg);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Build processing pipeline</span></div>
<div class="line"><span class="keyword">auto</span> processor = std::make_unique&lt;BaseProcessor&gt;();</div>
<div class="line">processor = std::make_unique&lt;LoggingDecorator&gt;(std::move(processor));</div>
<div class="line">processor = std::make_unique&lt;CompressionDecorator&gt;(std::move(processor));</div>
<div class="line">processor = std::make_unique&lt;EncryptionDecorator&gt;(std::move(processor));</div>
<div class="line"> </div>
<div class="line">processor-&gt;process(message);</div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1services_1_1container_html_a221266e349efd48a805f4d942db56320a13efe76945dcdb1111672f358c230ab4"><div class="ttname"><a href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a13efe76945dcdb1111672f358c230ab4">kcenon::messaging::services::container::container_operation::decompress</a></div><div class="ttdeci">@ decompress</div></div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1services_1_1container_html_a221266e349efd48a805f4d942db56320a390626c545194d0f20a704589b190994"><div class="ttname"><a href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a390626c545194d0f20a704589b190994">kcenon::messaging::services::container::container_operation::compress</a></div><div class="ttdeci">@ compress</div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Message processing pipelines</li>
<li>Request/response interceptors</li>
<li>Metrics collection</li>
<li>Security layers</li>
</ul>
<h2><a class="anchor" id="autotoc_md1781"></a>
7. Proxy Pattern</h2>
<p><b>Purpose</b>: Provide placeholder or surrogate for another object to control access.</p>
<p><b>Why Chosen</b>: Implements lazy loading, caching, and access control for remote services.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>IRemoteService {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> Response execute(<span class="keyword">const</span> Request&amp; req) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~IRemoteService() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RemoteService : <span class="keyword">public</span> IRemoteService {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Response execute(<span class="keyword">const</span> Request&amp; req)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Actual remote call</span></div>
<div class="line">        <span class="keywordflow">return</span> make_remote_call(req);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CachingProxy : <span class="keyword">public</span> IRemoteService {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::unique_ptr&lt;IRemoteService&gt; service_;</div>
<div class="line">    std::unordered_map&lt;Request, Response, RequestHash&gt; cache_;</div>
<div class="line">    std::mutex cache_mutex_;</div>
<div class="line">    std::chrono::seconds ttl_{60};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>CacheEntry {</div>
<div class="line">        Response <a class="code hl_enumvalue" href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#accdec513cff0fa75c42e41e381b490a4ad1fc8eaf36937be0c3ba8cfe0a2c1bfe">response</a>;</div>
<div class="line">        std::chrono::steady_clock::time_point timestamp;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CachingProxy(std::unique_ptr&lt;IRemoteService&gt; service)</div>
<div class="line">        : service_(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::move(service)) {}</div>
<div class="line"> </div>
<div class="line">    Response execute(<span class="keyword">const</span> Request&amp; req)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Check cache</span></div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(cache_mutex_);</div>
<div class="line">            <span class="keyword">auto</span> it = cache_.find(req);</div>
<div class="line">            <span class="keywordflow">if</span> (it != cache_.end()) {</div>
<div class="line">                <span class="keyword">auto</span> age = std::chrono::steady_clock::now() - it-&gt;second.timestamp;</div>
<div class="line">                <span class="keywordflow">if</span> (age &lt; ttl_) {</div>
<div class="line">                    <span class="keywordflow">return</span> it-&gt;second.response;  <span class="comment">// Cache hit</span></div>
<div class="line">                }</div>
<div class="line">                cache_.erase(it);  <span class="comment">// Expired</span></div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Cache miss - execute request</span></div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#accdec513cff0fa75c42e41e381b490a4ad1fc8eaf36937be0c3ba8cfe0a2c1bfe">response</a> = service_-&gt;execute(req);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Update cache</span></div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(cache_mutex_);</div>
<div class="line">            cache_[req] = {<a class="code hl_enumvalue" href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#accdec513cff0fa75c42e41e381b490a4ad1fc8eaf36937be0c3ba8cfe0a2c1bfe">response</a>, std::chrono::steady_clock::now()};</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_enumvalue" href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#accdec513cff0fa75c42e41e381b490a4ad1fc8eaf36937be0c3ba8cfe0a2c1bfe">response</a>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> service = std::make_unique&lt;RemoteService&gt;();</div>
<div class="line"><span class="keyword">auto</span> proxy = std::make_unique&lt;CachingProxy&gt;(std::move(service));</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#accdec513cff0fa75c42e41e381b490a4ad1fc8eaf36937be0c3ba8cfe0a2c1bfe">response</a> = proxy-&gt;execute(request);  <span class="comment">// Cached for subsequent calls</span></div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1core_html_accdec513cff0fa75c42e41e381b490a4ad1fc8eaf36937be0c3ba8cfe0a2c1bfe"><div class="ttname"><a href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#accdec513cff0fa75c42e41e381b490a4ad1fc8eaf36937be0c3ba8cfe0a2c1bfe">kcenon::messaging::core::message_type::response</a></div><div class="ttdeci">@ response</div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Remote service proxies</li>
<li>Database query caching</li>
<li>Authentication proxies</li>
<li>Rate limiting proxies</li>
</ul>
<h2><a class="anchor" id="autotoc_md1782"></a>
8. Composite Pattern</h2>
<p><b>Purpose</b>: Compose objects into tree structures to represent part-whole hierarchies.</p>
<p><b>Why Chosen</b>: Enables hierarchical message routing and complex filter compositions.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>IMessageFilter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> matches(<span class="keyword">const</span> Message&amp; msg) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~IMessageFilter() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Leaf filters</span></div>
<div class="line"><span class="keyword">class </span>TopicFilter : <span class="keyword">public</span> IMessageFilter {</div>
<div class="line">    std::string pattern_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    TopicFilter(<span class="keyword">const</span> std::string&amp; pattern) : pattern_(pattern) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> matches(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::regex_match(msg.topic(), std::regex(pattern_));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PriorityFilter : <span class="keyword">public</span> IMessageFilter {</div>
<div class="line">    Priority min_priority_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PriorityFilter(Priority min) : min_priority_(min) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> matches(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> msg.priority() &gt;= min_priority_;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Composite filters</span></div>
<div class="line"><span class="keyword">class </span>CompositeFilter : <span class="keyword">public</span> IMessageFilter {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;IMessageFilter&gt;&gt; filters_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="../../d2/d11/test__std__concepts_8cpp.html#acb807bc597e1fc5883bc91a306d44f03">add</a>(std::unique_ptr&lt;IMessageFilter&gt; filter) {</div>
<div class="line">        filters_.push_back(std::move(filter));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AndFilter : <span class="keyword">public</span> CompositeFilter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> matches(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::all_of(filters_.begin(), filters_.end(),</div>
<div class="line">            [&amp;msg](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; filter) {</div>
<div class="line">                return filter-&gt;matches(msg);</div>
<div class="line">            });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>OrFilter : <span class="keyword">public</span> CompositeFilter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> matches(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::any_of(filters_.begin(), filters_.end(),</div>
<div class="line">            [&amp;msg](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; filter) {</div>
<div class="line">                return filter-&gt;matches(msg);</div>
<div class="line">            });</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Build complex filter</span></div>
<div class="line"><span class="keyword">auto</span> filter = std::make_unique&lt;AndFilter&gt;();</div>
<div class="line">filter-&gt;add(std::make_unique&lt;TopicFilter&gt;(<span class="stringliteral">&quot;user\\..*&quot;</span>));</div>
<div class="line">filter-&gt;add(std::make_unique&lt;PriorityFilter&gt;(Priority::HIGH));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> or_filter = std::make_unique&lt;OrFilter&gt;();</div>
<div class="line">or_filter-&gt;add(std::make_unique&lt;TopicFilter&gt;(<span class="stringliteral">&quot;system\\..*&quot;</span>));</div>
<div class="line">or_filter-&gt;add(std::move(filter));</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (or_filter-&gt;matches(message)) {</div>
<div class="line">    <span class="comment">// Process message</span></div>
<div class="line">}</div>
<div class="ttc" id="atest__std__concepts_8cpp_html_acb807bc597e1fc5883bc91a306d44f03"><div class="ttname"><a href="../../d2/d11/test__std__concepts_8cpp.html#acb807bc597e1fc5883bc91a306d44f03">add</a></div><div class="ttdeci">T add(T a, T b)</div><div class="ttdef"><b>Definition</b> <a href="../../d2/d11/test__std__concepts_8cpp_source.html#l00043">test_std_concepts.cpp:43</a></div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Message routing rules</li>
<li>Complex query filters</li>
<li>Permission hierarchies</li>
<li>Configuration trees</li>
</ul>
<h1><a class="anchor" id="autotoc_md1783"></a>
Behavioral Patterns</h1>
<h2><a class="anchor" id="autotoc_md1784"></a>
9. Observer Pattern</h2>
<p><b>Purpose</b>: Define one-to-many dependency between objects for event notification.</p>
<p><b>Why Chosen</b>: Core to pub/sub messaging system, enables loose coupling between components.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EventType&gt;</div>
<div class="line"><span class="keyword">class </span>EventBus {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using </span>Handler = std::function&lt;void(<span class="keyword">const</span> EventType&amp;)&gt;;</div>
<div class="line">    <span class="keyword">using </span>HandlerId = size_t;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>Subscription {</div>
<div class="line">        HandlerId id;</div>
<div class="line">        Handler handler;</div>
<div class="line">        std::weak_ptr&lt;void&gt; lifetime;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;Subscription&gt; subscribers_;</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    std::atomic&lt;HandlerId&gt; next_id_{0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HandlerId subscribe(Handler handler,</div>
<div class="line">                       std::shared_ptr&lt;void&gt; lifetime = <span class="keyword">nullptr</span>) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        HandlerId <span class="keywordtype">id</span> = next_id_++;</div>
<div class="line">        subscribers_.push_back({id, handler, lifetime});</div>
<div class="line">        <span class="keywordflow">return</span> id;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> unsubscribe(HandlerId <span class="keywordtype">id</span>) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        subscribers_.erase(</div>
<div class="line">            std::remove_if(subscribers_.begin(), subscribers_.end(),</div>
<div class="line">                [<span class="keywordtype">id</span>](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sub) { return sub.id == id; }),</div>
<div class="line">            subscribers_.end()</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> publish(<span class="keyword">const</span> EventType&amp; event) {</div>
<div class="line">        std::vector&lt;Handler&gt; handlers;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Copy handlers to avoid holding lock during callbacks</span></div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Clean up expired subscriptions</span></div>
<div class="line">            subscribers_.erase(</div>
<div class="line">                std::remove_if(subscribers_.begin(), subscribers_.end(),</div>
<div class="line">                    [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sub) { return sub.lifetime.expired(); }),</div>
<div class="line">                subscribers_.end()</div>
<div class="line">            );</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Collect active handlers</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sub : subscribers_) {</div>
<div class="line">                handlers.push_back(sub.handler);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Execute handlers</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; handler : handlers) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                handler(event);</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                <span class="comment">// Log error but continue notifying others</span></div>
<div class="line">                logger_.error(<span class="stringliteral">&quot;Handler error: {}&quot;</span>, e.what());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">EventBus&lt;UserCreatedEvent&gt; user_events;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subscribe</span></div>
<div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = user_events.subscribe([](<span class="keyword">const</span> UserCreatedEvent&amp; event) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;New user: &quot;</span> &lt;&lt; <span class="keyword">event</span>.username &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Publish</span></div>
<div class="line">user_events.publish(UserCreatedEvent{<span class="stringliteral">&quot;john_doe&quot;</span>, <span class="stringliteral">&quot;john@example.com&quot;</span>});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Unsubscribe</span></div>
<div class="line">user_events.unsubscribe(<span class="keywordtype">id</span>);</div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Message bus pub/sub</li>
<li>Connection state changes</li>
<li>Configuration updates</li>
<li>System event notifications</li>
</ul>
<h2><a class="anchor" id="autotoc_md1785"></a>
10. Strategy Pattern</h2>
<p><b>Purpose</b>: Define family of algorithms and make them interchangeable.</p>
<p><b>Why Chosen</b>: Allows runtime selection of serialization formats, compression algorithms, and routing strategies.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ISerializationStrategy {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> std::string serialize(<span class="keyword">const</span> Message&amp; msg) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> Message deserialize(<span class="keyword">const</span> std::string&amp; data) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~ISerializationStrategy() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>BinarySerializer : <span class="keyword">public</span> ISerializationStrategy {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string serialize(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Binary serialization logic</span></div>
<div class="line">        <span class="keywordflow">return</span> binary_encode(msg);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Message <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a95f98046b7ecfb92a1d8a6006babb282">deserialize</a>(<span class="keyword">const</span> std::string&amp; data)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> binary_decode(data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>JsonSerializer : <span class="keyword">public</span> ISerializationStrategy {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a235cdd01b87af1e1de37f4746a88d82c">serialize</a>(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        nlohmann::json j;</div>
<div class="line">        j[<span class="stringliteral">&quot;id&quot;</span>] = msg.id();</div>
<div class="line">        j[<span class="stringliteral">&quot;topic&quot;</span>] = msg.topic();</div>
<div class="line">        j[<span class="stringliteral">&quot;payload&quot;</span>] = msg.payload();</div>
<div class="line">        <span class="keywordflow">return</span> j.dump();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Message <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a95f98046b7ecfb92a1d8a6006babb282">deserialize</a>(<span class="keyword">const</span> std::string&amp; data)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keyword">auto</span> j = nlohmann::json::parse(data);</div>
<div class="line">        Message msg;</div>
<div class="line">        msg.set_id(j[<span class="stringliteral">&quot;id&quot;</span>]);</div>
<div class="line">        msg.set_topic(j[<span class="stringliteral">&quot;topic&quot;</span>]);</div>
<div class="line">        msg.set_payload(j[<span class="stringliteral">&quot;payload&quot;</span>]);</div>
<div class="line">        <span class="keywordflow">return</span> msg;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ProtobufSerializer : <span class="keyword">public</span> ISerializationStrategy {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a235cdd01b87af1e1de37f4746a88d82c">serialize</a>(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Protobuf serialization</span></div>
<div class="line">        <span class="keywordflow">return</span> protobuf_encode(msg);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Message <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a95f98046b7ecfb92a1d8a6006babb282">deserialize</a>(<span class="keyword">const</span> std::string&amp; data)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> protobuf_decode(data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Context class</span></div>
<div class="line"><span class="keyword">class </span>MessageSerializer {</div>
<div class="line">    std::unique_ptr&lt;ISerializationStrategy&gt; strategy_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> set_strategy(std::unique_ptr&lt;ISerializationStrategy&gt; strategy) {</div>
<div class="line">        strategy_ = std::move(strategy);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::string <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a235cdd01b87af1e1de37f4746a88d82c">serialize</a>(<span class="keyword">const</span> Message&amp; msg) {</div>
<div class="line">        <span class="keywordflow">if</span> (!strategy_) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;No serialization strategy set&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> strategy_-&gt;serialize(msg);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Message <a class="code hl_enumvalue" href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a95f98046b7ecfb92a1d8a6006babb282">deserialize</a>(<span class="keyword">const</span> std::string&amp; data) {</div>
<div class="line">        <span class="keywordflow">if</span> (!strategy_) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;No serialization strategy set&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> strategy_-&gt;deserialize(data);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">MessageSerializer serializer;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Select strategy based on configuration</span></div>
<div class="line"><span class="keywordflow">switch</span> (config.format) {</div>
<div class="line">    <span class="keywordflow">case</span> Format::BINARY:</div>
<div class="line">        serializer.set_strategy(std::make_unique&lt;BinarySerializer&gt;());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> Format::JSON:</div>
<div class="line">        serializer.set_strategy(std::make_unique&lt;JsonSerializer&gt;());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">case</span> Format::PROTOBUF:</div>
<div class="line">        serializer.set_strategy(std::make_unique&lt;ProtobufSerializer&gt;());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> data = serializer.serialize(message);</div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1services_1_1container_html_a221266e349efd48a805f4d942db56320a235cdd01b87af1e1de37f4746a88d82c"><div class="ttname"><a href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a235cdd01b87af1e1de37f4746a88d82c">kcenon::messaging::services::container::container_operation::serialize</a></div><div class="ttdeci">@ serialize</div></div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1services_1_1container_html_a221266e349efd48a805f4d942db56320a95f98046b7ecfb92a1d8a6006babb282"><div class="ttname"><a href="../../dd/df3/namespacekcenon_1_1messaging_1_1services_1_1container.html#a221266e349efd48a805f4d942db56320a95f98046b7ecfb92a1d8a6006babb282">kcenon::messaging::services::container::container_operation::deserialize</a></div><div class="ttdeci">@ deserialize</div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Serialization strategies</li>
<li>Compression algorithms</li>
<li>Load balancing strategies</li>
<li>Retry strategies</li>
</ul>
<h2><a class="anchor" id="autotoc_md1786"></a>
11. Chain of Responsibility Pattern</h2>
<p><b>Purpose</b>: Pass requests along a chain of handlers until one handles it.</p>
<p><b>Why Chosen</b>: Perfect for message processing pipelines with middleware.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MessageHandler {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    std::unique_ptr&lt;MessageHandler&gt; next_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> set_next(std::unique_ptr&lt;MessageHandler&gt; next) {</div>
<div class="line">        <span class="keywordflow">if</span> (next_) {</div>
<div class="line">            next_-&gt;set_next(std::move(next));</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            next_ = std::move(next);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(Message&amp; msg) {</div>
<div class="line">        <span class="keywordflow">if</span> (!process(msg) &amp;&amp; next_) {</div>
<div class="line">            next_-&gt;handle(msg);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> process(Message&amp; msg) = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AuthenticationHandler : <span class="keyword">public</span> MessageHandler {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (!msg.has_auth_token()) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Authentication required&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!validate_token(msg.auth_token())) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Invalid authentication token&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// Continue to next handler</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RateLimitHandler : <span class="keyword">public</span> MessageHandler {</div>
<div class="line">    RateLimiter limiter_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (!limiter_.allow_request(msg.sender_id())) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Rate limit exceeded&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// Continue to next handler</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ValidationHandler : <span class="keyword">public</span> MessageHandler {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (msg.size() &gt; MAX_MESSAGE_SIZE) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Message too large&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!is_valid_topic(msg.topic())) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Invalid topic&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// Continue to next handler</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RouterHandler : <span class="keyword">public</span> MessageHandler {</div>
<div class="line">    MessageRouter router_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> process(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        router_.route(msg);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// Message handled, stop chain</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Build processing chain</span></div>
<div class="line"><span class="keyword">auto</span> chain = std::make_unique&lt;AuthenticationHandler&gt;();</div>
<div class="line">chain-&gt;set_next(std::make_unique&lt;RateLimitHandler&gt;());</div>
<div class="line">chain-&gt;set_next(std::make_unique&lt;ValidationHandler&gt;());</div>
<div class="line">chain-&gt;set_next(std::make_unique&lt;RouterHandler&gt;());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Process message through chain</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    chain-&gt;handle(message);</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">    logger_.error(<span class="stringliteral">&quot;Message processing failed: {}&quot;</span>, e.what());</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Request processing pipeline</li>
<li>Error handling chain</li>
<li>Message transformation pipeline</li>
<li>Security filter chain</li>
</ul>
<h2><a class="anchor" id="autotoc_md1787"></a>
12. Command Pattern</h2>
<p><b>Purpose</b>: Encapsulate requests as objects for parameterization and queuing.</p>
<p><b>Why Chosen</b>: Enables undo operations, request queuing, and transaction support.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ICommand {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> execute() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> undo() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> ~ICommand() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DatabaseCommand : <span class="keyword">public</span> ICommand {</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    DatabaseManager&amp; db_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DatabaseCommand(DatabaseManager&amp; db) : db_(db) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>InsertCommand : <span class="keyword">public</span> DatabaseCommand {</div>
<div class="line">    std::string table_;</div>
<div class="line">    std::map&lt;std::string, std::any&gt; data_;</div>
<div class="line">    int64_t inserted_id_ = -1;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    InsertCommand(DatabaseManager&amp; db, <span class="keyword">const</span> std::string&amp; table,</div>
<div class="line">                  <span class="keyword">const</span> std::map&lt;std::string, std::any&gt;&amp; data)</div>
<div class="line">        : DatabaseCommand(db), table_(table), data_(data) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> execute()<span class="keyword"> override </span>{</div>
<div class="line">        inserted_id_ = db_.insert(table_, data_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> undo()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (inserted_id_ != -1) {</div>
<div class="line">            db_.delete_by_id(table_, inserted_id_);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>UpdateCommand : <span class="keyword">public</span> DatabaseCommand {</div>
<div class="line">    std::string table_;</div>
<div class="line">    int64_t id_;</div>
<div class="line">    std::map&lt;std::string, std::any&gt; new_data_;</div>
<div class="line">    std::map&lt;std::string, std::any&gt; old_data_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    UpdateCommand(DatabaseManager&amp; db, <span class="keyword">const</span> std::string&amp; table,</div>
<div class="line">                  int64_t <span class="keywordtype">id</span>, <span class="keyword">const</span> std::map&lt;std::string, std::any&gt;&amp; data)</div>
<div class="line">        : DatabaseCommand(db), table_(table), id_(id), new_data_(data) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> execute()<span class="keyword"> override </span>{</div>
<div class="line">        old_data_ = db_.select_by_id(table_, id_);</div>
<div class="line">        db_.update(table_, id_, new_data_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> undo()<span class="keyword"> override </span>{</div>
<div class="line">        db_.update(table_, id_, old_data_);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>TransactionManager {</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;ICommand&gt;&gt; commands_;</div>
<div class="line">    std::stack&lt;ICommand*&gt; executed_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> add_command(std::unique_ptr&lt;ICommand&gt; cmd) {</div>
<div class="line">        commands_.push_back(std::move(cmd));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> execute_all() {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; cmd : commands_) {</div>
<div class="line">                cmd-&gt;execute();</div>
<div class="line">                executed_.push(cmd.get());</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">            rollback();</div>
<div class="line">            <span class="keywordflow">throw</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> rollback() {</div>
<div class="line">        <span class="keywordflow">while</span> (!executed_.empty()) {</div>
<div class="line">            executed_.top()-&gt;undo();</div>
<div class="line">            executed_.pop();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">TransactionManager transaction;</div>
<div class="line"> </div>
<div class="line">transaction.add_command(</div>
<div class="line">    std::make_unique&lt;InsertCommand&gt;(db, <span class="stringliteral">&quot;users&quot;</span>, {</div>
<div class="line">        {<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;John Doe&quot;</span>},</div>
<div class="line">        {<span class="stringliteral">&quot;email&quot;</span>, <span class="stringliteral">&quot;john@example.com&quot;</span>}</div>
<div class="line">    })</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">transaction.add_command(</div>
<div class="line">    std::make_unique&lt;UpdateCommand&gt;(db, <span class="stringliteral">&quot;accounts&quot;</span>, account_id, {</div>
<div class="line">        {<span class="stringliteral">&quot;balance&quot;</span>, new_balance}</div>
<div class="line">    })</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    transaction.execute_all();</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">    <span class="comment">// Automatic rollback</span></div>
<div class="line">    logger_.error(<span class="stringliteral">&quot;Transaction failed: {}&quot;</span>, e.what());</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Database transactions</li>
<li>Message queue operations</li>
<li>Configuration changes</li>
<li>Batch processing</li>
</ul>
<h2><a class="anchor" id="autotoc_md1788"></a>
13. Template Method Pattern</h2>
<p><b>Purpose</b>: Define skeleton of algorithm in base class, subclasses override specific steps.</p>
<p><b>Why Chosen</b>: Standardizes service lifecycle and message processing flow.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Service {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        logger_.info(<span class="stringliteral">&quot;Starting service: {}&quot;</span>, name());</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!initialize()) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Initialization failed&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (!connect()) {</div>
<div class="line">            cleanup();</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Connection failed&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        run();</div>
<div class="line"> </div>
<div class="line">        logger_.info(<span class="stringliteral">&quot;Service started: {}&quot;</span>, name());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        logger_.info(<span class="stringliteral">&quot;Stopping service: {}&quot;</span>, name());</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_define" href="../../da/dcd/log__server_8cpp.html#aaefada63b967623c915b6b3ae59c43c8">shutdown</a>();</div>
<div class="line">        disconnect();</div>
<div class="line">        cleanup();</div>
<div class="line"> </div>
<div class="line">        logger_.info(<span class="stringliteral">&quot;Service stopped: {}&quot;</span>, name());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="comment">// Template methods to be overridden</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string name() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> initialize() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> connect() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> run() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_define" href="../../da/dcd/log__server_8cpp.html#aaefada63b967623c915b6b3ae59c43c8">shutdown</a>() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> disconnect() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> cleanup() = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>NetworkService : <span class="keyword">public</span> Service {</div>
<div class="line">    boost::asio::io_context io_context_;</div>
<div class="line">    std::unique_ptr&lt;tcp::acceptor&gt; acceptor_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    std::string name()<span class="keyword"> const override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;NetworkService&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> initialize()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Initialize networking resources</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> connect()<span class="keyword"> override </span>{</div>
<div class="line">        acceptor_ = std::make_unique&lt;tcp::acceptor&gt;(io_context_,</div>
<div class="line">            tcp::endpoint(tcp::v4(), port_));</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> run()<span class="keyword"> override </span>{</div>
<div class="line">        accept_connections();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_define" href="../../da/dcd/log__server_8cpp.html#aaefada63b967623c915b6b3ae59c43c8">shutdown</a>()<span class="keyword"> override </span>{</div>
<div class="line">        io_context_.stop();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> disconnect()<span class="keyword"> override </span>{</div>
<div class="line">        acceptor_.reset();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> cleanup()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Clean up resources</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> service = std::make_unique&lt;NetworkService&gt;();</div>
<div class="line">service-&gt;start();  <span class="comment">// Follows template method pattern</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">service-&gt;stop();</div>
<div class="ttc" id="alog__server_8cpp_html_aaefada63b967623c915b6b3ae59c43c8"><div class="ttname"><a href="../../da/dcd/log__server_8cpp.html#aaefada63b967623c915b6b3ae59c43c8">shutdown</a></div><div class="ttdeci">#define shutdown(fd, how)</div><div class="ttdef"><b>Definition</b> <a href="../../da/dcd/log__server_8cpp_source.html#l00015">log_server.cpp:15</a></div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Service lifecycle management</li>
<li>Connection establishment</li>
<li>Request processing flow</li>
<li>Resource initialization</li>
</ul>
<h1><a class="anchor" id="autotoc_md1789"></a>
Concurrency Patterns</h1>
<h2><a class="anchor" id="autotoc_md1790"></a>
14. Producer-Consumer Pattern</h2>
<p><b>Purpose</b>: Decouple production and consumption of data with buffering.</p>
<p><b>Why Chosen</b>: Essential for async message processing and work distribution.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>ProducerConsumerQueue {</div>
<div class="line">    std::queue&lt;T&gt; queue_;</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    std::condition_variable not_empty_;</div>
<div class="line">    std::condition_variable not_full_;</div>
<div class="line">    <span class="keywordtype">size_t</span> max_size_;</div>
<div class="line">    std::atomic&lt;bool&gt; shutdown_{<span class="keyword">false</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> ProducerConsumerQueue(<span class="keywordtype">size_t</span> max_size)</div>
<div class="line">        : max_size_(max_size) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> produce(T item) {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line"> </div>
<div class="line">        not_full_.wait(lock, [<span class="keyword">this</span>] {</div>
<div class="line">            <span class="keywordflow">return</span> queue_.size() &lt; max_size_ || shutdown_;</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (shutdown_) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Queue is shutting down&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        queue_.push(std::move(item));</div>
<div class="line">        not_empty_.notify_one();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::optional&lt;T&gt; consume() {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line"> </div>
<div class="line">        not_empty_.wait(lock, [<span class="keyword">this</span>] {</div>
<div class="line">            <span class="keywordflow">return</span> !queue_.empty() || shutdown_;</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (queue_.empty()) {</div>
<div class="line">            <span class="keywordflow">return</span> std::nullopt;  <span class="comment">// Shutdown case</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        T item = std::move(queue_.front());</div>
<div class="line">        queue_.pop();</div>
<div class="line">        not_full_.notify_one();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> item;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_define" href="../../da/dcd/log__server_8cpp.html#aaefada63b967623c915b6b3ae59c43c8">shutdown</a>() {</div>
<div class="line">        shutdown_ = <span class="keyword">true</span>;</div>
<div class="line">        not_empty_.notify_all();</div>
<div class="line">        not_full_.notify_all();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Producer</span></div>
<div class="line"><span class="keywordtype">void</span> producer(ProducerConsumerQueue&lt;Message&gt;&amp; queue) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">        queue.produce(create_message(i));</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Consumer</span></div>
<div class="line"><span class="keywordtype">void</span> consumer(ProducerConsumerQueue&lt;Message&gt;&amp; queue) {</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">auto</span> msg = queue.consume()) {</div>
<div class="line">        process_message(*msg);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">ProducerConsumerQueue&lt;Message&gt; queue(100);</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::thread&gt; producers;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">    producers.emplace_back(producer, std::ref(queue));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::thread&gt; consumers;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">    consumers.emplace_back(consumer, std::ref(queue));</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Message queue implementation</li>
<li>Work distribution</li>
<li>Async I/O buffering</li>
<li>Log message processing</li>
</ul>
<h2><a class="anchor" id="autotoc_md1791"></a>
15. Thread Pool Pattern</h2>
<p><b>Purpose</b>: Reuse fixed number of threads for executing tasks.</p>
<p><b>Why Chosen</b>: Reduces thread creation overhead and controls resource usage.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ThreadPool {</div>
<div class="line">    std::vector&lt;std::thread&gt; workers_;</div>
<div class="line">    std::queue&lt;std::function&lt;void()&gt;&gt; tasks_;</div>
<div class="line">    std::mutex queue_mutex_;</div>
<div class="line">    std::condition_variable condition_;</div>
<div class="line">    std::atomic&lt;bool&gt; stop_{<span class="keyword">false</span>};</div>
<div class="line">    std::atomic&lt;size_t&gt; active_tasks_{0};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> ThreadPool(<span class="keywordtype">size_t</span> threads) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; threads; ++i) {</div>
<div class="line">            workers_.emplace_back([<span class="keyword">this</span>, i] {</div>
<div class="line">                worker_thread(i);</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~ThreadPool() {</div>
<div class="line">        <a class="code hl_define" href="../../da/dcd/log__server_8cpp.html#aaefada63b967623c915b6b3ae59c43c8">shutdown</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... <a class="code hl_function" href="../../d7/d0d/mpmc__performance__test_8cpp.html#a05bf0dd7b05fdf8364c327c819f7914c">Args</a>&gt;</div>
<div class="line">    <span class="keyword">auto</span> submit(F&amp;&amp; f, <a class="code hl_function" href="../../d7/d0d/mpmc__performance__test_8cpp.html#a05bf0dd7b05fdf8364c327c819f7914c">Args</a>&amp;&amp;... args) {</div>
<div class="line">        <span class="keyword">using </span>ReturnType = <span class="keyword">decltype</span>(f(args...));</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_struct" href="../../db/da2/structtask.html">task</a> = std::make_shared&lt;std::packaged_task&lt;ReturnType()&gt;&gt;(</div>
<div class="line">            std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> future = <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>-&gt;get_future();</div>
<div class="line"> </div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (stop_) {</div>
<div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;ThreadPool is stopped&quot;</span>);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            tasks_.emplace([<a class="code hl_struct" href="../../db/da2/structtask.html">task</a>]() { (*task)(); });</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        condition_.notify_one();</div>
<div class="line">        <span class="keywordflow">return</span> future;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> wait_all() {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">        condition_.wait(lock, [<span class="keyword">this</span>] {</div>
<div class="line">            <span class="keywordflow">return</span> tasks_.empty() &amp;&amp; active_tasks_ == 0;</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> worker_thread(<span class="keywordtype">size_t</span> <span class="keywordtype">id</span>) {</div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            std::function&lt;void()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>;</div>
<div class="line"> </div>
<div class="line">            {</div>
<div class="line">                std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line"> </div>
<div class="line">                condition_.wait(lock, [<span class="keyword">this</span>] {</div>
<div class="line">                    <span class="keywordflow">return</span> stop_ || !tasks_.empty();</div>
<div class="line">                });</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (stop_ &amp;&amp; tasks_.empty()) {</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                <a class="code hl_struct" href="../../db/da2/structtask.html">task</a> = std::move(tasks_.front());</div>
<div class="line">                tasks_.pop();</div>
<div class="line">                active_tasks_++;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>();</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                logger_.error(<span class="stringliteral">&quot;Task failed in worker {}: {}&quot;</span>, <span class="keywordtype">id</span>, e.what());</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            active_tasks_--;</div>
<div class="line">            condition_.notify_all();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_define" href="../../da/dcd/log__server_8cpp.html#aaefada63b967623c915b6b3ae59c43c8">shutdown</a>() {</div>
<div class="line">        stop_ = <span class="keyword">true</span>;</div>
<div class="line">        condition_.notify_all();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) {</div>
<div class="line">            <span class="keywordflow">if</span> (worker.joinable()) {</div>
<div class="line">                worker.join();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="ampmc__performance__test_8cpp_html_a05bf0dd7b05fdf8364c327c819f7914c"><div class="ttname"><a href="../../d7/d0d/mpmc__performance__test_8cpp.html#a05bf0dd7b05fdf8364c327c819f7914c">Args</a></div><div class="ttdeci">Args({2, 2, 5000}) -&gt; Args({4, 4, 2500}) -&gt;Args({8, 8, 1250})</div></div>
<div class="ttc" id="astructtask_html"><div class="ttname"><a href="../../db/da2/structtask.html">task</a></div><div class="ttdef"><b>Definition</b> <a href="../../d4/daa/distributed__worker_8cpp_source.html#l00033">distributed_worker.cpp:33</a></div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Message processing workers</li>
<li>Database query execution</li>
<li>Network I/O handling</li>
<li>Background tasks</li>
</ul>
<h1><a class="anchor" id="autotoc_md1792"></a>
Architectural Patterns</h1>
<h2><a class="anchor" id="autotoc_md1793"></a>
16. Microkernel Pattern</h2>
<p><b>Purpose</b>: Separate minimal core functionality from extended features via plugins.</p>
<p><b>Why Chosen</b>: Allows extensible system with pluggable components.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MessageKernel {</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;IPlugin&gt;&gt; plugins_;</div>
<div class="line">    std::unordered_map&lt;std::string, IPlugin*&gt; plugin_registry_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> register_plugin(std::unique_ptr&lt;IPlugin&gt; plugin) {</div>
<div class="line">        <span class="keyword">auto</span> name = plugin-&gt;name();</div>
<div class="line">        plugin-&gt;initialize(<span class="keyword">this</span>);</div>
<div class="line">        plugin_registry_[name] = plugin.get();</div>
<div class="line">        plugins_.push_back(std::move(plugin));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    T* get_plugin(<span class="keyword">const</span> std::string&amp; name) {</div>
<div class="line">        <span class="keyword">auto</span> it = plugin_registry_.find(name);</div>
<div class="line">        <span class="keywordflow">if</span> (it != plugin_registry_.end()) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">dynamic_cast&lt;</span>T*<span class="keyword">&gt;</span>(it-&gt;second);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> process_message(Message&amp; msg) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; plugin : plugins_) {</div>
<div class="line">            <span class="keywordflow">if</span> (plugin-&gt;can_handle(msg)) {</div>
<div class="line">                plugin-&gt;handle(msg);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>IPlugin {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> std::string name() <span class="keyword">const</span> = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> initialize(MessageKernel* kernel) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> can_handle(<span class="keyword">const</span> Message&amp; msg) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> handle(Message&amp; msg) = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>LoggingPlugin : <span class="keyword">public</span> IPlugin {</div>
<div class="line">    MessageKernel* kernel_;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::string name()<span class="keyword"> const override </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;logging&quot;</span>; }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initialize(MessageKernel* kernel)<span class="keyword"> override </span>{</div>
<div class="line">        kernel_ = kernel;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> can_handle(<span class="keyword">const</span> Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// Log all messages</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> handle(Message&amp; msg)<span class="keyword"> override </span>{</div>
<div class="line">        logger_.info(<span class="stringliteral">&quot;Message: {}&quot;</span>, msg.id());</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Plugin architecture</li>
<li>Service extensions</li>
<li>Protocol handlers</li>
<li>Custom processors</li>
</ul>
<h2><a class="anchor" id="autotoc_md1794"></a>
17. Event-Driven Architecture</h2>
<p><b>Purpose</b>: System components communicate through events rather than direct calls.</p>
<p><b>Why Chosen</b>: Enables loose coupling and scalable distributed systems.</p>
<p><b>Implementation</b>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>EventDrivenSystem {</div>
<div class="line">    <span class="keyword">struct </span>EventHandler {</div>
<div class="line">        std::string event_type;</div>
<div class="line">        std::function&lt;void(<span class="keyword">const</span> Event&amp;)&gt; handler;</div>
<div class="line">        Priority priority;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::multimap&lt;std::string, EventHandler&gt; handlers_;</div>
<div class="line">    std::priority_queue&lt;Event&gt; event_queue_;</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    std::condition_variable cv_;</div>
<div class="line">    std::vector&lt;std::thread&gt; workers_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_{<span class="keyword">true</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> register_handler(<span class="keyword">const</span> std::string&amp; event_type,</div>
<div class="line">                         std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> Event&amp;)&gt; handler,</div>
<div class="line">                         Priority priority = Priority::NORMAL) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        handlers_.emplace(event_type, EventHandler{event_type, handler, <a class="code hl_enumvalue" href="../../d8/d98/namespacethread__pool__module.html#add8b8e5f5fd0f12965fb6fdda6b22355ab988295c268025b49dfb3df26171ddc3">priority</a>});</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> emit(<span class="keyword">const</span> Event&amp; event) {</div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">            event_queue_.push(event);</div>
<div class="line">        }</div>
<div class="line">        cv_.notify_one();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> start(<span class="keywordtype">size_t</span> num_workers) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; num_workers; ++i) {</div>
<div class="line">            workers_.emplace_back([<span class="keyword">this</span>] { process_events(); });</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> process_events() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            Event event;</div>
<div class="line"> </div>
<div class="line">            {</div>
<div class="line">                std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">                cv_.wait(lock, [<span class="keyword">this</span>] {</div>
<div class="line">                    <span class="keywordflow">return</span> !event_queue_.empty() || !running_;</div>
<div class="line">                });</div>
<div class="line"> </div>
<div class="line">                <span class="keywordflow">if</span> (!running_) <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="keyword">event</span> = event_queue_.top();</div>
<div class="line">                event_queue_.pop();</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">auto</span> range = handlers_.equal_range(event.type());</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) {</div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                    it-&gt;second.handler(event);</div>
<div class="line">                } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                    logger_.error(<span class="stringliteral">&quot;Event handler failed: {}&quot;</span>, e.what());</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="anamespacethread__pool__module_html_add8b8e5f5fd0f12965fb6fdda6b22355ab988295c268025b49dfb3df26171ddc3"><div class="ttname"><a href="../../d8/d98/namespacethread__pool__module.html#add8b8e5f5fd0f12965fb6fdda6b22355ab988295c268025b49dfb3df26171ddc3">thread_pool_module::scheduling_policy::priority</a></div><div class="ttdeci">@ priority</div><div class="ttdoc">Priority-based scheduling.</div></div>
</div><!-- fragment --><p><b>Usage in System</b>:</p><ul>
<li>Core messaging infrastructure</li>
<li>System event handling</li>
<li>Async processing</li>
<li>Service communication</li>
</ul>
<h1><a class="anchor" id="autotoc_md1795"></a>
Summary</h1>
<p>The Messaging System leverages these design patterns to achieve:</p>
<ol type="1">
<li><b>Flexibility</b>: Factory and Strategy patterns enable runtime configuration</li>
<li><b>Scalability</b>: Producer-Consumer and Thread Pool patterns handle load</li>
<li><b>Maintainability</b>: Template Method and Decorator patterns provide structure</li>
<li><b>Performance</b>: Object Pool and Proxy patterns optimize resources</li>
<li><b>Reliability</b>: Command and Observer patterns ensure consistency</li>
<li><b>Extensibility</b>: Plugin and Adapter patterns allow easy integration</li>
</ol>
<p>Each pattern is carefully chosen to solve specific architectural challenges while maintaining system coherence and performance requirements. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
