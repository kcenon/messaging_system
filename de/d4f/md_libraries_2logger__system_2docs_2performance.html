<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: Logger System Performance Guide</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('de/d4f/md_libraries_2logger__system_2docs_2performance.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Logger System Performance Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md308"></a> </p>
<h1><a class="anchor" id="autotoc_md309"></a>
Overview</h1>
<p>The Logger System is designed for high-performance logging in multi-threaded applications. This guide covers performance characteristics, benchmarks, and optimization strategies.</p>
<h1><a class="anchor" id="autotoc_md310"></a>
Performance Characteristics</h1>
<h2><a class="anchor" id="autotoc_md311"></a>
Synchronous Mode</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Typical Latency   </th><th class="markdownTableHeadNone">Throughput    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Console Write   </td><td class="markdownTableBodyNone">50-200 μs   </td><td class="markdownTableBodyNone">~5K-20K logs/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">File Write   </td><td class="markdownTableBodyNone">20-100 μs   </td><td class="markdownTableBodyNone">~10K-50K logs/sec    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Memory Write   </td><td class="markdownTableBodyNone">&lt; 1 μs   </td><td class="markdownTableBodyNone">&gt; 1M logs/sec   </td></tr>
</table>
<p><b>Characteristics:</b></p><ul>
<li>Direct I/O blocking</li>
<li>Latency depends on output device</li>
<li>No additional memory overhead</li>
<li>Zero background CPU usage</li>
</ul>
<h2><a class="anchor" id="autotoc_md312"></a>
Asynchronous Mode</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Operation   </th><th class="markdownTableHeadNone">Typical Latency   </th><th class="markdownTableHeadNone">Throughput    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Log Enqueue   </td><td class="markdownTableBodyNone">&lt; 1 μs   </td><td class="markdownTableBodyNone">&gt; 1M logs/sec    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Background Processing   </td><td class="markdownTableBodyNone">N/A   </td><td class="markdownTableBodyNone">Hardware limited   </td></tr>
</table>
<p><b>Characteristics:</b></p><ul>
<li>Non-blocking enqueue</li>
<li>Decoupled from I/O latency</li>
<li>Configurable memory buffer</li>
<li>One background thread</li>
</ul>
<h1><a class="anchor" id="autotoc_md313"></a>
Benchmarks</h1>
<h2><a class="anchor" id="autotoc_md314"></a>
Test Environment</h2>
<ul>
<li>CPU: Intel Core i7-9700K @ 3.6GHz</li>
<li>RAM: 32GB DDR4</li>
<li>OS: Ubuntu 20.04 LTS</li>
<li>Compiler: GCC 10.3 with -O3</li>
</ul>
<h2><a class="anchor" id="autotoc_md315"></a>
Single Thread Performance</h2>
<div class="fragment"><div class="line"><span class="comment">// Benchmark: 1 million log messages</span></div>
<div class="line"><span class="keyword">auto</span> logger = std::make_shared&lt;logger_module::logger&gt;(<span class="keyword">true</span>, 16384);</div>
<div class="line">logger-&gt;add_writer(std::make_unique&lt;null_writer&gt;()); <span class="comment">// No I/O</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1&#39;000&#39;000; ++i) {</div>
<div class="line">    logger-&gt;log(log_level::info, <span class="stringliteral">&quot;Test message &quot;</span> + std::to_string(i));</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
</div><!-- fragment --><p><b>Results:</b></p><ul>
<li>Async mode: ~1.2M logs/second</li>
<li>Sync mode: ~2.5M logs/second (null writer)</li>
<li>Sync mode: ~15K logs/second (console writer)</li>
</ul>
<h2><a class="anchor" id="autotoc_md316"></a>
Multi-threaded Performance</h2>
<div class="fragment"><div class="line"><span class="comment">// Benchmark: 4 threads, 250K messages each</span></div>
<div class="line">std::vector&lt;std::thread&gt; threads;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> t = 0; t &lt; 4; ++t) {</div>
<div class="line">    threads.emplace_back([&amp;logger, t]() {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 250&#39;000; ++i) {</div>
<div class="line">            logger-&gt;log(log_level::info, </div>
<div class="line">                       <span class="stringliteral">&quot;Thread &quot;</span> + std::to_string(t) + <span class="stringliteral">&quot; msg &quot;</span> + std::to_string(i));</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Results:</b></p><ul>
<li>Async mode: ~950K logs/second (total)</li>
<li>Sync mode: ~12K logs/second (console, contention)</li>
</ul>
<h2><a class="anchor" id="autotoc_md317"></a>
Memory Usage</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Configuration   </th><th class="markdownTableHeadNone">Memory Usage    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Base logger   </td><td class="markdownTableBodyNone">~1 KB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Async buffer (8K entries)   </td><td class="markdownTableBodyNone">~256 KB    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Async buffer (64K entries)   </td><td class="markdownTableBodyNone">~2 MB    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Per log entry   </td><td class="markdownTableBodyNone">~32-128 bytes   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md318"></a>
Optimization Strategies</h1>
<h2><a class="anchor" id="autotoc_md319"></a>
1. Choose the Right Mode</h2>
<p><b>Use Synchronous Mode When:</b></p><ul>
<li>Logging frequency is low (&lt; 100 logs/sec)</li>
<li>Latency is not critical</li>
<li>Memory is extremely constrained</li>
<li>You need guaranteed immediate output</li>
</ul>
<p><b>Use Asynchronous Mode When:</b></p><ul>
<li>High-frequency logging (&gt; 1000 logs/sec)</li>
<li>Low latency is critical</li>
<li>Multiple threads are logging</li>
<li>I/O performance varies</li>
</ul>
<h2><a class="anchor" id="autotoc_md320"></a>
2. Buffer Size Tuning</h2>
<div class="fragment"><div class="line"><span class="comment">// Calculate optimal buffer size</span></div>
<div class="line"><span class="keywordtype">size_t</span> logs_per_second = 10000;</div>
<div class="line"><span class="keywordtype">size_t</span> buffer_time_seconds = 1;</div>
<div class="line"><span class="keywordtype">size_t</span> safety_factor = 2;</div>
<div class="line"><span class="keywordtype">size_t</span> buffer_size = logs_per_second * buffer_time_seconds * safety_factor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> logger = std::make_shared&lt;logger_module::logger&gt;(<span class="keyword">true</span>, buffer_size);</div>
</div><!-- fragment --><p><b>Guidelines:</b></p><ul>
<li>Start with default (8192)</li>
<li>Monitor dropped messages</li>
<li>Increase for burst handling</li>
<li>Consider memory constraints</li>
</ul>
<h2><a class="anchor" id="autotoc_md321"></a>
3. Level Filtering</h2>
<div class="fragment"><div class="line"><span class="comment">// Filter early to avoid processing</span></div>
<div class="line">logger-&gt;set_min_level(log_level::info);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check before expensive operations</span></div>
<div class="line"><span class="keywordflow">if</span> (logger-&gt;is_enabled(log_level::debug)) {</div>
<div class="line">    std::string expensive_msg = build_debug_string();</div>
<div class="line">    logger-&gt;log(log_level::debug, expensive_msg);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md322"></a>
4. Message Construction</h2>
<div class="fragment"><div class="line"><span class="comment">// Avoid string concatenation in hot paths</span></div>
<div class="line"><span class="comment">// Bad:</span></div>
<div class="line">logger-&gt;log(log_level::info, <span class="stringliteral">&quot;Value: &quot;</span> + std::to_string(value) + </div>
<div class="line">                            <span class="stringliteral">&quot; Status: &quot;</span> + status);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good:</span></div>
<div class="line"><span class="keyword">thread_local</span> <span class="keywordtype">char</span> buffer[256];</div>
<div class="line">snprintf(buffer, <span class="keyword">sizeof</span>(buffer), <span class="stringliteral">&quot;Value: %d Status: %s&quot;</span>, value, status);</div>
<div class="line">logger-&gt;log(log_level::info, buffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Better (when available):</span></div>
<div class="line">logger-&gt;log(log_level::info, std::format(<span class="stringliteral">&quot;Value: {} Status: {}&quot;</span>, value, status));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md323"></a>
5. Writer Optimization</h2>
<h3><a class="anchor" id="autotoc_md324"></a>
Console Writer</h3>
<div class="fragment"><div class="line"><span class="comment">// Disable colors for better performance</span></div>
<div class="line"><span class="keyword">auto</span> console = std::make_unique&lt;console_writer&gt;();</div>
<div class="line">console-&gt;set_use_color(<span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use stderr for all output (single stream)</span></div>
<div class="line"><span class="keyword">auto</span> console = std::make_unique&lt;console_writer&gt;(<span class="keyword">true</span>);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md325"></a>
Custom High-Performance Writer</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>memory_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line">    std::vector&lt;std::string&gt; logs_;</div>
<div class="line">    <span class="keyword">mutable</span> std::mutex mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> write(log_level level, <span class="keyword">const</span> std::string&amp; message,</div>
<div class="line">               <span class="keyword">const</span> std::string&amp; file, <span class="keywordtype">int</span> line,</div>
<div class="line">               <span class="keyword">const</span> std::string&amp; function,</div>
<div class="line">               <span class="keyword">const</span> std::chrono::system_clock::time_point&amp; timestamp)<span class="keyword"> override </span>{</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        logs_.reserve(logs_.size() + 1);</div>
<div class="line">        logs_.emplace_back(format_log_entry(level, message, file, line, </div>
<div class="line">                                           function, timestamp));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> flush()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// No-op for memory writer</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md326"></a>
6. Batch Processing</h2>
<p>For custom writers, implement batching:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>batched_file_writer : <span class="keyword">public</span> base_writer {</div>
<div class="line">    std::vector&lt;std::string&gt; batch_;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> <a class="code hl_variable" href="../../d7/d0d/mpmc__performance__test_8cpp.html#af182bc9822b8d2beb66c8ee495a6d61f">BATCH_SIZE</a> = 100;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> write(...)<span class="keyword"> override </span>{</div>
<div class="line">        batch_.push_back(format_log_entry(...));</div>
<div class="line">        <span class="keywordflow">if</span> (batch_.size() &gt;= <a class="code hl_variable" href="../../d7/d0d/mpmc__performance__test_8cpp.html#af182bc9822b8d2beb66c8ee495a6d61f">BATCH_SIZE</a>) {</div>
<div class="line">            flush();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> flush()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Write entire batch at once</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; entry : batch_) {</div>
<div class="line">            file_.write(entry.data(), entry.size());</div>
<div class="line">        }</div>
<div class="line">        file_.flush();</div>
<div class="line">        batch_.clear();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="ampmc__performance__test_8cpp_html_af182bc9822b8d2beb66c8ee495a6d61f"><div class="ttname"><a href="../../d7/d0d/mpmc__performance__test_8cpp.html#af182bc9822b8d2beb66c8ee495a6d61f">BATCH_SIZE</a></div><div class="ttdeci">constexpr size_t BATCH_SIZE</div><div class="ttdef"><b>Definition</b> <a href="../../d7/d0d/mpmc__performance__test_8cpp_source.html#l00046">mpmc_performance_test.cpp:46</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md327"></a>
Performance Anti-patterns</h1>
<h2><a class="anchor" id="autotoc_md328"></a>
1. Synchronous I/O in Hot Paths</h2>
<div class="fragment"><div class="line"><span class="comment">// Bad: Blocks on every call</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; item : large_collection) {</div>
<div class="line">    <a class="code hl_variable" href="../../d9/d71/logger__performance__benchmark_8cpp.html#aa7967b02d9eabe1d0e1f94f31e6d5c23">sync_logger</a>-&gt;log(log_level::debug, <span class="stringliteral">&quot;Processing: &quot;</span> + item.name());</div>
<div class="line">    process(item);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good: Use async or batch</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_variable" href="../../d9/d71/logger__performance__benchmark_8cpp.html#a915aa603431588879c0d37ddd854d206">async_logger</a> = std::make_shared&lt;logger&gt;(<span class="keyword">true</span>);</div>
<div class="ttc" id="alogger__performance__benchmark_8cpp_html_a915aa603431588879c0d37ddd854d206"><div class="ttname"><a href="../../d9/d71/logger__performance__benchmark_8cpp.html#a915aa603431588879c0d37ddd854d206">async_logger</a></div><div class="ttdeci">static std::unique_ptr&lt; logger &gt; async_logger</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d71/logger__performance__benchmark_8cpp_source.html#l00061">logger_performance_benchmark.cpp:61</a></div></div>
<div class="ttc" id="alogger__performance__benchmark_8cpp_html_aa7967b02d9eabe1d0e1f94f31e6d5c23"><div class="ttname"><a href="../../d9/d71/logger__performance__benchmark_8cpp.html#aa7967b02d9eabe1d0e1f94f31e6d5c23">sync_logger</a></div><div class="ttdeci">static std::unique_ptr&lt; logger &gt; sync_logger</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d71/logger__performance__benchmark_8cpp_source.html#l00060">logger_performance_benchmark.cpp:60</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md329"></a>
2. Excessive String Formatting</h2>
<div class="fragment"><div class="line"><span class="comment">// Bad: Creates many temporaries</span></div>
<div class="line">logger-&gt;log(level, <span class="stringliteral">&quot;A: &quot;</span> + a + <span class="stringliteral">&quot; B: &quot;</span> + b + <span class="stringliteral">&quot; C: &quot;</span> + c);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good: Single allocation</span></div>
<div class="line">logger-&gt;log(level, std::format(<span class="stringliteral">&quot;A: {} B: {} C: {}&quot;</span>, a, b, c));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md330"></a>
3. Logging in Tight Loops</h2>
<div class="fragment"><div class="line"><span class="comment">// Bad: Logs every iteration</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {</div>
<div class="line">    logger-&gt;log(log_level::trace, <span class="stringliteral">&quot;Iteration &quot;</span> + std::to_string(i));</div>
<div class="line">    <span class="comment">// work</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Good: Sample or summarize</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000000; ++i) {</div>
<div class="line">    <span class="keywordflow">if</span> (i % 10000 == 0) {</div>
<div class="line">        logger-&gt;log(log_level::debug, <span class="stringliteral">&quot;Progress: &quot;</span> + std::to_string(i));</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// work</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md331"></a>
Profiling and Monitoring</h1>
<h2><a class="anchor" id="autotoc_md332"></a>
Built-in Metrics</h2>
<p>Monitor logger performance:</p>
<div class="fragment"><div class="line"><span class="comment">// Check if buffers are overflowing</span></div>
<div class="line"><span class="keyword">class </span>monitoring_logger : <span class="keyword">public</span> logger {</div>
<div class="line">    std::atomic&lt;size_t&gt; dropped_messages_{0};</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> log(...)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (!try_enqueue(...)) {</div>
<div class="line">            dropped_messages_.fetch_add(1);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">size_t</span> get_dropped_count()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> dropped_messages_.load();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md333"></a>
External Profiling</h2>
<p>Use system tools:</p><ul>
<li><code>perf</code> for CPU profiling</li>
<li><code>valgrind</code> for memory analysis</li>
<li><code>strace</code> for system call analysis</li>
</ul>
<div class="fragment"><div class="line"># Profile CPU usage</div>
<div class="line">perf record -g ./your_app</div>
<div class="line">perf report</div>
<div class="line"> </div>
<div class="line"># Check system calls</div>
<div class="line">strace -c ./your_app</div>
<div class="line"> </div>
<div class="line"># Memory profiling</div>
<div class="line">valgrind --tool=massif ./your_app</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md334"></a>
Best Practices Summary</h1>
<ol type="1">
<li><b>Default to Async Mode</b> - Better performance for most use cases</li>
<li><b>Set Appropriate Levels</b> - Filter early to reduce overhead</li>
<li><b>Size Buffers Correctly</b> - Based on expected load</li>
<li><b>Minimize Allocations</b> - Reuse buffers, avoid string concatenation</li>
<li><b>Batch I/O Operations</b> - Reduce system call overhead</li>
<li><b>Profile Real Workloads</b> - Measure actual performance</li>
<li><b>Monitor Health</b> - Track dropped messages and latency</li>
</ol>
<h1><a class="anchor" id="autotoc_md335"></a>
Platform-Specific Optimizations</h1>
<h2><a class="anchor" id="autotoc_md336"></a>
Linux</h2>
<ul>
<li>Use <code>io_uring</code> for file writes (future)</li>
<li>Consider <code>mmap</code> for large log files</li>
<li>Tune kernel buffers for network logging</li>
</ul>
<h2><a class="anchor" id="autotoc_md337"></a>
Windows</h2>
<ul>
<li>Use overlapped I/O for async file writes</li>
<li>Consider ETW for system integration</li>
<li>Optimize console API usage</li>
</ul>
<h2><a class="anchor" id="autotoc_md338"></a>
macOS</h2>
<ul>
<li>Use Grand Central Dispatch for async operations</li>
<li>Consider os_log for system integration</li>
<li>Optimize for unified buffer cache </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
