<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: Thread System Examples</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('de/deb/md_libraries_2thread__system_2docs_2examples.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Thread System Examples</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md918"></a> This guide contains practical examples demonstrating how to use the Thread System framework in real-world scenarios.</p>
<h1><a class="anchor" id="autotoc_md919"></a>
Quick Start Examples</h1>
<h2><a class="anchor" id="autotoc_md920"></a>
Hello World with Thread Pool</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../db/d5d/basic__usage__example_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="comment">// Create thread pool</span></div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add workers</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; workers;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">        workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">    }</div>
<div class="line">    pool-&gt;enqueue_batch(std::move(workers));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Start pool</span></div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Submit job</span></div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">        []() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Hello from thread pool!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        }</div>
<div class="line">    ));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for completion</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Clean up</span></div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="abasic__usage__example_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="../../db/d5d/basic__usage__example_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> <a href="../../db/d5d/basic__usage__example_8cpp_source.html#l00015">basic_usage_example.cpp:15</a></div></div>
<div class="ttc" id="aclassthread__module_1_1result__void_html"><div class="ttname"><a href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a></div><div class="ttdoc">Wrapper for void result.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d4e/modular__structure_2core_2include_2thread__system__core_2thread__base_2sync_2error__handling_8h_source.html#l00197">error_handling.h:197</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md921"></a>
Parallel Computation</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> parallel_sum(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; data) {</div>
<div class="line">    <span class="comment">// Create thread pool</span></div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add 4 workers</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; workers;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">        workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">    }</div>
<div class="line">    pool-&gt;enqueue_batch(std::move(workers));</div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size = data.size() / 4;</div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;double&gt;&gt; results;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">        <span class="keyword">auto</span> start = data.begin() + i * chunk_size;</div>
<div class="line">        <span class="keyword">auto</span> end = (i == 3) ? data.end() : start + chunk_size;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> result = std::make_shared&lt;double&gt;(0.0);</div>
<div class="line">        results.push_back(result);</div>
<div class="line">        </div>
<div class="line">        pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [start, end, result]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                *result = std::accumulate(start, end, 0.0);</div>
<div class="line">                <span class="keywordflow">return</span> {};</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for all jobs to complete</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">double</span> total = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; result : results) {</div>
<div class="line">        total += *result;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">    <span class="keywordflow">return</span> total;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md922"></a>
Basic Examples</h1>
<h2><a class="anchor" id="autotoc_md923"></a>
Simple Job Submission</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../db/d5d/basic__usage__example_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="comment">// Create and configure pool</span></div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add 2 workers</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; workers;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">        workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> error = pool-&gt;enqueue_batch(std::move(workers))) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to add workers: &quot;</span> &lt;&lt; *error &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">auto</span> error = pool-&gt;start()) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to start pool: &quot;</span> &lt;&lt; *<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Submit job with shared result</span></div>
<div class="line">    <span class="keyword">auto</span> result = std::make_shared&lt;int&gt;(0);</div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">        [result]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">            *result = 42;</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        }</div>
<div class="line">    ));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait and get result</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; *result &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1integrations_html_a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282"><div class="ttname"><a href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">kcenon::messaging::integrations::external_system_status::error</a></div><div class="ttdeci">@ error</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md924"></a>
Error Handling</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../db/d5d/basic__usage__example_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add workers</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; workers;</div>
<div class="line">    workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">    workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">    pool-&gt;enqueue_batch(std::move(workers));</div>
<div class="line">    </div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Submit job that fails</span></div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">        []() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">            <span class="comment">// Simulate error</span></div>
<div class="line">            <span class="keywordflow">return</span> thread_module::error_info(</div>
<div class="line">                thread_module::error_type::runtime_error,</div>
<div class="line">                <span class="stringliteral">&quot;Something went wrong!&quot;</span></div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">    ));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// The error will be logged by the worker</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    </div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md925"></a>
File Processing</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;filesystem&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> process_files(<span class="keyword">const</span> std::vector&lt;std::filesystem::path&gt;&amp; files) {</div>
<div class="line">    <span class="comment">// Create pool</span></div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add workers</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; workers;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">        workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">    }</div>
<div class="line">    pool-&gt;enqueue_batch(std::move(workers));</div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Process each file</span></div>
<div class="line">    std::vector&lt;std::shared_ptr&lt;size_t&gt;&gt; line_counts;</div>
<div class="line">    <span class="keyword">auto</span> output_mutex = std::make_shared&lt;std::mutex&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : files) {</div>
<div class="line">        <span class="keyword">auto</span> count = std::make_shared&lt;size_t&gt;(0);</div>
<div class="line">        line_counts.push_back(count);</div>
<div class="line">        </div>
<div class="line">        pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [file, count, output_mutex]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                std::ifstream ifs(file);</div>
<div class="line">                <span class="keywordflow">if</span> (!ifs) {</div>
<div class="line">                    <span class="keywordflow">return</span> thread_module::error_info(</div>
<div class="line">                        thread_module::error_type::file_not_found,</div>
<div class="line">                        <span class="stringliteral">&quot;Cannot open file: &quot;</span> + file.string()</div>
<div class="line">                    );</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                std::string line;</div>
<div class="line">                <span class="keywordflow">while</span> (std::getline(ifs, line)) {</div>
<div class="line">                    (*count)++;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                {</div>
<div class="line">                    std::lock_guard&lt;std::mutex&gt; lock(*output_mutex);</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; file.filename().string() </div>
<div class="line">                              &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; *count &lt;&lt; <span class="stringliteral">&quot; lines&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> {};</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for all files to be processed</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Report total</span></div>
<div class="line">    <span class="keywordtype">size_t</span> total = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; count : line_counts) {</div>
<div class="line">        total += *count;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Total lines: &quot;</span> &lt;&lt; total &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Clean up</span></div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md926"></a>
Type-Based Thread Pool Examples</h1>
<h2><a class="anchor" id="autotoc_md927"></a>
Basic Type Scheduling</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;typed_thread_pool/pool/typed_thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;typed_thread_pool/jobs/callback_typed_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../db/d5d/basic__usage__example_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="comment">// Create typed thread pool</span></div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;typed_thread_pool_module::typed_thread_pool&gt;();</div>
<div class="line">    <span class="keyword">auto</span> output_mutex = std::make_shared&lt;std::mutex&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add workers with different type responsibilities</span></div>
<div class="line">    <span class="comment">// Worker 1: Only handles High priority</span></div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;<a class="code hl_class" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t&lt;job_types&gt;</a>&gt;(</div>
<div class="line">        std::initializer_list&lt;job_types&gt;{job_types::High}</div>
<div class="line">    ));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Worker 2: Handles Normal and Low priority</span></div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;<a class="code hl_class" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t&lt;job_types&gt;</a>&gt;(</div>
<div class="line">        std::initializer_list&lt;job_types&gt;{job_types::Normal, job_types::Low}</div>
<div class="line">    ));</div>
<div class="line">    </div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Submit jobs with different priorities</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; ++i) {</div>
<div class="line">        pool-&gt;enqueue(std::make_unique&lt;<a class="code hl_class" href="../../d3/dea/classtyped__thread__pool__module_1_1callback__typed__job__t.html">typed_thread_pool_module::callback_typed_job&lt;job_types&gt;</a>&gt;(</div>
<div class="line">            job_types::High,</div>
<div class="line">            [i, output_mutex]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(*output_mutex);</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;High priority job &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span> {};</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">        </div>
<div class="line">        pool-&gt;enqueue(std::make_unique&lt;<a class="code hl_class" href="../../d3/dea/classtyped__thread__pool__module_1_1callback__typed__job__t.html">typed_thread_pool_module::callback_typed_job&lt;job_types&gt;</a>&gt;(</div>
<div class="line">            job_types::Low,</div>
<div class="line">            [i, output_mutex]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(*output_mutex);</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Low priority job &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span> {};</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// High priority jobs will be processed first</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    </div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasstyped__thread__pool__module_1_1callback__typed__job__t_html"><div class="ttname"><a href="../../d3/dea/classtyped__thread__pool__module_1_1callback__typed__job__t.html">typed_thread_pool_module::callback_typed_job_t</a></div><div class="ttdoc">A template for creating priority-based jobs that execute a user-defined callback.</div><div class="ttdef"><b>Definition</b> <a href="../../d2/da8/sources_2typed__thread__pool_2jobs_2callback__typed__job_8h_source.html#l00054">callback_typed_job.h:55</a></div></div>
<div class="ttc" id="aclasstyped__thread__pool__module_1_1typed__thread__worker__t_html"><div class="ttname"><a href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t</a></div><div class="ttdoc">A template-based worker thread class that processes jobs from a priority job queue.</div><div class="ttdef"><b>Definition</b> <a href="../../dc/d5f/sources_2typed__thread__pool_2scheduling_2typed__thread__worker_8h_source.html#l00094">typed_thread_worker.h:95</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md928"></a>
Custom Type Types</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;typed_thread_pool/pool/typed_thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;typed_thread_pool/jobs/typed_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define custom priority types</span></div>
<div class="line"><span class="keyword">enum class</span> TaskPriority : uint8_t {</div>
<div class="line">    Critical = 1,</div>
<div class="line">    UserInteractive = 2,</div>
<div class="line">    Background = 3,</div>
<div class="line">    Maintenance = 4</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom job implementation</span></div>
<div class="line"><span class="keyword">class </span>MyCustomJob : <span class="keyword">public</span> <a class="code hl_class" href="../../d8/d4f/classtyped__thread__pool__module_1_1typed__job__t.html">typed_thread_pool_module::typed_job_t</a>&lt;TaskPriority&gt; {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::string task_name_;</div>
<div class="line">    std::shared_ptr&lt;std::mutex&gt; output_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyCustomJob(TaskPriority priority, <span class="keyword">const</span> std::string&amp; name, </div>
<div class="line">                std::shared_ptr&lt;std::mutex&gt; mutex)</div>
<div class="line">        : typed_job_t&lt;TaskPriority&gt;(priority), </div>
<div class="line">          task_name_(name), </div>
<div class="line">          output_mutex_(mutex) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> operator()() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(*output_mutex_);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Executing priority &quot;</span> &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(get_type()) </div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; task_name_ &lt;&lt; std::endl;</div>
<div class="line">        <span class="comment">// Do actual work here</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../db/d5d/basic__usage__example_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="comment">// Create pool with custom priority type</span></div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;typed_thread_pool_module::typed_thread_pool_t&lt;TaskPriority&gt;&gt;();</div>
<div class="line">    <span class="keyword">auto</span> output_mutex = std::make_shared&lt;std::mutex&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add workers</span></div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;<a class="code hl_class" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t&lt;TaskPriority&gt;</a>&gt;(</div>
<div class="line">        std::initializer_list&lt;TaskPriority&gt;{TaskPriority::Critical, TaskPriority::UserInteractive}</div>
<div class="line">    ));</div>
<div class="line">    </div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Submit custom jobs</span></div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;MyCustomJob&gt;(TaskPriority::Critical, <span class="stringliteral">&quot;Database backup&quot;</span>, output_mutex));</div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;MyCustomJob&gt;(TaskPriority::Background, <span class="stringliteral">&quot;Cache cleanup&quot;</span>, output_mutex));</div>
<div class="line">    </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    </div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclasstyped__thread__pool__module_1_1typed__job__t_html"><div class="ttname"><a href="../../d8/d4f/classtyped__thread__pool__module_1_1typed__job__t.html">typed_thread_pool_module::typed_job_t</a></div><div class="ttdoc">Represents a job that carries a specific priority level.</div><div class="ttdef"><b>Definition</b> <a href="../../d7/da0/sources_2typed__thread__pool_2jobs_2typed__job_8h_source.html#l00057">typed_job.h:58</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md929"></a>
Advanced Thread Pool Examples</h1>
<h2><a class="anchor" id="autotoc_md930"></a>
Custom Job Priority Queue</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;condition_variable&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PriorityJobQueue {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>PriorityJob {</div>
<div class="line">        <span class="keywordtype">int</span> priority;</div>
<div class="line">        std::function&lt;void()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> PriorityJob&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">            <span class="keywordflow">return</span> priority &lt; other.priority; <span class="comment">// Higher priority first</span></div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::priority_queue&lt;PriorityJob&gt; queue_;</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    std::condition_variable cv_;</div>
<div class="line">    <span class="keywordtype">bool</span> stopped_ = <span class="keyword">false</span>;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> add_job(<span class="keywordtype">int</span> priority, std::function&lt;<span class="keywordtype">void</span>()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        queue_.push({<a class="code hl_enumvalue" href="../../d8/d98/namespacethread__pool__module.html#add8b8e5f5fd0f12965fb6fdda6b22355ab988295c268025b49dfb3df26171ddc3">priority</a>, std::move(<a class="code hl_struct" href="../../db/da2/structtask.html">task</a>)});</div>
<div class="line">        cv_.notify_one();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::optional&lt;std::function&lt;void()&gt;&gt; get_job() {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        cv_.wait(lock, [<span class="keyword">this</span>] { <span class="keywordflow">return</span> !queue_.empty() || stopped_; });</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (stopped_ &amp;&amp; queue_.empty()) {</div>
<div class="line">            <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> job = queue_.top();</div>
<div class="line">        queue_.pop();</div>
<div class="line">        <span class="keywordflow">return</span> job.task;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        stopped_ = <span class="keyword">true</span>;</div>
<div class="line">        cv_.notify_all();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> example_priority_processing() {</div>
<div class="line">    <span class="keyword">auto</span> queue = std::make_shared&lt;PriorityJobQueue&gt;();</div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add workers</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; workers;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">        workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">    }</div>
<div class="line">    pool-&gt;enqueue_batch(std::move(workers));</div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Worker thread to process priority queue</span></div>
<div class="line">    pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">        [queue]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">            <span class="keywordflow">while</span> (<span class="keyword">auto</span> job = queue-&gt;get_job()) {</div>
<div class="line">                (*job)();</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        }</div>
<div class="line">    ));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add jobs with different priorities</span></div>
<div class="line">    queue-&gt;add_job(1, []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Low priority task&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    queue-&gt;add_job(10, []() { std::cout &lt;&lt; <span class="stringliteral">&quot;High priority task&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    queue-&gt;add_job(5, []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Medium priority task&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    queue-&gt;stop();</div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">}</div>
<div class="ttc" id="anamespacethread__pool__module_html_add8b8e5f5fd0f12965fb6fdda6b22355ab988295c268025b49dfb3df26171ddc3"><div class="ttname"><a href="../../d8/d98/namespacethread__pool__module.html#add8b8e5f5fd0f12965fb6fdda6b22355ab988295c268025b49dfb3df26171ddc3">thread_pool_module::scheduling_policy::priority</a></div><div class="ttdeci">@ priority</div><div class="ttdoc">Priority-based scheduling.</div></div>
<div class="ttc" id="astructtask_html"><div class="ttname"><a href="../../db/da2/structtask.html">task</a></div><div class="ttdef"><b>Definition</b> <a href="../../d4/daa/distributed__worker_8cpp_source.html#l00033">distributed_worker.cpp:33</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md931"></a>
Performance Measurement</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_base/core/thread_base.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PerformanceTimer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::string operation_;</div>
<div class="line">    std::chrono::high_resolution_clock::time_point start_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PerformanceTimer(<span class="keyword">const</span> std::string&amp; operation) </div>
<div class="line">        : operation_(operation), </div>
<div class="line">          start_(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::chrono::high_resolution_clock::now()) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Starting: &quot;</span> &lt;&lt; operation_ &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ~PerformanceTimer() {</div>
<div class="line">        <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start_);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Completed: &quot;</span> &lt;&lt; operation_ </div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) </div>
<div class="line">                  &lt;&lt; duration.count() / 1000.0 &lt;&lt; <span class="stringliteral">&quot;ms)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> measure_thread_pool_performance() {</div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Add workers</span></div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; workers;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">        workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">    }</div>
<div class="line">    pool-&gt;enqueue_batch(std::move(workers));</div>
<div class="line">    pool-&gt;start();</div>
<div class="line">    </div>
<div class="line">    {</div>
<div class="line">        PerformanceTimer timer(<span class="stringliteral">&quot;1000 job submissions&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::atomic&lt;int&gt; <a class="code hl_enumvalue" href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#a0ebc74b13acdfe5c2939ed4e5acaeab6aaa8fb77e57d1ca18d593e909729871fe">completed</a>{0};</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">            pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">                [&amp;completed]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                    <span class="comment">// Simulate work</span></div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">                    <a class="code hl_enumvalue" href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#a0ebc74b13acdfe5c2939ed4e5acaeab6aaa8fb77e57d1ca18d593e909729871fe">completed</a>++;</div>
<div class="line">                    <span class="keywordflow">return</span> {};</div>
<div class="line">                }</div>
<div class="line">            ));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Wait for completion</span></div>
<div class="line">        <span class="keywordflow">while</span> (completed &lt; 1000) {</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">}</div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1core_html_a0ebc74b13acdfe5c2939ed4e5acaeab6aaa8fb77e57d1ca18d593e909729871fe"><div class="ttname"><a href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#a0ebc74b13acdfe5c2939ed4e5acaeab6aaa8fb77e57d1ca18d593e909729871fe">kcenon::messaging::core::message_status::completed</a></div><div class="ttdeci">@ completed</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="../../d8/dcc/namespacestd.html">std</a></div><div class="ttdoc">STL namespace.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md932"></a>
Real-World Scenarios</h1>
<h2><a class="anchor" id="autotoc_md933"></a>
Web Server Request Handler</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;typed_thread_pool/pool/typed_thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>WebServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;typed_thread_pool_module::typed_thread_pool&gt; request_pool_;</div>
<div class="line">    std::shared_ptr&lt;thread_pool_module::thread_pool&gt; io_pool_;</div>
<div class="line">    std::shared_ptr&lt;std::mutex&gt; output_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    WebServer() : output_mutex_(<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::make_shared&lt;<a class="code hl_namespace" href="../../d8/dcc/namespacestd.html">std</a>::mutex&gt;()) {</div>
<div class="line">        <span class="comment">// Request handling pool with priorities</span></div>
<div class="line">        request_pool_ = std::make_shared&lt;typed_thread_pool_module::typed_thread_pool&gt;();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// High priority worker for API requests</span></div>
<div class="line">        request_pool_-&gt;enqueue(</div>
<div class="line">            std::make_unique&lt;<a class="code hl_class" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                std::initializer_list&lt;job_types&gt;{job_types::High}</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Normal priority workers for regular requests</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div>
<div class="line">            request_pool_-&gt;enqueue(</div>
<div class="line">                std::make_unique&lt;<a class="code hl_class" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                    std::initializer_list&lt;job_types&gt;{job_types::Normal, job_types::Low}</div>
<div class="line">                )</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// I/O pool for file operations</span></div>
<div class="line">        io_pool_ = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">        std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; io_workers;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">            io_workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">        }</div>
<div class="line">        io_pool_-&gt;enqueue_batch(std::move(io_workers));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        request_pool_-&gt;start();</div>
<div class="line">        io_pool_-&gt;start();</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(*output_mutex_);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Web server started&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> handle_request(<span class="keyword">const</span> std::string&amp; path, <span class="keywordtype">bool</span> is_api) {</div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../d8/d98/namespacethread__pool__module.html#add8b8e5f5fd0f12965fb6fdda6b22355ab988295c268025b49dfb3df26171ddc3">priority</a> = is_api ? job_types::High : job_types::Normal;</div>
<div class="line">        </div>
<div class="line">        request_pool_-&gt;enqueue(</div>
<div class="line">            std::make_unique&lt;<a class="code hl_class" href="../../d3/dea/classtyped__thread__pool__module_1_1callback__typed__job__t.html">typed_thread_pool_module::callback_typed_job&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                priority,</div>
<div class="line">                [<span class="keyword">this</span>, path]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                    {</div>
<div class="line">                        std::lock_guard&lt;std::mutex&gt; lock(*output_mutex_);</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;Processing request: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// Process request</span></div>
<div class="line">                    <span class="keywordflow">if</span> (path.starts_with(<span class="stringliteral">&quot;/static/&quot;</span>)) {</div>
<div class="line">                        serve_static_file(path.substr(8));</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        generate_response(path);</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">return</span> {};</div>
<div class="line">                }</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        request_pool_-&gt;stop();</div>
<div class="line">        io_pool_-&gt;stop();</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(*output_mutex_);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Web server stopped&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> serve_static_file(<span class="keyword">const</span> std::string&amp; file) {</div>
<div class="line">        io_pool_-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [<span class="keyword">this</span>, file]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                <span class="comment">// Read and serve file</span></div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(*output_mutex_);</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Serving static file: &quot;</span> &lt;&lt; file &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span> {};</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> generate_response(<span class="keyword">const</span> std::string&amp; path) {</div>
<div class="line">        <span class="comment">// Generate dynamic response</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(*output_mutex_);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Generating response for: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md934"></a>
Data Processing Pipeline</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;typed_thread_pool/pool/typed_thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DataPipeline {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>DataItem {</div>
<div class="line">        <span class="keywordtype">int</span> id;</div>
<div class="line">        std::vector&lt;double&gt; data;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::shared_ptr&lt;typed_thread_pool_module::typed_thread_pool&gt; pool_;</div>
<div class="line">    std::queue&lt;DataItem&gt; input_queue_;</div>
<div class="line">    std::mutex queue_mutex_;</div>
<div class="line">    std::mutex output_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataPipeline() {</div>
<div class="line">        pool_ = std::make_shared&lt;typed_thread_pool_module::typed_thread_pool&gt;();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Stage 1: Data ingestion (high priority)</span></div>
<div class="line">        pool_-&gt;enqueue(</div>
<div class="line">            std::make_unique&lt;<a class="code hl_class" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                std::initializer_list&lt;job_types&gt;{job_types::High}</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Stage 2: Processing (normal priority)</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {</div>
<div class="line">            pool_-&gt;enqueue(</div>
<div class="line">                std::make_unique&lt;<a class="code hl_class" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                    std::initializer_list&lt;job_types&gt;{job_types::Normal}</div>
<div class="line">                )</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Stage 3: Cleanup (low priority)</span></div>
<div class="line">        pool_-&gt;enqueue(</div>
<div class="line">            std::make_unique&lt;<a class="code hl_class" href="../../d0/d0f/classtyped__thread__pool__module_1_1typed__thread__worker__t.html">typed_thread_pool_module::typed_thread_worker_t&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                std::initializer_list&lt;job_types&gt;{job_types::Low}</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> process_batch(<span class="keyword">const</span> std::vector&lt;DataItem&gt;&amp; items) {</div>
<div class="line">        <span class="comment">// Stage 1: Ingest data</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : items) {</div>
<div class="line">            pool_-&gt;enqueue(</div>
<div class="line">                std::make_unique&lt;<a class="code hl_class" href="../../d3/dea/classtyped__thread__pool__module_1_1callback__typed__job__t.html">typed_thread_pool_module::callback_typed_job&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                    job_types::High,</div>
<div class="line">                    [<span class="keyword">this</span>, item]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                        validate_and_queue(item);</div>
<div class="line">                        <span class="keywordflow">return</span> {};</div>
<div class="line">                    }</div>
<div class="line">                )</div>
<div class="line">            );</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Stage 2: Process data</span></div>
<div class="line">        pool_-&gt;enqueue(</div>
<div class="line">            std::make_unique&lt;<a class="code hl_class" href="../../d3/dea/classtyped__thread__pool__module_1_1callback__typed__job__t.html">typed_thread_pool_module::callback_typed_job&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                job_types::Normal,</div>
<div class="line">                [<span class="keyword">this</span>]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                    process_queued_items();</div>
<div class="line">                    <span class="keywordflow">return</span> {};</div>
<div class="line">                }</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Stage 3: Cleanup</span></div>
<div class="line">        pool_-&gt;enqueue(</div>
<div class="line">            std::make_unique&lt;<a class="code hl_class" href="../../d3/dea/classtyped__thread__pool__module_1_1callback__typed__job__t.html">typed_thread_pool_module::callback_typed_job&lt;job_types&gt;</a>&gt;(</div>
<div class="line">                job_types::Low,</div>
<div class="line">                [<span class="keyword">this</span>]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                    cleanup_processed_data();</div>
<div class="line">                    <span class="keywordflow">return</span> {};</div>
<div class="line">                }</div>
<div class="line">            )</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> validate_and_queue(<span class="keyword">const</span> DataItem&amp; item) {</div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(output_mutex_);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Validating item &quot;</span> &lt;&lt; item.id &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Validation logic</span></div>
<div class="line">        <span class="keywordflow">if</span> (item.data.empty()) {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(output_mutex_);</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid data for item &quot;</span> &lt;&lt; item.id &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">        input_queue_.push(item);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> process_queued_items() {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">        <span class="keywordflow">while</span> (!input_queue_.empty()) {</div>
<div class="line">            <span class="keyword">auto</span> item = input_queue_.front();</div>
<div class="line">            input_queue_.pop();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Process data</span></div>
<div class="line">            <span class="keywordtype">double</span> sum = std::accumulate(item.data.begin(), item.data.end(), 0.0);</div>
<div class="line">            </div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; output_lock(output_mutex_);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Processed item &quot;</span> &lt;&lt; item.id </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;: sum = &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> cleanup_processed_data() {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(output_mutex_);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Performing cleanup&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="comment">// Cleanup logic</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md935"></a>
Best Practices</h1>
<h2><a class="anchor" id="autotoc_md936"></a>
Resource Management</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ResourcePool {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;thread_pool_module::thread_pool&gt; pool_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ResourcePool() {</div>
<div class="line">        pool_ = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Add workers</span></div>
<div class="line">        std::vector&lt;std::unique_ptr&lt;thread_pool_module::thread_worker&gt;&gt; workers;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">            workers.push_back(std::make_unique&lt;thread_pool_module::thread_worker&gt;());</div>
<div class="line">        }</div>
<div class="line">        pool_-&gt;enqueue_batch(std::move(workers));</div>
<div class="line">        pool_-&gt;start();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// RAII pattern for automatic cleanup</span></div>
<div class="line">    ~ResourcePool() {</div>
<div class="line">        <span class="keywordflow">if</span> (pool_) {</div>
<div class="line">            pool_-&gt;stop();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> process_with_timeout(std::function&lt;<span class="keywordtype">void</span>()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>, </div>
<div class="line">                             std::chrono::milliseconds timeout) {</div>
<div class="line">        <span class="keyword">auto</span> done = std::make_shared&lt;std::atomic&lt;bool&gt;&gt;(<span class="keyword">false</span>);</div>
<div class="line">        </div>
<div class="line">        pool_-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [<a class="code hl_struct" href="../../db/da2/structtask.html">task</a>, done]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>();</div>
<div class="line">                done-&gt;store(<span class="keyword">true</span>);</div>
<div class="line">                <span class="keywordflow">return</span> {};</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Wait with timeout</span></div>
<div class="line">        <span class="keyword">auto</span> start = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keywordflow">while</span> (!done-&gt;load()) {</div>
<div class="line">            <span class="keywordflow">if</span> (std::chrono::steady_clock::now() - start &gt; timeout) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Task timed out&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md937"></a>
Exception Safety</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;future&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;optional&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>SafeJobExecutor {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;thread_pool_module::thread_pool&gt; pool_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SafeJobExecutor(std::shared_ptr&lt;thread_pool_module::thread_pool&gt; pool) </div>
<div class="line">        : pool_(pool) {}</div>
<div class="line">    </div>
<div class="line">    std::future&lt;std::optional&lt;T&gt;&gt; execute_safe(std::function&lt;T()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>) {</div>
<div class="line">        <span class="keyword">auto</span> promise = std::make_shared&lt;std::promise&lt;std::optional&lt;T&gt;&gt;&gt;();</div>
<div class="line">        <span class="keyword">auto</span> future = promise-&gt;get_future();</div>
<div class="line">        </div>
<div class="line">        pool_-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [<a class="code hl_struct" href="../../db/da2/structtask.html">task</a>, promise]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                    T result = <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>();</div>
<div class="line">                    promise-&gt;set_value(result);</div>
<div class="line">                } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                    std::cerr &lt;&lt; <span class="stringliteral">&quot;Job failed: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">                    promise-&gt;set_value(std::nullopt);</div>
<div class="line">                } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">                    std::cerr &lt;&lt; <span class="stringliteral">&quot;Job failed: unknown error&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    promise-&gt;set_value(std::nullopt);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">return</span> {};</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> future;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md938"></a>
Examples with Optional Modules</h1>
<p>The Thread System can be enhanced with optional modules like logger and monitoring. These modules are maintained as separate projects but can be integrated when needed.</p>
<h2><a class="anchor" id="autotoc_md939"></a>
Integration with Logger Module</h2>
<p>If you have the logger module installed separately, you can enhance your thread pool with logging capabilities:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;thread_base/jobs/callback_job.h&quot;</span></div>
<div class="line"><span class="comment">// #include &quot;logger/core/logger.h&quot; // Include if logger module is available</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ThreadPoolWithOptionalLogging {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;thread_pool_module::thread_pool&gt; pool_;</div>
<div class="line">    <span class="keywordtype">bool</span> logging_enabled_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ThreadPoolWithOptionalLogging(<span class="keywordtype">bool</span> enable_logging = <span class="keyword">false</span>) </div>
<div class="line">        : logging_enabled_(enable_logging) {</div>
<div class="line">        pool_ = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Initialize logger if available and enabled</span></div>
<div class="line"><span class="preprocessor">        #ifdef HAS_LOGGER_MODULE</span></div>
<div class="line">        <span class="keywordflow">if</span> (logging_enabled_) {</div>
<div class="line">            log_module::start();</div>
<div class="line">            log_module::write_information(<span class="stringliteral">&quot;Thread pool initialized with logging&quot;</span>);</div>
<div class="line">        }</div>
<div class="line"><span class="preprocessor">        #endif</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ~ThreadPoolWithOptionalLogging() {</div>
<div class="line">        pool_-&gt;stop();</div>
<div class="line">        </div>
<div class="line"><span class="preprocessor">        #ifdef HAS_LOGGER_MODULE</span></div>
<div class="line">        <span class="keywordflow">if</span> (logging_enabled_) {</div>
<div class="line">            log_module::stop();</div>
<div class="line">        }</div>
<div class="line"><span class="preprocessor">        #endif</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> submit_job(std::function&lt;<span class="keywordtype">void</span>()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>) {</div>
<div class="line">        pool_-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [<span class="keyword">this</span>, <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>]() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a> {</div>
<div class="line"><span class="preprocessor">                #ifdef HAS_LOGGER_MODULE</span></div>
<div class="line">                <span class="keywordflow">if</span> (logging_enabled_) {</div>
<div class="line">                    log_module::write_debug(<span class="stringliteral">&quot;Starting job execution&quot;</span>);</div>
<div class="line">                }</div>
<div class="line"><span class="preprocessor">                #endif</span></div>
<div class="line">                </div>
<div class="line">                <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>();</div>
<div class="line">                </div>
<div class="line"><span class="preprocessor">                #ifdef HAS_LOGGER_MODULE</span></div>
<div class="line">                <span class="keywordflow">if</span> (logging_enabled_) {</div>
<div class="line">                    log_module::write_debug(<span class="stringliteral">&quot;Job execution completed&quot;</span>);</div>
<div class="line">                }</div>
<div class="line"><span class="preprocessor">                #endif</span></div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">return</span> {};</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md940"></a>
Custom Error Handler with Optional Monitoring</h2>
<p>You can implement custom error handlers that integrate with external monitoring systems:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;thread_pool/core/thread_pool.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;interfaces/error_handler.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CustomErrorHandler : <span class="keyword">public</span> <a class="code hl_class" href="../../dd/d11/classthread__module_1_1error__handler.html">thread_module::error_handler</a> {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::function&lt;void(<span class="keyword">const</span> std::string&amp;)&gt; monitor_callback_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    CustomErrorHandler(std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> std::string&amp;)&gt; callback = <span class="keyword">nullptr</span>)</div>
<div class="line">        : monitor_callback_(callback) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code hl_function" href="../../dd/d11/classthread__module_1_1error__handler.html#ab81b999f44040678850d75650599b407">handle_error</a>(<span class="keyword">const</span> thread_module::error_info&amp; error)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Basic error handling</span></div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Thread error: &quot;</span> &lt;&lt; error.message() &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Optional monitoring integration</span></div>
<div class="line">        <span class="keywordflow">if</span> (monitor_callback_) {</div>
<div class="line">            monitor_callback_(error.message());</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Could also integrate with external monitoring services</span></div>
<div class="line"><span class="preprocessor">        #ifdef HAS_MONITORING_MODULE</span></div>
<div class="line">        monitoring_module::report_error(<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.type(), <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.message());</div>
<div class="line"><span class="preprocessor">        #endif</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage example</span></div>
<div class="line"><span class="keywordtype">void</span> setup_thread_pool_with_monitoring() {</div>
<div class="line">    <span class="keyword">auto</span> pool = std::make_shared&lt;thread_pool_module::thread_pool&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Set up custom error handler with monitoring callback</span></div>
<div class="line">    <span class="keyword">auto</span> error_handler = std::make_unique&lt;CustomErrorHandler&gt;(</div>
<div class="line">        [](<span class="keyword">const</span> std::string&amp; error) {</div>
<div class="line">            <span class="comment">// Send to external monitoring service</span></div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Monitoring alert: &quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Configure pool with custom error handler</span></div>
<div class="line">    <span class="comment">// pool-&gt;set_error_handler(std::move(error_handler));</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassthread__module_1_1error__handler_html"><div class="ttname"><a href="../../dd/d11/classthread__module_1_1error__handler.html">thread_module::error_handler</a></div><div class="ttdoc">Error handler interface.</div><div class="ttdef"><b>Definition</b> <a href="../../d5/db4/modular__structure_2core_2include_2thread__system__core_2interfaces_2error__handler_8h_source.html#l00041">error_handler.h:41</a></div></div>
<div class="ttc" id="aclassthread__module_1_1error__handler_html_ab81b999f44040678850d75650599b407"><div class="ttname"><a href="../../dd/d11/classthread__module_1_1error__handler.html#ab81b999f44040678850d75650599b407">thread_module::error_handler::handle_error</a></div><div class="ttdeci">virtual void handle_error(const std::string &amp;context, const std::string &amp;error)=0</div><div class="ttdoc">Handle an error.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md941"></a>
Building with Optional Modules</h2>
<p>When building your application, you can conditionally include optional modules:</p>
<div class="fragment"><div class="line"># CMakeLists.txt</div>
<div class="line">cmake_minimum_required(VERSION 3.16)</div>
<div class="line">project(MyApplication)</div>
<div class="line"> </div>
<div class="line"># Core thread system</div>
<div class="line">find_package(ThreadSystem REQUIRED)</div>
<div class="line"> </div>
<div class="line"># Optional modules</div>
<div class="line">find_package(LoggerModule QUIET)</div>
<div class="line">find_package(MonitoringModule QUIET)</div>
<div class="line"> </div>
<div class="line">add_executable(my_app main.cpp)</div>
<div class="line">target_link_libraries(my_app PRIVATE ThreadSystem::thread_system)</div>
<div class="line"> </div>
<div class="line"># Conditionally link optional modules</div>
<div class="line">if(LoggerModule_FOUND)</div>
<div class="line">    target_compile_definitions(my_app PRIVATE HAS_LOGGER_MODULE)</div>
<div class="line">    target_link_libraries(my_app PRIVATE LoggerModule::logger)</div>
<div class="line">endif()</div>
<div class="line"> </div>
<div class="line">if(MonitoringModule_FOUND)</div>
<div class="line">    target_compile_definitions(my_app PRIVATE HAS_MONITORING_MODULE)</div>
<div class="line">    target_link_libraries(my_app PRIVATE MonitoringModule::monitoring)</div>
<div class="line">endif()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md942"></a>
Compilation Instructions</h2>
<p>For basic examples without optional modules: </p><div class="fragment"><div class="line"># Linux/macOS</div>
<div class="line">g++ -std=c++20 -I/path/to/thread_system/include example.cpp -lthread_system -pthread</div>
<div class="line"> </div>
<div class="line"># Windows (MSVC)</div>
<div class="line">cl /std:c++20 /I&quot;path\to\thread_system\include&quot; example.cpp thread_system.lib</div>
</div><!-- fragment --><p>For examples with optional modules: </p><div class="fragment"><div class="line"># With logger module</div>
<div class="line">g++ -std=c++20 -DHAS_LOGGER_MODULE \</div>
<div class="line">    -I/path/to/thread_system/include \</div>
<div class="line">    -I/path/to/logger_module/include \</div>
<div class="line">    example.cpp -lthread_system -llogger -pthread</div>
<div class="line"> </div>
<div class="line"># With both logger and monitoring</div>
<div class="line">g++ -std=c++20 -DHAS_LOGGER_MODULE -DHAS_MONITORING_MODULE \</div>
<div class="line">    -I/path/to/thread_system/include \</div>
<div class="line">    -I/path/to/logger_module/include \</div>
<div class="line">    -I/path/to/monitoring_module/include \</div>
<div class="line">    example.cpp -lthread_system -llogger -lmonitoring -pthread</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
