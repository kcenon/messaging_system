<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: kcenon::thread::thread_base Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('de/da3/classkcenon_1_1thread_1_1thread__base.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="../../de/d0b/classkcenon_1_1thread_1_1thread__base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">kcenon::thread::thread_base Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A foundational class for implementing custom worker threads.  
 <a href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for kcenon::thread::thread_base:</div>
<div class="dyncontent">
<div class="center"><img src="../../dc/dcc/classkcenon_1_1thread_1_1thread__base__inherit__graph.png" border="0" usemap="#akcenon_1_1thread_1_1thread__base_inherit__map" alt="Inheritance graph"/></div>
<map name="akcenon_1_1thread_1_1thread__base_inherit__map" id="akcenon_1_1thread_1_1thread__base_inherit__map">
<area shape="rect" title="A foundational class for implementing custom worker threads." alt="" coords="5,26,212,51"/>
<area shape="rect" href="../../d8/d8e/classkcenon_1_1thread_1_1typed__thread__worker__t.html" title=" " alt="" coords="585,50,755,104"/>
<area shape="poly" title=" " alt="" coords="155,19,195,9,237,5,339,3,384,4,440,10,518,26,590,47,589,52,517,31,440,15,383,9,339,8,237,10,196,14,157,24"/>
<area shape="rect" href="../../dc/de0/classWakeIntervalTestWorker.html" title=" " alt="" coords="261,26,440,51"/>
<area shape="poly" title=" " alt="" coords="226,45,261,44,261,50,226,50"/>
<area shape="poly" title=" " alt="" coords="226,27,261,27,261,32,226,32"/>
<area shape="rect" href="../../d9/d4f/classkcenon_1_1thread_1_1thread__worker.html" title="A specialized worker thread that processes jobs from a job_queue." alt="" coords="266,76,435,116"/>
<area shape="poly" title=" " alt="" coords="177,51,266,73,265,78,176,57"/>
<area shape="rect" href="../../d8/d8e/classkcenon_1_1thread_1_1typed__thread__worker__t.html" title="A template&#45;based worker thread class that processes jobs from a priority job queue." alt="" coords="266,140,435,195"/>
<area shape="poly" title=" " alt="" coords="143,56,263,125,288,138,286,143,260,130,140,61"/>
<area shape="poly" title=" " alt="" coords="448,137,584,98,586,103,450,142"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6f250c2483b08b7a28c42daa2e998fbf" id="r_a6f250c2483b08b7a28c42daa2e998fbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a6f250c2483b08b7a28c42daa2e998fbf">thread_base</a> (const <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;)=delete</td></tr>
<tr class="separator:a6f250c2483b08b7a28c42daa2e998fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c758a1b4aefde179e857faae3484a3" id="r_a29c758a1b4aefde179e857faae3484a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a29c758a1b4aefde179e857faae3484a3">operator=</a> (const <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;)=delete</td></tr>
<tr class="separator:a29c758a1b4aefde179e857faae3484a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fbe069c7d9a683bb3e4b93352b3d0d" id="r_a06fbe069c7d9a683bb3e4b93352b3d0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a06fbe069c7d9a683bb3e4b93352b3d0d">thread_base</a> (<a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a06fbe069c7d9a683bb3e4b93352b3d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059611438f73b3172fe1f806fbcb2294" id="r_a059611438f73b3172fe1f806fbcb2294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a059611438f73b3172fe1f806fbcb2294">operator=</a> (<a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a059611438f73b3172fe1f806fbcb2294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae39dd9d12a5d5607a3b1544dd73477" id="r_a1ae39dd9d12a5d5607a3b1544dd73477"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a1ae39dd9d12a5d5607a3b1544dd73477">thread_base</a> (const std::string &amp;thread_title=&quot;thread_base&quot;)</td></tr>
<tr class="memdesc:a1ae39dd9d12a5d5607a3b1544dd73477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> object.  <br /></td></tr>
<tr class="separator:a1ae39dd9d12a5d5607a3b1544dd73477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10681eff3a1153fdab4708baef0208a5" id="r_a10681eff3a1153fdab4708baef0208a5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a10681eff3a1153fdab4708baef0208a5">~thread_base</a> (void)</td></tr>
<tr class="memdesc:a10681eff3a1153fdab4708baef0208a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <br /></td></tr>
<tr class="separator:a10681eff3a1153fdab4708baef0208a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987cd56062fd8790f091bd0342d969fe" id="r_a987cd56062fd8790f091bd0342d969fe"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a987cd56062fd8790f091bd0342d969fe">set_wake_interval</a> (const std::optional&lt; std::chrono::milliseconds &gt; &amp;wake_interval) -&gt; void</td></tr>
<tr class="memdesc:a987cd56062fd8790f091bd0342d969fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the interval at which the worker thread should wake up (if any).  <br /></td></tr>
<tr class="separator:a987cd56062fd8790f091bd0342d969fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44f0039df3051450c843276b2b16c72" id="r_ab44f0039df3051450c843276b2b16c72"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#ab44f0039df3051450c843276b2b16c72">get_wake_interval</a> () const -&gt; std::optional&lt; std::chrono::milliseconds &gt;</td></tr>
<tr class="memdesc:ab44f0039df3051450c843276b2b16c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current wake interval setting.  <br /></td></tr>
<tr class="separator:ab44f0039df3051450c843276b2b16c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4987f7a96c19a4edbd76693fe34063f4" id="r_a4987f7a96c19a4edbd76693fe34063f4"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a4987f7a96c19a4edbd76693fe34063f4">start</a> (void) -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:a4987f7a96c19a4edbd76693fe34063f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the worker thread.  <br /></td></tr>
<tr class="separator:a4987f7a96c19a4edbd76693fe34063f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd8251959e0b4c91090b767c63f0eda" id="r_affd8251959e0b4c91090b767c63f0eda"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#affd8251959e0b4c91090b767c63f0eda">stop</a> (void) -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:affd8251959e0b4c91090b767c63f0eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the worker thread to stop and waits for it to finish.  <br /></td></tr>
<tr class="separator:affd8251959e0b4c91090b767c63f0eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239d2e29ef8a96056c3b2388459d053c" id="r_a239d2e29ef8a96056c3b2388459d053c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a239d2e29ef8a96056c3b2388459d053c">get_thread_title</a> () const -&gt; std::string</td></tr>
<tr class="memdesc:a239d2e29ef8a96056c3b2388459d053c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the worker thread's title.  <br /></td></tr>
<tr class="separator:a239d2e29ef8a96056c3b2388459d053c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94303816780f27ea8ca8f86a177cf896" id="r_a94303816780f27ea8ca8f86a177cf896"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a94303816780f27ea8ca8f86a177cf896">is_running</a> () const -&gt; bool</td></tr>
<tr class="memdesc:a94303816780f27ea8ca8f86a177cf896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the worker thread is currently running.  <br /></td></tr>
<tr class="separator:a94303816780f27ea8ca8f86a177cf896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1130c1076dfd5fec14bb0453ff0dbc9e" id="r_a1130c1076dfd5fec14bb0453ff0dbc9e"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a1130c1076dfd5fec14bb0453ff0dbc9e">to_string</a> (void) const -&gt; std::string</td></tr>
<tr class="memdesc:a1130c1076dfd5fec14bb0453ff0dbc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of this <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> object.  <br /></td></tr>
<tr class="separator:a1130c1076dfd5fec14bb0453ff0dbc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:accf440e8d179e5475c64c2e43028ca9d" id="r_accf440e8d179e5475c64c2e43028ca9d"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#accf440e8d179e5475c64c2e43028ca9d">should_continue_work</a> (void) const -&gt; bool</td></tr>
<tr class="memdesc:accf440e8d179e5475c64c2e43028ca9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the thread should continue doing work.  <br /></td></tr>
<tr class="separator:accf440e8d179e5475c64c2e43028ca9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24456c4c3522d010a5eca96f3702d2e8" id="r_a24456c4c3522d010a5eca96f3702d2e8"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a24456c4c3522d010a5eca96f3702d2e8">before_start</a> (void) -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:a24456c4c3522d010a5eca96f3702d2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called just before the worker thread starts running.  <br /></td></tr>
<tr class="separator:a24456c4c3522d010a5eca96f3702d2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71242830321c59a5df8440741dc094b2" id="r_a71242830321c59a5df8440741dc094b2"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a71242830321c59a5df8440741dc094b2">do_work</a> (void) -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:a71242830321c59a5df8440741dc094b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main work routine for the worker thread.  <br /></td></tr>
<tr class="separator:a71242830321c59a5df8440741dc094b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456d21758ca384572aa9683db8312843" id="r_a456d21758ca384572aa9683db8312843"><td class="memItemLeft" align="right" valign="top">virtual auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a456d21758ca384572aa9683db8312843">after_stop</a> (void) -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a></td></tr>
<tr class="memdesc:a456d21758ca384572aa9683db8312843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called immediately after the worker thread has stopped.  <br /></td></tr>
<tr class="separator:a456d21758ca384572aa9683db8312843"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9811f3e84955954a29d3e1606c183b01" id="r_a9811f3e84955954a29d3e1606c183b01"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::chrono::milliseconds &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a9811f3e84955954a29d3e1606c183b01">wake_interval_</a></td></tr>
<tr class="memdesc:a9811f3e84955954a29d3e1606c183b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval at which the thread is optionally awakened.  <br /></td></tr>
<tr class="separator:a9811f3e84955954a29d3e1606c183b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A foundational class for implementing custom worker threads. </p>
<p>The <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> class provides a framework for managing a single worker thread, offering lifecycle methods (start, stop), optional wake intervals, and hooks (<code>before_start</code>, <code>do_work</code>, <code>after_stop</code>) for derived classes to customize behavior.</p>
<p>This class abstracts platform-specific thread management details and provides a unified interface for both C++20 <code>std::jthread</code> and traditional <code>std::thread</code>, selected at compile time via the <code>USE_STD_JTHREAD</code> macro.</p>
<h3><a class="anchor" id="autotoc_md3363"></a>
Key Features</h3>
<ul>
<li>Standardized thread lifecycle management (start/stop)</li>
<li>Thread condition monitoring</li>
<li>Customizable worker behavior through virtual method overrides</li>
<li>Optional periodic wake intervals for recurring tasks</li>
<li>Built-in cancellation support (via <code>std::jthread</code> or custom mechanism)</li>
<li>Thread-safe signaling and state management</li>
</ul>
<h3><a class="anchor" id="autotoc_md3364"></a>
Thread Safety</h3>
<p>All public methods in <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> are thread-safe. The class uses internal synchronization mechanisms to protect its state.</p>
<h3><a class="anchor" id="autotoc_md3365"></a>
Typical Usage</h3>
<ol type="1">
<li>Inherit from <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> and override <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a71242830321c59a5df8440741dc094b2" title="The main work routine for the worker thread.">do_work()</a></code>, <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a24456c4c3522d010a5eca96f3702d2e8" title="Called just before the worker thread starts running.">before_start()</a></code>, and/or <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a456d21758ca384572aa9683db8312843" title="Called immediately after the worker thread has stopped.">after_stop()</a></code> as needed.</li>
<li>Instantiate your derived class, set a wake interval if desired, then call <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a4987f7a96c19a4edbd76693fe34063f4" title="Starts the worker thread.">start()</a></code> to launch the thread.</li>
<li>When shutting down or no longer needing the thread's work, call <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#affd8251959e0b4c91090b767c63f0eda" title="Requests the worker thread to stop and waits for it to finish.">stop()</a></code>.</li>
<li>The thread can periodically check <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#accf440e8d179e5475c64c2e43028ca9d" title="Determines whether the thread should continue doing work.">should_continue_work()</a></code> or internal conditions to determine if it should continue running.</li>
</ol>
<h3><a class="anchor" id="autotoc_md3366"></a>
Example</h3>
<div class="fragment"><div class="line"><span class="keyword">class </span>my_worker : <span class="keyword">public</span> <a class="code hl_class" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    my_worker() : <a class="code hl_class" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a>(<span class="stringliteral">&quot;my_worker&quot;</span>) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <a class="code hl_class" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a> before_start()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Initialize resources</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> do_work()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Perform work</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a> after_stop()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Clean up resources</span></div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../db/d5d/basic__usage__example_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keyword">auto</span> worker = std::make_unique&lt;my_worker&gt;();</div>
<div class="line">    worker-&gt;set_wake_interval(std::chrono::milliseconds(100)); <span class="comment">// Wake every 100ms</span></div>
<div class="line">    <span class="keyword">auto</span> result = worker-&gt;start();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Do other work...</span></div>
<div class="line">    </div>
<div class="line">    worker-&gt;stop();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="abasic__usage__example_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="../../db/d5d/basic__usage__example_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition</b> <a href="../../db/d5d/basic__usage__example_8cpp_source.html#l00015">basic_usage_example.cpp:15</a></div></div>
<div class="ttc" id="abenchmarks_2thread__pool__benchmarks_2benchmark__common_8h_html_a13fa946184c58584adc65e45561d6772"><div class="ttname"><a href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h.html#a13fa946184c58584adc65e45561d6772">result_void</a></div><div class="ttdeci">thread_module::result_void result_void</div><div class="ttdef"><b>Definition</b> <a href="../../df/dad/benchmarks_2thread__pool__benchmarks_2benchmark__common_8h_source.html#l00012">benchmark_common.h:12</a></div></div>
<div class="ttc" id="aclasskcenon_1_1thread_1_1result__void_html"><div class="ttname"><a href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">kcenon::thread::result_void</a></div><div class="ttdoc">Wrapper for void result.</div><div class="ttdef"><b>Definition</b> <a href="../../de/d9a/core_2sync_2include_2error__handling_8h_source.html#l00194">error_handling.h:194</a></div></div>
<div class="ttc" id="aclasskcenon_1_1thread_1_1thread__base_html"><div class="ttname"><a href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">kcenon::thread::thread_base</a></div><div class="ttdoc">A foundational class for implementing custom worker threads.</div><div class="ttdef"><b>Definition</b> <a href="../../df/dbc/thread__base_8h_source.html#l00150">thread_base.h:151</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/df7/classkcenon_1_1thread_1_1job.html" title="Represents a unit of work (task) to be executed, typically by a job queue.">kcenon::thread::job</a> For the work unit class processed by workers </dd>
<dd>
<a class="el" href="../../d9/da2/classkcenon_1_1thread_1_1job__queue.html" title="A thread-safe job queue for managing and dispatching work items.">kcenon::thread::job_queue</a> For the thread-safe queue used with workers </dd>
<dd>
<a class="el" href="../../d9/d4f/classkcenon_1_1thread_1_1thread__worker.html" title="A specialized worker thread that processes jobs from a job_queue.">kcenon::thread::thread_worker</a> For a specialized worker implementation </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00150">150</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f250c2483b08b7a28c42daa2e998fbf" name="a6f250c2483b08b7a28c42daa2e998fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f250c2483b08b7a28c42daa2e998fbf">&#9670;&#160;</a></span>thread_base() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kcenon::thread::thread_base::thread_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06fbe069c7d9a683bb3e4b93352b3d0d" name="a06fbe069c7d9a683bb3e4b93352b3d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fbe069c7d9a683bb3e4b93352b3d0d">&#9670;&#160;</a></span>thread_base() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kcenon::thread::thread_base::thread_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ae39dd9d12a5d5607a3b1544dd73477" name="a1ae39dd9d12a5d5607a3b1544dd73477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae39dd9d12a5d5607a3b1544dd73477">&#9670;&#160;</a></span>thread_base() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kcenon::thread::thread_base::thread_base </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>thread_title</em> = <code>&quot;thread_base&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> object. </p>
<p>Constructs a new <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a> instance with the specified title.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_title</td><td>A human-readable title for this worker thread (default: "thread_base").</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>thread_title</code> can be useful for logging, debugging, or thread naming (where the platform supports it).</p>
<p>Implementation details:</p><ul>
<li>Initializes the worker_thread_ pointer to nullptr (thread not started)</li>
<li>Sets up thread control mechanisms based on configuration:<ul>
<li>In C++20 mode (USE_STD_JTHREAD), initializes stop_source_ to std::nullopt</li>
<li>In legacy mode, initializes stop_requested_ to false</li>
</ul>
</li>
<li>Sets wake_interval_ to std::nullopt (no periodic wake-ups by default)</li>
<li>Sets thread_title_ to the provided title</li>
<li>Sets initial thread_condition_ to Created </li>
</ul>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00057">57</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>

</div>
</div>
<a id="a10681eff3a1153fdab4708baef0208a5" name="a10681eff3a1153fdab4708baef0208a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10681eff3a1153fdab4708baef0208a5">&#9670;&#160;</a></span>~thread_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">kcenon::thread::thread_base::~thread_base </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>
<p>Destroys the <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a> instance, stopping the thread if needed.</p>
<p>Ensures proper cleanup of derived classes.</p>
<p>If the thread is still running when the destructor is called, <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#affd8251959e0b4c91090b767c63f0eda" title="Requests the worker thread to stop and waits for it to finish.">stop()</a></code> is typically called internally to join the thread before destruction.</p>
<p>Implementation details:</p><ul>
<li>Calls <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#affd8251959e0b4c91090b767c63f0eda" title="Requests the worker thread to stop and waits for it to finish.">stop()</a> to ensure the thread is properly terminated</li>
<li>The <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#affd8251959e0b4c91090b767c63f0eda" title="Requests the worker thread to stop and waits for it to finish.">stop()</a> method handles joining the thread and cleaning up resources</li>
<li>This ensures no thread resources are leaked when the object is destroyed</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This destructor is virtual, allowing derived classes to perform their own cleanup operations in their destructors. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00081">81</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00333">stop()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a456d21758ca384572aa9683db8312843" name="a456d21758ca384572aa9683db8312843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456d21758ca384572aa9683db8312843">&#9670;&#160;</a></span>after_stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto kcenon::thread::thread_base::after_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called immediately after the worker thread has stopped. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Override this method in derived classes to perform any cleanup or finalization tasks once the worker thread has fully exited. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00281">281</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="a24456c4c3522d010a5eca96f3702d2e8" name="a24456c4c3522d010a5eca96f3702d2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24456c4c3522d010a5eca96f3702d2e8">&#9670;&#160;</a></span>before_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto kcenon::thread::thread_base::before_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called just before the worker thread starts running. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Override this method in derived classes to perform any initialization or setup required before the worker thread begins its main loop. </p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00262">262</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="a71242830321c59a5df8440741dc094b2" name="a71242830321c59a5df8440741dc094b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71242830321c59a5df8440741dc094b2">&#9670;&#160;</a></span>do_work()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto kcenon::thread::thread_base::do_work </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main work routine for the worker thread. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Derived classes should override this method to implement the actual work the thread needs to perform. This method is called repeatedly (in an internal loop) until the thread is signaled to stop or <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#accf440e8d179e5475c64c2e43028ca9d" title="Determines whether the thread should continue doing work.">should_continue_work()</a></code> returns <code>false</code>. </p>

<p>Reimplemented in <a class="el" href="../../dc/de0/classWakeIntervalTestWorker.html#a813f05761aca9a643da62ab2c0467c09">WakeIntervalTestWorker</a>, <a class="el" href="../../d9/d4f/classkcenon_1_1thread_1_1thread__worker.html#a27017e8c7397152405c9738b49b2e104">kcenon::thread::thread_worker</a>, <a class="el" href="../../d8/d8e/classkcenon_1_1thread_1_1typed__thread__worker__t.html#a4929d64335dd2c8a9fdf15e04c6ce6d9">kcenon::thread::typed_thread_worker_t&lt; job_type &gt;</a>, <a class="el" href="../../d8/d8e/classkcenon_1_1thread_1_1typed__thread__worker__t.html#a4929d64335dd2c8a9fdf15e04c6ce6d9">kcenon::thread::typed_thread_worker_t&lt; job_types &gt;</a>, and <a class="el" href="../../dc/de0/classWakeIntervalTestWorker.html#a813f05761aca9a643da62ab2c0467c09">WakeIntervalTestWorker</a>.</p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00272">272</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/d50/tests_2unit_2thread__base__test_2thread__base__test_8cpp_source.html#l00219">TEST_F()</a>.</p>

</div>
</div>
<a id="a239d2e29ef8a96056c3b2388459d053c" name="a239d2e29ef8a96056c3b2388459d053c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239d2e29ef8a96056c3b2388459d053c">&#9670;&#160;</a></span>get_thread_title()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto kcenon::thread::thread_base::get_thread_title </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::string </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the worker thread's title. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representing the thread's title. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00224">224</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

</div>
</div>
<a id="ab44f0039df3051450c843276b2b16c72" name="ab44f0039df3051450c843276b2b16c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44f0039df3051450c843276b2b16c72">&#9670;&#160;</a></span>get_wake_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto kcenon::thread::thread_base::get_wake_interval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::optional&lt;std::chrono::milliseconds&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current wake interval setting. </p>
<dl class="section return"><dt>Returns</dt><dd>The wake interval if set, or <code>std::nullopt</code> if periodic wake-ups are disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe.</dd></dl>
<p>Implementation details:</p><ul>
<li>Uses the same mutex as <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a987cd56062fd8790f091bd0342d969fe" title="Sets the interval at which the worker thread should wake up (if any).">set_wake_interval()</a> for consistency</li>
<li>Returns a copy of the current wake_interval_ value</li>
<li>std::nullopt indicates no periodic wake-ups are configured</li>
</ul>
<p>Thread Safety:</p><ul>
<li>Safe to call from any thread concurrently with <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a987cd56062fd8790f091bd0342d969fe" title="Sets the interval at which the worker thread should wake up (if any).">set_wake_interval()</a></li>
<li>The mutex ensures consistent reads even during concurrent modifications</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Current wake interval or std::nullopt if disabled </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00118">118</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00292">wake_interval_</a>.</p>

</div>
</div>
<a id="a94303816780f27ea8ca8f86a177cf896" name="a94303816780f27ea8ca8f86a177cf896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94303816780f27ea8ca8f86a177cf896">&#9670;&#160;</a></span>is_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto kcenon::thread::thread_base::is_running </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the worker thread is currently running. </p>
<p>Checks if the worker thread is currently active.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the thread is running, <code>false</code> otherwise.</dd></dl>
<p>This depends on the thread's internal condition state (e.g., <code>thread_conditions::running</code>).</p>
<p>Implementation details:</p><ul>
<li>Uses the atomic thread_condition_ member instead of checking thread pointers</li>
<li>This is more reliable as it reflects the actual thread state</li>
<li>Considers both Working and Waiting states as "running"</li>
<li>Thread-safe operation due to atomic load</li>
</ul>
<p>Thread States Considered "Running":</p><ul>
<li>Working: Thread is actively executing <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a71242830321c59a5df8440741dc094b2" title="The main work routine for the worker thread.">do_work()</a></li>
<li>Waiting: Thread is alive but waiting for work or timeout</li>
</ul>
<p>Thread States NOT Considered "Running":</p><ul>
<li>Created: Thread object created but not started</li>
<li>Stopping: Thread is in shutdown sequence</li>
<li>Stopped: Thread has completely finished</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if thread is actively running (Working or Waiting) </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00396">396</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a34151d8fa0dfc3565fdfc98b6d397367a5706de961fb376d701be6e7762d8b09c">kcenon::thread::Waiting</a>, and <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a34151d8fa0dfc3565fdfc98b6d397367a829eadc8e29caab50cc26bc6a451a1f1">kcenon::thread::Working</a>.</p>

</div>
</div>
<a id="a29c758a1b4aefde179e857faae3484a3" name="a29c758a1b4aefde179e857faae3484a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c758a1b4aefde179e857faae3484a3">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp; kcenon::thread::thread_base::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a059611438f73b3172fe1f806fbcb2294" name="a059611438f73b3172fe1f806fbcb2294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059611438f73b3172fe1f806fbcb2294">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp; kcenon::thread::thread_base::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a987cd56062fd8790f091bd0342d969fe" name="a987cd56062fd8790f091bd0342d969fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987cd56062fd8790f091bd0342d969fe">&#9670;&#160;</a></span>set_wake_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto kcenon::thread::thread_base::set_wake_interval </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; std::chrono::milliseconds &gt; &amp;&#160;</td>
          <td class="paramname"><em>wake_interval</em></td><td>)</td>
          <td> -&gt; void</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the interval at which the worker thread should wake up (if any). </p>
<p>Sets the wake interval for periodic thread wake-ups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wake_interval</td><td>Duration in milliseconds for periodic wake-ups, or <code>std::nullopt</code> to disable periodic wake-ups.</td></tr>
  </table>
  </dd>
</dl>
<p>If a wake interval is set, the worker thread can periodically perform some action (e.g., housekeeping tasks) even if there's no immediate external signal.</p>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe.</dd></dl>
<p>Implementation details:</p><ul>
<li>Uses a dedicated mutex (wake_interval_mutex_) to ensure thread-safe access</li>
<li>The scoped_lock ensures automatic release when the function exits</li>
<li>This interval controls how often the thread wakes up even when idle</li>
<li>Setting std::nullopt disables periodic wake-ups (thread only wakes on signals)</li>
</ul>
<p>Thread Safety:</p><ul>
<li>Safe to call from any thread while the worker thread is running</li>
<li>The wake_interval_mutex_ protects against data races with <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#ab44f0039df3051450c843276b2b16c72" title="Gets the current wake interval setting.">get_wake_interval()</a> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00096">96</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>

</div>
</div>
<a id="accf440e8d179e5475c64c2e43028ca9d" name="accf440e8d179e5475c64c2e43028ca9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf440e8d179e5475c64c2e43028ca9d">&#9670;&#160;</a></span>should_continue_work()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual auto kcenon::thread::thread_base::should_continue_work </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the thread should continue doing work. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there is work to do, <code>false</code> otherwise.</dd></dl>
<p>The default implementation always returns <code>false</code> (indicating no ongoing work). Override this in derived classes if you wish the thread to perform repeated tasks until some condition changes. </p>

<p>Reimplemented in <a class="el" href="../../dc/de0/classWakeIntervalTestWorker.html#a999324a654643ef465157e6d2bd8031b">WakeIntervalTestWorker</a>, <a class="el" href="../../d9/d4f/classkcenon_1_1thread_1_1thread__worker.html#a6ec89a61b058a4c489bab962703076af">kcenon::thread::thread_worker</a>, <a class="el" href="../../d8/d8e/classkcenon_1_1thread_1_1typed__thread__worker__t.html#a578b934b3eae04fedc3c128d1dea7f38">kcenon::thread::typed_thread_worker_t&lt; job_type &gt;</a>, <a class="el" href="../../d8/d8e/classkcenon_1_1thread_1_1typed__thread__worker__t.html#a578b934b3eae04fedc3c128d1dea7f38">kcenon::thread::typed_thread_worker_t&lt; job_types &gt;</a>, and <a class="el" href="../../dc/de0/classWakeIntervalTestWorker.html#a999324a654643ef465157e6d2bd8031b">WakeIntervalTestWorker</a>.</p>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00253">253</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/d50/tests_2unit_2thread__base__test_2thread__base__test_8cpp_source.html#l00219">TEST_F()</a>.</p>

</div>
</div>
<a id="a4987f7a96c19a4edbd76693fe34063f4" name="a4987f7a96c19a4edbd76693fe34063f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4987f7a96c19a4edbd76693fe34063f4">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto kcenon::thread::thread_base::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the worker thread. </p>
<p>Starts the worker thread and begins execution loop.</p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Internally, this method:</p><ol type="1">
<li>Calls <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a24456c4c3522d010a5eca96f3702d2e8" title="Called just before the worker thread starts running.">before_start()</a></code> to allow derived classes to perform setup.</li>
<li>Spawns a new thread (using either <code>std::jthread</code> or <code>std::thread</code>).</li>
<li>Repeatedly calls <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a71242830321c59a5df8440741dc094b2" title="The main work routine for the worker thread.">do_work()</a></code> until the thread is signaled to stop.</li>
</ol>
<p>Implementation details:</p><ul>
<li>First checks if thread is already running using different methods:<ul>
<li>C++20: stop_source_.has_value() indicates active thread</li>
<li>Legacy: worker_thread_-&gt;joinable() indicates active thread</li>
</ul>
</li>
<li>Calls <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#affd8251959e0b4c91090b767c63f0eda" title="Requests the worker thread to stop and waits for it to finish.">stop()</a> first to ensure clean state (idempotent operation)</li>
<li>Initializes stop control mechanism:<ul>
<li>C++20: Creates new std::stop_source for cooperative cancellation</li>
<li>Legacy: Resets atomic stop_requested_ flag to false</li>
</ul>
</li>
<li>Creates worker thread that executes the main work loop</li>
</ul>
<p>Main Work Loop Logic:</p><ol type="1">
<li>Calls <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a24456c4c3522d010a5eca96f3702d2e8" title="Called just before the worker thread starts running.">before_start()</a> hook for derived class initialization</li>
<li>Enters main loop while not stopped and has work to do</li>
<li>Sets thread_condition_ to Waiting before sleep</li>
<li>Waits on condition variable with optional timeout (wake_interval)</li>
<li>Sets thread_condition_ to Working before calling <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a71242830321c59a5df8440741dc094b2" title="The main work routine for the worker thread.">do_work()</a></li>
<li>Calls <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a71242830321c59a5df8440741dc094b2" title="The main work routine for the worker thread.">do_work()</a> hook for actual work execution</li>
<li>Handles exceptions from <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a71242830321c59a5df8440741dc094b2" title="The main work routine for the worker thread.">do_work()</a> gracefully</li>
<li>Calls <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a456d21758ca384572aa9683db8312843" title="Called immediately after the worker thread has stopped.">after_stop()</a> hook for cleanup when exiting</li>
</ol>
<p>Error Handling:</p><ul>
<li>Returns error if thread is already running</li>
<li>Catches std::bad_alloc during thread creation</li>
<li>Logs errors from hooks using std::cerr</li>
<li>Exception-safe cleanup in catch blocks</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Empty result on success, error on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00157">157</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a20e1d8b59344b87a5dc3a46603607a23acde679dc006944a4dcc197c13cf731e5">kcenon::thread::resource_allocation_failed</a>, <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a34151d8fa0dfc3565fdfc98b6d397367a7b7ecb39b9e110c2a31409a1672bad23">kcenon::thread::Stopping</a>, <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a20e1d8b59344b87a5dc3a46603607a23ae6fac5620122dc140bbc13a44aeac670">kcenon::thread::thread_already_running</a>, <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a34151d8fa0dfc3565fdfc98b6d397367a5706de961fb376d701be6e7762d8b09c">kcenon::thread::Waiting</a>, and <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a34151d8fa0dfc3565fdfc98b6d397367a829eadc8e29caab50cc26bc6a451a1f1">kcenon::thread::Working</a>.</p>

</div>
</div>
<a id="affd8251959e0b4c91090b767c63f0eda" name="affd8251959e0b4c91090b767c63f0eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd8251959e0b4c91090b767c63f0eda">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto kcenon::thread::thread_base::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; <a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html">result_void</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the worker thread to stop and waits for it to finish. </p>
<p>Stops the worker thread and waits for it to complete.</p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="../../de/dff/classkcenon_1_1thread_1_1result__void.html" title="Wrapper for void result.">result_void</a></code> containing an error on failure, or success value if successful.</dd></dl>
<p>Internally, this method:</p><ol type="1">
<li>Signals the thread to stop (via <code>stop_source_</code> or <code>stop_requested_</code>).</li>
<li>Joins the thread, ensuring it has fully exited.</li>
<li>Calls <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a456d21758ca384572aa9683db8312843" title="Called immediately after the worker thread has stopped.">after_stop()</a></code> for post-shutdown cleanup in derived classes.</li>
</ol>
<p>Implementation details:</p><ul>
<li>This method is idempotent - safe to call multiple times</li>
<li>First checks if there's actually a thread to stop</li>
<li>Uses platform-specific stop signaling:<ul>
<li>C++20: Uses std::stop_source for cooperative cancellation</li>
<li>Legacy: Sets atomic flag stop_requested_ to true</li>
</ul>
</li>
<li>Notifies condition variable to wake up waiting thread</li>
<li>Joins the thread to wait for complete shutdown</li>
<li>Cleans up all thread-related resources</li>
</ul>
<p>Shutdown Sequence:</p><ol type="1">
<li>Signal stop request using appropriate mechanism</li>
<li>Notify condition variable to wake sleeping thread</li>
<li>Wait for thread to exit its main loop and complete <a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html#a456d21758ca384572aa9683db8312843" title="Called immediately after the worker thread has stopped.">after_stop()</a></li>
<li>Clean up thread object and stop control mechanism</li>
<li>Update thread_condition_ to Stopped state</li>
</ol>
<p>Thread Safety:</p><ul>
<li>Safe to call from any thread including the worker thread itself</li>
<li>Uses proper synchronization to avoid race conditions</li>
<li>join() ensures thread resources are properly released</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Empty result on success, error if thread wasn't running </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00333">333</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a34151d8fa0dfc3565fdfc98b6d397367ac23e2b09ebe6bf4cb5e2a9abe85c0be2">kcenon::thread::Stopped</a>, and <a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html#a20e1d8b59344b87a5dc3a46603607a23af2be7360c604a961b720a704f214b53c">kcenon::thread::thread_not_running</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00081">~thread_base()</a>.</p>

</div>
</div>
<a id="a1130c1076dfd5fec14bb0453ff0dbc9e" name="a1130c1076dfd5fec14bb0453ff0dbc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1130c1076dfd5fec14bb0453ff0dbc9e">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto kcenon::thread::thread_base::to_string </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; std::string</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string representation of this <code><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html" title="A foundational class for implementing custom worker threads.">thread_base</a></code> object. </p>
<p>Provides a string representation of the thread's current state.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing descriptive or diagnostic information about the thread.</dd></dl>
<p>Derived classes may override this to include additional details (e.g., current status, counters, or other state).</p>
<p>Implementation details:</p><ul>
<li>Uses the formatter utility to create consistent output format</li>
<li>Includes both thread title and current condition</li>
<li>Useful for logging and debugging purposes</li>
<li>Thread-safe due to atomic load of thread_condition_</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Formatted string showing thread title and current state </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00415">415</a> of file <a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a>.</p>

<p class="reference">References <a class="el" href="../../dd/da9/thread__system_2utilities_2include_2formatter_8h_source.html#l00176">kcenon::thread::utils::formatter::format()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d9/de2/thread__worker_8h_source.html#l00264">fmt::formatter&lt; kcenon::thread::thread_worker &gt;::format()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9811f3e84955954a29d3e1606c183b01" name="a9811f3e84955954a29d3e1606c183b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9811f3e84955954a29d3e1606c183b01">&#9670;&#160;</a></span>wake_interval_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;std::chrono::milliseconds&gt; kcenon::thread::thread_base::wake_interval_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interval at which the thread is optionally awakened. </p>
<p>If set, the worker thread can wake periodically (in addition to any other wake conditions) to perform tasks at regular intervals.</p>
<dl class="section note"><dt>Note</dt><dd>Access to this member must be synchronized using wake_interval_mutex_ </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/dbc/thread__base_8h_source.html#l00292">292</a> of file <a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../df/d10/thread__base_8cpp_source.html#l00118">get_wake_interval()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libraries/thread_system/include/kcenon/thread/core/<a class="el" href="../../df/dbc/thread__base_8h_source.html">thread_base.h</a></li>
<li>libraries/thread_system/src/core/<a class="el" href="../../df/d10/thread__base_8cpp_source.html">thread_base.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d9/d03/namespacekcenon.html">kcenon</a></li><li class="navelem"><a class="el" href="../../da/dcc/namespacekcenon_1_1thread.html">thread</a></li><li class="navelem"><a class="el" href="../../de/da3/classkcenon_1_1thread_1_1thread__base.html">thread_base</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
