<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: Migration Guide: Transitioning to Thread System</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d9/dae/md_libraries_2thread__system_2docs_2migration__guide.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Migration Guide: Transitioning to Thread System</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1031"></a> This guide provides step-by-step instructions for transitioning existing multithreaded code to use the Thread System library. Whether you're migrating from raw threads, a different threading library, or just improving your existing concurrent code, this document will help you make the transition smoothly.</p>
<h1><a class="anchor" id="autotoc_md1032"></a>
Why Migrate to Thread System?</h1>
<p>Before diving into the migration process, let's review the key benefits of using Thread System:</p>
<ol type="1">
<li><b>Structured concurrency</b>: Clear thread lifecycle management and job-based design</li>
<li><b>Error handling</b>: Consistent error reporting using <code>result_void</code> and optional return types</li>
<li><b>Improved thread safety</b>: Thread-safe patterns and components</li>
<li><b>Type scheduling</b>: Built-in support for type-based execution</li>
<li><b>Logging integration</b>: Thread-safe, asynchronous logging system</li>
<li><b>Modern C++</b>: Leverages C++20 features when available</li>
<li><b>Cross-platform</b>: Works consistently across Windows, Linux, and macOS</li>
</ol>
<h1><a class="anchor" id="autotoc_md1033"></a>
Migration Process Overview</h1>
<p>The migration process typically follows these steps:</p>
<ol type="1">
<li><b>Analysis</b>: Identify threading patterns in your existing code</li>
<li><b>Component selection</b>: Choose appropriate Thread System components</li>
<li><b>Basic refactoring</b>: Replace direct thread usage with Thread System</li>
<li><b>Advanced refactoring</b>: Leverage Thread System features</li>
<li><b>Testing and validation</b>: Verify correctness and performance</li>
</ol>
<p>Let's explore each step in detail with examples.</p>
<h1><a class="anchor" id="autotoc_md1034"></a>
Step 1: Analyze Existing Code</h1>
<p>Before migrating, identify your current threading patterns:</p>
<h2><a class="anchor" id="autotoc_md1035"></a>
Common Threading Patterns</h2>
<h3><a class="anchor" id="autotoc_md1036"></a>
Raw Thread Usage</h3>
<div class="fragment"><div class="line"><span class="comment">// Typical std::thread usage</span></div>
<div class="line">std::thread worker_thread([data]() {</div>
<div class="line">    <span class="comment">// Worker function</span></div>
<div class="line">    process_data(data);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Join later</span></div>
<div class="line">worker_thread.join();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1037"></a>
Thread Pool Pattern</h3>
<div class="fragment"><div class="line"><span class="comment">// Simplified thread pool example</span></div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="../../d2/d1f/classSimpleThreadPool.html">SimpleThreadPool</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <a class="code hl_class" href="../../d2/d1f/classSimpleThreadPool.html">SimpleThreadPool</a>(<span class="keywordtype">size_t</span> <a class="code hl_variable" href="../../df/de0/optimized__storage_8h.html#acbe3ff89760ba4e883cfef7df57f461c">thread_count</a>) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code hl_variable" href="../../df/de0/optimized__storage_8h.html#acbe3ff89760ba4e883cfef7df57f461c">thread_count</a>; ++i) {</div>
<div class="line">            threads_.emplace_back([<span class="keyword">this</span>]() {</div>
<div class="line">                <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">                    std::function&lt;void()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>;</div>
<div class="line">                    {</div>
<div class="line">                        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">                        condition_.wait(lock, [<span class="keyword">this</span>]() { </div>
<div class="line">                            <span class="keywordflow">return</span> stop_ || !tasks_.empty(); </div>
<div class="line">                        });</div>
<div class="line">                        </div>
<div class="line">                        <span class="keywordflow">if</span> (stop_ &amp;&amp; tasks_.empty()) {</div>
<div class="line">                            <span class="keywordflow">return</span>;</div>
<div class="line">                        }</div>
<div class="line">                        </div>
<div class="line">                        <a class="code hl_struct" href="../../db/da2/structtask.html">task</a> = std::move(tasks_.front());</div>
<div class="line">                        tasks_.pop();</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>();</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;</div>
<div class="line">    <span class="keywordtype">void</span> enqueue(F&amp;&amp; f) {</div>
<div class="line">        {</div>
<div class="line">            std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">            tasks_.emplace(std::forward&lt;F&gt;(f));</div>
<div class="line">        }</div>
<div class="line">        condition_.notify_one();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <a class="code hl_function" href="../../d2/d1f/classSimpleThreadPool.html#ac1e1402bfdc946417ca0ce392909b277">~SimpleThreadPool</a>() {</div>
<div class="line">        {</div>
<div class="line">            std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">            stop_ = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        condition_.notify_all();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (std::thread&amp; thread : threads_) {</div>
<div class="line">            thread.join();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::thread&gt; threads_;</div>
<div class="line">    std::queue&lt;std::function&lt;void()&gt;&gt; tasks_;</div>
<div class="line">    std::mutex queue_mutex_;</div>
<div class="line">    std::condition_variable condition_;</div>
<div class="line">    <span class="keywordtype">bool</span> stop_ = <span class="keyword">false</span>;</div>
<div class="line">};</div>
<div class="ttc" id="aclassSimpleThreadPool_html"><div class="ttname"><a href="../../d2/d1f/classSimpleThreadPool.html">SimpleThreadPool</a></div><div class="ttdef"><b>Definition</b> <a href="../../d6/d0d/comparison__benchmark_8cpp_source.html#l00126">comparison_benchmark.cpp:126</a></div></div>
<div class="ttc" id="aclassSimpleThreadPool_html_ac1e1402bfdc946417ca0ce392909b277"><div class="ttname"><a href="../../d2/d1f/classSimpleThreadPool.html#ac1e1402bfdc946417ca0ce392909b277">SimpleThreadPool::~SimpleThreadPool</a></div><div class="ttdeci">~SimpleThreadPool()</div><div class="ttdef"><b>Definition</b> <a href="../../d6/d0d/comparison__benchmark_8cpp_source.html#l00148">comparison_benchmark.cpp:148</a></div></div>
<div class="ttc" id="aoptimized__storage_8h_html_acbe3ff89760ba4e883cfef7df57f461c"><div class="ttname"><a href="../../df/de0/optimized__storage_8h.html#acbe3ff89760ba4e883cfef7df57f461c">thread_count</a></div><div class="ttdeci">std::uint16_t thread_count</div><div class="ttdef"><b>Definition</b> <a href="../../df/de0/optimized__storage_8h_source.html#l00003">optimized_storage.h:3</a></div></div>
<div class="ttc" id="astructtask_html"><div class="ttname"><a href="../../db/da2/structtask.html">task</a></div><div class="ttdef"><b>Definition</b> <a href="../../d4/daa/distributed__worker_8cpp_source.html#l00033">distributed_worker.cpp:33</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1038"></a>
Asynchronous Processing</h3>
<div class="fragment"><div class="line"><span class="comment">// Using std::async</span></div>
<div class="line"><span class="keyword">auto</span> future = std::async(std::launch::async, []() {</div>
<div class="line">    <span class="comment">// Perform operation</span></div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get result later</span></div>
<div class="line"><span class="keyword">auto</span> result = future.get();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1039"></a>
Producer-Consumer Pattern</h3>
<div class="fragment"><div class="line"><span class="comment">// Shared queue</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>ThreadSafeQueue {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> push(T value) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        queue_.push(std::move(value));</div>
<div class="line">        condition_.notify_one();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> try_pop(T&amp; value) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        <span class="keywordflow">if</span> (queue_.empty()) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        value = std::move(queue_.front());</div>
<div class="line">        queue_.pop();</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> wait_and_pop(T&amp; value) {</div>
<div class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</div>
<div class="line">        condition_.wait(lock, [<span class="keyword">this</span>]() { <span class="keywordflow">return</span> !queue_.empty(); });</div>
<div class="line">        value = std::move(queue_.front());</div>
<div class="line">        queue_.pop();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::queue&lt;T&gt; queue_;</div>
<div class="line">    std::mutex mutex_;</div>
<div class="line">    std::condition_variable condition_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line">ThreadSafeQueue&lt;Item&gt; queue;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Producer thread</span></div>
<div class="line">std::thread producer([&amp;queue]() {</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        Item item = produce_item();</div>
<div class="line">        queue.push(std::move(item));</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Consumer thread</span></div>
<div class="line">std::thread consumer([&amp;queue]() {</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        Item item;</div>
<div class="line">        queue.wait_and_pop(item);</div>
<div class="line">        consume_item(item);</div>
<div class="line">    }</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1040"></a>
Step 2: Select Thread System Components</h1>
<p>Based on your existing patterns, select the appropriate Thread System components:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Existing Pattern   </th><th class="markdownTableHeadNone">Thread System Component    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Raw threads   </td><td class="markdownTableBodyNone"><code>thread_base</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread pools   </td><td class="markdownTableBodyNone"><code>thread_pool</code> or <code>typed_thread_pool</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Async processing   </td><td class="markdownTableBodyNone"><code>callback_job</code> with thread pool    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Producer-consumer   </td><td class="markdownTableBodyNone">Job queues with thread pool    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Worker threads   </td><td class="markdownTableBodyNone">Custom <code>thread_base</code> subclass    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread-safe logging   </td><td class="markdownTableBodyNone"><code>log_module</code>   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md1041"></a>
Step 3: Basic Refactoring</h1>
<p>Let's refactor each common pattern to use Thread System:</p>
<h2><a class="anchor" id="autotoc_md1042"></a>
Raw Thread to thread_base</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Raw thread</span></div>
<div class="line">std::thread worker_thread([data]() {</div>
<div class="line">    <span class="comment">// Worker function</span></div>
<div class="line">    process_data(data);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: thread_base</span></div>
<div class="line"><span class="keyword">class </span>DataProcessor : <span class="keyword">public</span> <a class="code hl_class" href="../../da/d94/classthread__module_1_1thread__base.html">thread_module::thread_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataProcessor(<span class="keyword">const</span> Data&amp; data) : data_(data) {}</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5">do_work</a>() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            process_data(data_);</div>
<div class="line">            <span class="keywordflow">return</span> {}; <span class="comment">// Success</span></div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            <span class="keywordflow">return</span> make_error(e.what()); <span class="comment">// Error</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Data data_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> processor = std::make_unique&lt;DataProcessor&gt;(data);</div>
<div class="line"><span class="keyword">auto</span> result = processor-&gt;start();</div>
<div class="line"><span class="keywordflow">if</span> (result.has_value()) {</div>
<div class="line">    <span class="comment">// Handle start error</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later</span></div>
<div class="line">processor-&gt;stop();</div>
<div class="ttc" id="aclassthread__module_1_1result__void_html"><div class="ttname"><a href="../../dd/da2/classthread__module_1_1result__void.html">thread_module::result_void</a></div><div class="ttdoc">Wrapper for void result.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d4e/modular__structure_2core_2include_2thread__system__core_2thread__base_2sync_2error__handling_8h_source.html#l00197">error_handling.h:197</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html">thread_module::thread_base</a></div><div class="ttdoc">A foundational class for implementing custom worker threads.</div><div class="ttdef"><b>Definition</b> <a href="../../dc/d98/modular__structure_2core_2include_2thread__system__core_2thread__base_2core_2thread__base_8h_source.html#l00150">thread_base.h:151</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_afeb2e53943516cf65354f9cd5930b2d5"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5">thread_module::thread_base::do_work</a></div><div class="ttdeci">virtual auto do_work(void) -&gt; result_void</div><div class="ttdoc">The main work routine for the worker thread.</div><div class="ttdef"><b>Definition</b> <a href="../../dc/d98/modular__structure_2core_2include_2thread__system__core_2thread__base_2core_2thread__base_8h_source.html#l00272">thread_base.h:272</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1043"></a>
Thread Pool to thread_pool</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Custom thread pool</span></div>
<div class="line"><a class="code hl_class" href="../../d2/d1f/classSimpleThreadPool.html">SimpleThreadPool</a> pool(std::thread::hardware_concurrency());</div>
<div class="line">pool.enqueue([]() {</div>
<div class="line">    process_data();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Thread System thread_pool</span></div>
<div class="line"><span class="keyword">auto</span> [pool, error] = <a class="code hl_function" href="../../d6/d0d/comparison__benchmark_8cpp.html#a85c1bc628eb54edb6a3c2f3e611ef6e2">create_default</a>(std::thread::hardware_concurrency());</div>
<div class="line"><span class="keywordflow">if</span> (error.has_value()) {</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    []() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            process_data();</div>
<div class="line">            <span class="keywordflow">return</span> std::nullopt; <span class="comment">// Success</span></div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            <span class="keywordflow">return</span> e.what(); <span class="comment">// Error</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = pool-&gt;enqueue(std::move(job));</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">    <span class="comment">// Handle enqueue error</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = pool-&gt;start();</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">    <span class="comment">// Handle start error</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later</span></div>
<div class="line">pool-&gt;stop();</div>
<div class="ttc" id="acomparison__benchmark_8cpp_html_a85c1bc628eb54edb6a3c2f3e611ef6e2"><div class="ttname"><a href="../../d6/d0d/comparison__benchmark_8cpp.html#a85c1bc628eb54edb6a3c2f3e611ef6e2">create_default</a></div><div class="ttdeci">auto create_default(const uint16_t &amp;worker_counts) -&gt; std::tuple&lt; std::shared_ptr&lt; thread_pool_module::thread_pool &gt;, std::optional&lt; std::string &gt; &gt;</div><div class="ttdef"><b>Definition</b> <a href="../../d6/d0d/comparison__benchmark_8cpp_source.html#l00068">comparison_benchmark.cpp:68</a></div></div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1integrations_html_a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282"><div class="ttname"><a href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">kcenon::messaging::integrations::external_system_status::error</a></div><div class="ttdeci">@ error</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1044"></a>
Async Processing to Thread System</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: std::async</span></div>
<div class="line"><span class="keyword">auto</span> future = std::async(std::launch::async, []() {</div>
<div class="line">    <span class="keywordflow">return</span> process_data();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later</span></div>
<div class="line"><span class="keyword">auto</span> result = future.get();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Thread System with promise/future pattern</span></div>
<div class="line">std::promise&lt;Result&gt; promise;</div>
<div class="line">std::future&lt;Result&gt; future = promise.get_future();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    [&amp;promise]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            Result result = process_data();</div>
<div class="line">            promise.set_value(result);</div>
<div class="line">            <span class="keywordflow">return</span> std::nullopt; <span class="comment">// Success</span></div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            promise.set_exception(std::current_exception());</div>
<div class="line">            <span class="keywordflow">return</span> e.what(); <span class="comment">// Error</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">thread_pool-&gt;enqueue(std::move(job));</div>
<div class="line">thread_pool-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later</span></div>
<div class="line"><span class="keyword">auto</span> result = future.get(); <span class="comment">// Will throw if exception was set</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1045"></a>
Producer-Consumer to Thread System</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Custom producer-consumer with thread-safe queue</span></div>
<div class="line">ThreadSafeQueue&lt;Item&gt; queue;</div>
<div class="line"><span class="comment">// Producer and consumer threads...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Thread System job-based approach</span></div>
<div class="line"><span class="keyword">class </span>Producer : <span class="keyword">public</span> <a class="code hl_class" href="../../da/d94/classthread__module_1_1thread__base.html">thread_module::thread_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Producer(std::shared_ptr&lt;thread_pool_module::thread_pool&gt; consumer_pool)</div>
<div class="line">        : consumer_pool_(consumer_pool) {}</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5">do_work</a>() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        Item item = produce_item();</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [item]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">                <span class="comment">// Consumer logic</span></div>
<div class="line">                consume_item(item);</div>
<div class="line">                <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = consumer_pool_-&gt;enqueue(std::move(job));</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">            <span class="keywordflow">return</span> make_error(<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.value());</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a>() const -&gt; <span class="keywordtype">bool</span><span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">return</span> should_continue_producing_;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;thread_pool_module::thread_pool&gt; consumer_pool_;</div>
<div class="line">    <span class="keywordtype">bool</span> should_continue_producing_ = <span class="keyword">true</span>;</div>
<div class="line">    </div>
<div class="line">    Item produce_item() {</div>
<div class="line">        <span class="comment">// Production logic</span></div>
<div class="line">        <span class="keywordflow">return</span> Item{};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> consumer_pool = <a class="code hl_function" href="../../d6/d0d/comparison__benchmark_8cpp.html#a85c1bc628eb54edb6a3c2f3e611ef6e2">create_default</a>(4).first;</div>
<div class="line">consumer_pool-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> producer = std::make_unique&lt;Producer&gt;(consumer_pool);</div>
<div class="line">producer-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later</span></div>
<div class="line">producer-&gt;stop();</div>
<div class="line">consumer_pool-&gt;stop();</div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_aed49d6d3bcda2aa7a31b233269bc7f0f"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">thread_module::thread_base::should_continue_work</a></div><div class="ttdeci">virtual auto should_continue_work(void) const -&gt; bool</div><div class="ttdoc">Determines whether the thread should continue doing work.</div><div class="ttdef"><b>Definition</b> <a href="../../dc/d98/modular__structure_2core_2include_2thread__system__core_2thread__base_2core_2thread__base_8h_source.html#l00253">thread_base.h:253</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1046"></a>
Step 4: Advanced Refactoring</h1>
<p>After the basic migration, enhance your code with Thread System's advanced features:</p>
<h2><a class="anchor" id="autotoc_md1047"></a>
Adding Type Support</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Regular thread pool jobs</span></div>
<div class="line">pool-&gt;enqueue(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    []() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        process_data();</div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    }</div>
<div class="line">));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Type-based jobs</span></div>
<div class="line"><span class="keyword">auto</span> [type_pool, error] = create_type_pool(2, 2, 2); <span class="comment">// High, normal, low</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Critical job</span></div>
<div class="line"><span class="keyword">auto</span> critical_job = std::make_unique&lt;typed_thread_pool_module::callback_typed_job&gt;(</div>
<div class="line">    []() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> {</div>
<div class="line">        process_critical_data();</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    },</div>
<div class="line">    typed_thread_pool_module::job_types::High</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Background job</span></div>
<div class="line"><span class="keyword">auto</span> background_job = std::make_unique&lt;typed_thread_pool_module::callback_typed_job&gt;(</div>
<div class="line">    []() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> {</div>
<div class="line">        process_background_data();</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    },</div>
<div class="line">    typed_thread_pool_module::job_types::Low</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">type_pool-&gt;enqueue(std::move(critical_job));</div>
<div class="line">type_pool-&gt;enqueue(std::move(background_job));</div>
<div class="line">type_pool-&gt;start();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1048"></a>
Integrating Logging</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Custom logging</span></div>
<div class="line"><span class="keywordtype">void</span> log_message(<span class="keyword">const</span> std::string&amp; message) {</div>
<div class="line">    std::lock_guard&lt;std::mutex&gt; lock(log_mutex_);</div>
<div class="line">    std::cout &lt;&lt; get_timestamp() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Thread System logging</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="../../d6/d01/logger__sample_8cpp.html#a8d986ee76ac0cece6635815924ac089f">initialize_logger</a>() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">    log_module::set_title(<span class="stringliteral">&quot;my_application&quot;</span>);</div>
<div class="line">    log_module::console_target(log_module::log_types::All);</div>
<div class="line">    log_module::file_target(log_module::log_types::Warning | </div>
<div class="line">                           log_module::log_types::Error);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> log_module::start();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Initialize logger</span></div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = <a class="code hl_function" href="../../d6/d01/logger__sample_8cpp.html#a8d986ee76ac0cece6635815924ac089f">initialize_logger</a>();</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Logger initialization failed: &quot;</span> &lt;&lt; <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.value() &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use logger in threads</span></div>
<div class="line"><span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    []() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        log_module::write_information(<span class="stringliteral">&quot;Starting job processing&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            process_data();</div>
<div class="line">            log_module::write_information(<span class="stringliteral">&quot;Job completed successfully&quot;</span>);</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            log_module::write_error(<span class="stringliteral">&quot;Job failed: {}&quot;</span>, e.what());</div>
<div class="line">            <span class="keywordflow">return</span> e.what();</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="ttc" id="alogger__sample_8cpp_html_a8d986ee76ac0cece6635815924ac089f"><div class="ttname"><a href="../../d6/d01/logger__sample_8cpp.html#a8d986ee76ac0cece6635815924ac089f">initialize_logger</a></div><div class="ttdeci">auto initialize_logger() -&gt; std::optional&lt; std::string &gt;</div><div class="ttdef"><b>Definition</b> <a href="../../d6/d01/logger__sample_8cpp_source.html#l00048">logger_sample.cpp:48</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1049"></a>
Implementing Periodic Tasks</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Custom timer thread</span></div>
<div class="line">std::atomic&lt;bool&gt; <a class="code hl_variable" href="../../d2/d72/advanced__analysis__example_8cpp.html#af53701aded99286de42137bffab9561a">running</a>{<span class="keyword">true</span>};</div>
<div class="line">std::thread timer_thread([&amp;<a class="code hl_variable" href="../../d2/d72/advanced__analysis__example_8cpp.html#af53701aded99286de42137bffab9561a">running</a>]() {</div>
<div class="line">    <span class="keywordflow">while</span> (<a class="code hl_variable" href="../../d2/d72/advanced__analysis__example_8cpp.html#af53701aded99286de42137bffab9561a">running</a>) {</div>
<div class="line">        perform_periodic_task();</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(60));</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later</span></div>
<div class="line"><a class="code hl_variable" href="../../d2/d72/advanced__analysis__example_8cpp.html#af53701aded99286de42137bffab9561a">running</a> = <span class="keyword">false</span>;</div>
<div class="line">timer_thread.join();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Thread System with wake interval</span></div>
<div class="line"><span class="keyword">class </span>PeriodicTask : <span class="keyword">public</span> <a class="code hl_class" href="../../da/d94/classthread__module_1_1thread__base.html">thread_module::thread_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PeriodicTask() {</div>
<div class="line">        <span class="comment">// Set 60-second wake interval</span></div>
<div class="line">        <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#a3910ded89424d7f2c698bf268dad6648">set_wake_interval</a>(std::chrono::seconds(60));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5">do_work</a>() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            perform_periodic_task();</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            <span class="keywordflow">return</span> make_error(e.what());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> periodic_task = std::make_unique&lt;PeriodicTask&gt;();</div>
<div class="line">periodic_task-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later</span></div>
<div class="line">periodic_task-&gt;stop();</div>
<div class="ttc" id="aadvanced__analysis__example_8cpp_html_af53701aded99286de42137bffab9561a"><div class="ttname"><a href="../../d2/d72/advanced__analysis__example_8cpp.html#af53701aded99286de42137bffab9561a">running</a></div><div class="ttdeci">std::atomic&lt; bool &gt; running</div><div class="ttdef"><b>Definition</b> <a href="../../d2/d72/advanced__analysis__example_8cpp_source.html#l00022">advanced_analysis_example.cpp:22</a></div></div>
<div class="ttc" id="aclassthread__module_1_1thread__base_html_a3910ded89424d7f2c698bf268dad6648"><div class="ttname"><a href="../../da/d94/classthread__module_1_1thread__base.html#a3910ded89424d7f2c698bf268dad6648">thread_module::thread_base::set_wake_interval</a></div><div class="ttdeci">auto set_wake_interval(const std::optional&lt; std::chrono::milliseconds &gt; &amp;wake_interval) -&gt; void</div><div class="ttdoc">Sets the interval at which the worker thread should wake up (if any).</div><div class="ttdef"><b>Definition</b> <a href="../../d4/deb/modular__structure_2core_2src_2thread__base_2core_2thread__base_8cpp_source.html#l00096">thread_base.cpp:96</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1050"></a>
Error Handling Improvements</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Exception-based error handling</span></div>
<div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">    pool.enqueue([]() {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            process_data();</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    });</div>
<div class="line">} <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue job: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Result-based error handling</span></div>
<div class="line"><span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    []() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        <span class="comment">// Try to process data</span></div>
<div class="line">        <span class="keyword">auto</span> result = process_data();</div>
<div class="line">        <span class="keywordflow">if</span> (result.has_error()) {</div>
<div class="line">            log_module::write_error(<span class="stringliteral">&quot;Processing error: {}&quot;</span>, result.get_error().message());</div>
<div class="line">            <span class="keywordflow">return</span> result.get_error().message();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = pool-&gt;enqueue(std::move(job));</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">    log_module::write_error(<span class="stringliteral">&quot;Failed to enqueue job: {}&quot;</span>, <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.value());</div>
<div class="line">    <span class="comment">// Handle error</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1051"></a>
Step 5: Testing and Validation</h1>
<p>After migrating to Thread System, thoroughly test your code:</p>
<h2><a class="anchor" id="autotoc_md1052"></a>
Unit Tests for Thread System Components</h2>
<div class="fragment"><div class="line"><span class="comment">// Test thread_base functionality</span></div>
<div class="line"><a class="code hl_function" href="../../d9/d22/ring__buffer__test_8cpp.html#a00f7cf7e0a118da418e38a390949587d">TEST</a>(<a class="code hl_class" href="../../db/d90/classThreadBaseTest.html">ThreadBaseTest</a>, StartStopCycle) {</div>
<div class="line">    <span class="comment">// Create a custom thread_base</span></div>
<div class="line">    <span class="keyword">class </span>TestThread : <span class="keyword">public</span> <a class="code hl_class" href="../../da/d94/classthread__module_1_1thread__base.html">thread_module::thread_base</a> {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        std::atomic&lt;int&gt; counter{0};</div>
<div class="line">        </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#afeb2e53943516cf65354f9cd5930b2d5">do_work</a>() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">            counter++;</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_function" href="../../da/d94/classthread__module_1_1thread__base.html#aed49d6d3bcda2aa7a31b233269bc7f0f">should_continue_work</a>() const -&gt; <span class="keywordtype">bool</span><span class="keyword"> override </span>{</div>
<div class="line">            <span class="keywordflow">return</span> counter &lt; 10;</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">auto</span> test_thread = std::make_unique&lt;TestThread&gt;();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Start the thread</span></div>
<div class="line">    <span class="keyword">auto</span> result = test_thread-&gt;start();</div>
<div class="line">    ASSERT_FALSE(result.has_value()) &lt;&lt; <span class="stringliteral">&quot;Thread failed to start: &quot;</span> </div>
<div class="line">                                    &lt;&lt; result.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for completion</span></div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Stop the thread</span></div>
<div class="line">    result = test_thread-&gt;stop();</div>
<div class="line">    ASSERT_FALSE(result.has_value()) &lt;&lt; <span class="stringliteral">&quot;Thread failed to stop: &quot;</span> </div>
<div class="line">                                    &lt;&lt; result.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Verify counter value</span></div>
<div class="line">    EXPECT_EQ(test_thread-&gt;counter, 10) &lt;&lt; <span class="stringliteral">&quot;Thread did not execute expected number of iterations&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Test thread_pool functionality</span></div>
<div class="line"><a class="code hl_function" href="../../d9/d22/ring__buffer__test_8cpp.html#a00f7cf7e0a118da418e38a390949587d">TEST</a>(ThreadPoolTest, JobExecution) {</div>
<div class="line">    <span class="comment">// Create thread pool</span></div>
<div class="line">    <span class="keyword">auto</span> [pool, <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>] = <a class="code hl_function" href="../../d6/d0d/comparison__benchmark_8cpp.html#a85c1bc628eb54edb6a3c2f3e611ef6e2">create_default</a>(4);</div>
<div class="line">    ASSERT_FALSE(<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) &lt;&lt; <span class="stringliteral">&quot;Failed to create thread pool: &quot;</span> </div>
<div class="line">                                   &lt;&lt; <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create atomic counter for job completion tracking</span></div>
<div class="line">    std::atomic&lt;int&gt; completed_jobs{0};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Prepare jobs</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> job_count = 100;</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_module::job&gt;&gt; jobs;</div>
<div class="line">    jobs.reserve(job_count);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; job_count; ++i) {</div>
<div class="line">        jobs.push_back(std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [&amp;completed_jobs]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">                completed_jobs++;</div>
<div class="line">                <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">            }</div>
<div class="line">        ));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Enqueue jobs</span></div>
<div class="line">    <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = pool-&gt;enqueue_batch(std::move(jobs));</div>
<div class="line">    ASSERT_FALSE(<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) &lt;&lt; <span class="stringliteral">&quot;Failed to enqueue jobs: &quot;</span> </div>
<div class="line">                                   &lt;&lt; <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Start pool</span></div>
<div class="line">    <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = pool-&gt;start();</div>
<div class="line">    ASSERT_FALSE(<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) &lt;&lt; <span class="stringliteral">&quot;Failed to start thread pool: &quot;</span> </div>
<div class="line">                                   &lt;&lt; <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Wait for completion (with timeout)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#a0ebc74b13acdfe5c2939ed4e5acaeab6a90272dda245ae1fb3cf197e91a8689dc">timeout</a> = std::chrono::seconds(5);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> start_time = std::chrono::steady_clock::now();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (completed_jobs &lt; job_count) {</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (std::chrono::steady_clock::now() - start_time &gt; timeout) {</div>
<div class="line">            pool-&gt;stop();</div>
<div class="line">            FAIL() &lt;&lt; <span class="stringliteral">&quot;Timeout waiting for jobs to complete. Completed: &quot;</span> </div>
<div class="line">                  &lt;&lt; completed_jobs &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; job_count;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Stop pool</span></div>
<div class="line">    pool-&gt;stop();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Verify all jobs completed</span></div>
<div class="line">    EXPECT_EQ(completed_jobs, job_count) &lt;&lt; <span class="stringliteral">&quot;Not all jobs were executed&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassThreadBaseTest_html"><div class="ttname"><a href="../../db/d90/classThreadBaseTest.html">ThreadBaseTest</a></div><div class="ttdef"><b>Definition</b> <a href="../../d7/d7c/thread__base__test_8cpp_source.html#l00044">thread_base_test.cpp:45</a></div></div>
<div class="ttc" id="anamespacekcenon_1_1messaging_1_1core_html_a0ebc74b13acdfe5c2939ed4e5acaeab6a90272dda245ae1fb3cf197e91a8689dc"><div class="ttname"><a href="../../db/d06/namespacekcenon_1_1messaging_1_1core.html#a0ebc74b13acdfe5c2939ed4e5acaeab6a90272dda245ae1fb3cf197e91a8689dc">kcenon::messaging::core::message_status::timeout</a></div><div class="ttdeci">@ timeout</div></div>
<div class="ttc" id="aring__buffer__test_8cpp_html_a00f7cf7e0a118da418e38a390949587d"><div class="ttname"><a href="../../d9/d22/ring__buffer__test_8cpp.html#a00f7cf7e0a118da418e38a390949587d">TEST</a></div><div class="ttdeci">TEST(RingBufferGenericTest, DifferentTypes)</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d22/ring__buffer__test_8cpp_source.html#l00124">ring_buffer_test.cpp:124</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1053"></a>
Performance Validation</h2>
<div class="fragment"><div class="line"><span class="comment">// Performance comparison</span></div>
<div class="line"><span class="keywordtype">void</span> performance_comparison() {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> iterations = 10;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> job_count = 100000;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Measure original implementation</span></div>
<div class="line">    <span class="keywordtype">double</span> original_avg_time = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iterations; ++i) {</div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        run_original_implementation(job_count);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">            end_time - start_time).count();</div>
<div class="line">            </div>
<div class="line">        original_avg_time += duration;</div>
<div class="line">    }</div>
<div class="line">    original_avg_time /= iterations;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Measure Thread System implementation</span></div>
<div class="line">    <span class="keywordtype">double</span> thread_system_avg_time = 0.0;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iterations; ++i) {</div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        run_thread_system_implementation(job_count);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">            end_time - start_time).count();</div>
<div class="line">            </div>
<div class="line">        thread_system_avg_time += duration;</div>
<div class="line">    }</div>
<div class="line">    thread_system_avg_time /= iterations;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Compare results</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Original implementation: &quot;</span> &lt;&lt; original_avg_time &lt;&lt; <span class="stringliteral">&quot;ms\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Thread System implementation: &quot;</span> &lt;&lt; thread_system_avg_time &lt;&lt; <span class="stringliteral">&quot;ms\n&quot;</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Performance change: &quot;</span> </div>
<div class="line">              &lt;&lt; ((thread_system_avg_time / original_avg_time) - 1.0) * 100 &lt;&lt; <span class="stringliteral">&quot;%\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1054"></a>
Common Migration Challenges and Solutions</h1>
<h2><a class="anchor" id="autotoc_md1055"></a>
Challenge 1: Adapting to Result-based Error Handling</h2>
<p><b>Problem</b>: Thread System uses <code>std::optional&lt;std::string&gt;</code> or <code>result_void</code> for error reporting instead of exceptions.</p>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// Create a wrapper function to convert exception-based code</span></div>
<div class="line"><span class="keyword">auto</span> run_with_exception_handling(std::function&lt;<span class="keywordtype">void</span>()&gt; func) -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        func();</div>
<div class="line">        <span class="keywordflow">return</span> std::nullopt; <span class="comment">// Success</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        <span class="keywordflow">return</span> e.what(); <span class="comment">// Return error message</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Unknown error occurred&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">    [legacy_func]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        <span class="keywordflow">return</span> run_with_exception_handling(legacy_func);</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1056"></a>
Challenge 2: Managing Thread Lifecycle</h2>
<p><b>Problem</b>: Thread System has a different lifecycle model (start/stop) compared to raw threads.</p>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// Create a manager class for Thread System components</span></div>
<div class="line"><span class="keyword">class </span>ThreadManager {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Add a thread_base component</span></div>
<div class="line">    <span class="keyword">auto</span> add_thread(std::unique_ptr&lt;thread_module::thread_base&gt; thread) -&gt; <span class="keywordtype">void</span> {</div>
<div class="line">        threads_.push_back(std::move(thread));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Start all threads</span></div>
<div class="line">    <span class="keyword">auto</span> start_all() -&gt; std::vector&lt;std::pair&lt;size_t, std::string&gt;&gt; {</div>
<div class="line">        std::vector&lt;std::pair&lt;size_t, std::string&gt;&gt; errors;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; threads_.size(); ++i) {</div>
<div class="line">            <span class="keyword">auto</span> result = threads_[i]-&gt;start();</div>
<div class="line">            <span class="keywordflow">if</span> (result.has_value()) {</div>
<div class="line">                errors.emplace_back(i, result.value());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> errors;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Stop all threads</span></div>
<div class="line">    <span class="keyword">auto</span> stop_all() -&gt; std::vector&lt;std::pair&lt;size_t, std::string&gt;&gt; {</div>
<div class="line">        std::vector&lt;std::pair&lt;size_t, std::string&gt;&gt; errors;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; threads_.size(); ++i) {</div>
<div class="line">            <span class="keyword">auto</span> result = threads_[i]-&gt;stop();</div>
<div class="line">            <span class="keywordflow">if</span> (result.has_value()) {</div>
<div class="line">                errors.emplace_back(i, result.value());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> errors;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;thread_module::thread_base&gt;&gt; threads_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1057"></a>
Challenge 3: Adapting to Job-based Design</h2>
<p><b>Problem</b>: Converting callback-heavy code to Thread System's job-based design.</p>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// Create a job factory for your specific domain</span></div>
<div class="line"><span class="keyword">class </span>JobFactory {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Create a job from a callback function</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> create_callback_job(std::function&lt;<span class="keywordtype">void</span>()&gt; callback) </div>
<div class="line">        -&gt; std::unique_ptr&lt;thread_module::job&gt; {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [callback]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                    callback();</div>
<div class="line">                    <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">                } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                    <span class="keywordflow">return</span> e.what();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Create a domain-specific job</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> create_processing_job(T data) -&gt; std::unique_ptr&lt;thread_module::job&gt; {</div>
<div class="line">        <span class="keywordflow">return</span> std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [data]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">                <span class="keywordflow">return</span> process_data(data);</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Domain-specific processing function</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> process_data(<span class="keyword">const</span> T&amp; data) -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// Domain-specific processing</span></div>
<div class="line">            <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            <span class="keywordflow">return</span> e.what();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1058"></a>
Challenge 4: Integrating with Existing Libraries</h2>
<p><b>Problem</b>: Integrating Thread System with libraries that have their own threading models.</p>
<p><b>Solution</b>: </p><div class="fragment"><div class="line"><span class="comment">// Create an adapter for library integration</span></div>
<div class="line"><span class="keyword">class </span>LibraryThreadAdapter {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    LibraryThreadAdapter(std::shared_ptr&lt;thread_pool_module::thread_pool&gt; pool)</div>
<div class="line">        : thread_pool_(pool) {}</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Convert library callback to Thread System job</span></div>
<div class="line">    <span class="keywordtype">void</span> register_library_callback(std::function&lt;<span class="keywordtype">void</span>(LibraryResult)&gt; callback) {</div>
<div class="line">        <span class="comment">// Set up library to call our adapter function</span></div>
<div class="line">        library_instance_.set_callback([<span class="keyword">this</span>, callback](LibraryResult result) {</div>
<div class="line">            <span class="comment">// Create a job to process the callback on our thread pool</span></div>
<div class="line">            <span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">                [callback, result]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">                    callback(result);</div>
<div class="line">                    <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">                }</div>
<div class="line">            );</div>
<div class="line">            </div>
<div class="line">            thread_pool_-&gt;enqueue(std::move(job));</div>
<div class="line">        });</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ExternalLibrary library_instance_;</div>
<div class="line">    std::shared_ptr&lt;thread_pool_module::thread_pool&gt; thread_pool_;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1059"></a>
Migrating Specific Threading Models</h1>
<h2><a class="anchor" id="autotoc_md1060"></a>
Single Background Thread</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Single background thread</span></div>
<div class="line"><span class="keyword">class </span>BackgroundProcessor {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    BackgroundProcessor() : running_(true) {</div>
<div class="line">        thread_ = std::thread(&amp;BackgroundProcessor::run, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ~BackgroundProcessor() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (thread_.joinable()) {</div>
<div class="line">            thread_.join();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            process_background_tasks();</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    std::thread thread_;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Thread System background thread</span></div>
<div class="line"><span class="keyword">class </span>BackgroundProcessor : <span class="keyword">public</span> <a class="code hl_class" href="../../da/d94/classthread__module_1_1thread__base.html">thread_module::thread_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    BackgroundProcessor() : thread_base(<span class="stringliteral">&quot;background_processor&quot;</span>) {</div>
<div class="line">        <span class="comment">// Wake up every second</span></div>
<div class="line">        set_wake_interval(std::chrono::seconds(1));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">auto</span> do_work() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            process_background_tasks();</div>
<div class="line">            <span class="keywordflow">return</span> {};</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            log_module::write_error(<span class="stringliteral">&quot;Background processing error: {}&quot;</span>, e.what());</div>
<div class="line">            <span class="keywordflow">return</span> make_error(e.what());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1061"></a>
Worker Thread Pool</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Custom worker pool</span></div>
<div class="line"><span class="keyword">class </span>WorkerPool {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    WorkerPool(<span class="keywordtype">size_t</span> <a class="code hl_variable" href="../../df/de0/optimized__storage_8h.html#acbe3ff89760ba4e883cfef7df57f461c">thread_count</a>) {</div>
<div class="line">        workers_.reserve(<a class="code hl_variable" href="../../df/de0/optimized__storage_8h.html#acbe3ff89760ba4e883cfef7df57f461c">thread_count</a>);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; <a class="code hl_variable" href="../../df/de0/optimized__storage_8h.html#acbe3ff89760ba4e883cfef7df57f461c">thread_count</a>; ++i) {</div>
<div class="line">            workers_.emplace_back(std::thread(&amp;WorkerPool::worker_function, <span class="keyword">this</span>));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> add_task(std::function&lt;<span class="keywordtype">void</span>()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">        tasks_.push(std::move(<a class="code hl_struct" href="../../db/da2/structtask.html">task</a>));</div>
<div class="line">        condition_.notify_one();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ~WorkerPool() {</div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">            shutdown_ = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        condition_.notify_all();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; worker : workers_) {</div>
<div class="line">            <span class="keywordflow">if</span> (worker.joinable()) {</div>
<div class="line">                worker.join();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> worker_function() {</div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            std::function&lt;void()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>;</div>
<div class="line">            </div>
<div class="line">            {</div>
<div class="line">                std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">                condition_.wait(lock, [<span class="keyword">this</span>] {</div>
<div class="line">                    <span class="keywordflow">return</span> shutdown_ || !tasks_.empty();</div>
<div class="line">                });</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (shutdown_ &amp;&amp; tasks_.empty()) {</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <a class="code hl_struct" href="../../db/da2/structtask.html">task</a> = std::move(tasks_.front());</div>
<div class="line">                tasks_.pop();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;std::thread&gt; workers_;</div>
<div class="line">    std::queue&lt;std::function&lt;void()&gt;&gt; tasks_;</div>
<div class="line">    std::mutex queue_mutex_;</div>
<div class="line">    std::condition_variable condition_;</div>
<div class="line">    <span class="keywordtype">bool</span> shutdown_ = <span class="keyword">false</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Thread System thread pool</span></div>
<div class="line"><span class="keyword">class </span>WorkerPool {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    WorkerPool(<span class="keywordtype">size_t</span> <a class="code hl_variable" href="../../df/de0/optimized__storage_8h.html#acbe3ff89760ba4e883cfef7df57f461c">thread_count</a>) {</div>
<div class="line">        <span class="keyword">auto</span> [pool, <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>] = <a class="code hl_function" href="../../d6/d0d/comparison__benchmark_8cpp.html#a85c1bc628eb54edb6a3c2f3e611ef6e2">create_default</a>(<a class="code hl_variable" href="../../df/de0/optimized__storage_8h.html#acbe3ff89760ba4e883cfef7df57f461c">thread_count</a>);</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Failed to create thread pool: &quot;</span> + </div>
<div class="line">                                    <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        thread_pool_ = std::move(pool);</div>
<div class="line">        <span class="keyword">auto</span> start_result = thread_pool_-&gt;start();</div>
<div class="line">        <span class="keywordflow">if</span> (start_result.has_value()) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Failed to start thread pool: &quot;</span> + </div>
<div class="line">                                    start_result.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> add_task(std::function&lt;<span class="keywordtype">void</span>()&gt; <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>) {</div>
<div class="line">        <span class="keyword">auto</span> job = std::make_unique&lt;thread_module::callback_job&gt;(</div>
<div class="line">            [<a class="code hl_struct" href="../../db/da2/structtask.html">task</a>]() -&gt; std::optional&lt;std::string&gt; {</div>
<div class="line">                <span class="keywordflow">try</span> {</div>
<div class="line">                    <a class="code hl_struct" href="../../db/da2/structtask.html">task</a>();</div>
<div class="line">                    <span class="keywordflow">return</span> std::nullopt;</div>
<div class="line">                } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                    <span class="keywordflow">return</span> e.what();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a> = thread_pool_-&gt;enqueue(std::move(job));</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.has_value()) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Failed to enqueue job: &quot;</span> + </div>
<div class="line">                                    <a class="code hl_enumvalue" href="../../d9/dda/namespacekcenon_1_1messaging_1_1integrations.html#a9709b17de9726ec32bb398f5868ce728acb5e100e5a9a3e7f6d1fd97512215282">error</a>.value_or(<span class="stringliteral">&quot;unknown error&quot;</span>));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ~WorkerPool() {</div>
<div class="line">        thread_pool_-&gt;stop();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;thread_pool_module::thread_pool&gt; thread_pool_;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1062"></a>
Event Loop</h2>
<div class="fragment"><div class="line"><span class="comment">// Before: Event loop</span></div>
<div class="line"><span class="keyword">class </span>EventLoop {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            Event event;</div>
<div class="line">            <span class="keywordflow">if</span> (event_queue_.try_dequeue(event)) {</div>
<div class="line">                process_event(event);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> push_event(<span class="keyword">const</span> Event&amp; event) {</div>
<div class="line">        event_queue_.enqueue(event);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> process_event(<span class="keyword">const</span> Event&amp; event) {</div>
<div class="line">        <span class="comment">// Handle event</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ConcurrentQueue&lt;Event&gt; event_queue_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_{<span class="keyword">false</span>};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// After: Thread System based event loop</span></div>
<div class="line"><span class="keyword">class </span>EventLoop : <span class="keyword">public</span> <a class="code hl_class" href="../../da/d94/classthread__module_1_1thread__base.html">thread_module::thread_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EventLoop() : thread_base(<span class="stringliteral">&quot;event_loop&quot;</span>) {</div>
<div class="line">        <span class="comment">// Wake up frequently to check for events</span></div>
<div class="line">        set_wake_interval(std::chrono::milliseconds(10));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> push_event(<span class="keyword">const</span> Event&amp; event) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">        event_queue_.push(event);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">auto</span> do_work() -&gt; <a class="code hl_class" href="../../dd/da2/classthread__module_1_1result__void.html">result_void</a> <span class="keyword">override</span> {</div>
<div class="line">        Event event;</div>
<div class="line">        <span class="keywordtype">bool</span> has_event = <span class="keyword">false</span>;</div>
<div class="line">        </div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">            <span class="keywordflow">if</span> (!event_queue_.empty()) {</div>
<div class="line">                <span class="keyword">event</span> = event_queue_.front();</div>
<div class="line">                event_queue_.pop();</div>
<div class="line">                has_event = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (has_event) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                process_event(event);</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                <span class="keywordflow">return</span> make_error(e.what());</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> process_event(<span class="keyword">const</span> Event&amp; event) {</div>
<div class="line">        <span class="comment">// Handle event</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::queue&lt;Event&gt; event_queue_;</div>
<div class="line">    std::mutex queue_mutex_;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1063"></a>
Best Practices for Successful Migration</h1>
<ol type="1">
<li><b>Incremental migration</b>: Migrate one subsystem at a time, rather than the entire codebase</li>
<li><b>Start with core components</b>: Begin with central threading components that have wide impacts</li>
<li><b>Create adaptation layers</b>: Build bridges between Thread System and existing code</li>
<li><b>Thorough testing</b>: Validate correctness and performance at each step</li>
<li><b>Monitor error handling</b>: Ensure all errors are properly captured and reported</li>
<li><b>Document rationale</b>: Record why specific migration decisions were made</li>
<li><b>Train the team</b>: Ensure all developers understand Thread System concepts</li>
</ol>
<h1><a class="anchor" id="autotoc_md1064"></a>
Migration Checklist</h1>
<p>Use this checklist to track your migration progress:</p>
<ul>
<li>[ ] Identify all threading code in the application</li>
<li>[ ] Select appropriate Thread System components for each usage</li>
<li>[ ] Develop a phased migration plan</li>
<li>[ ] Create adaptation code where needed</li>
<li>[ ] Refactor one component at a time</li>
<li>[ ] Write tests for the migrated code</li>
<li>[ ] Verify correctness and performance</li>
<li>[ ] Update documentation</li>
<li>[ ] Review for further optimizations</li>
</ul>
<h1><a class="anchor" id="autotoc_md1065"></a>
Conclusion</h1>
<p>Migrating to Thread System provides significant advantages for code clarity, maintainability, and correctness. By following this guide, you can systematically transform your existing threading code to leverage Thread System's structured approach and advanced features.</p>
<p>Remember that successful migration is an incremental process. Take the time to understand each component, test thoroughly, and gradually build expertise with Thread System's capabilities. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
