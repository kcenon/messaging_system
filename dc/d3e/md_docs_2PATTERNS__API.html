<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging System: Messaging Patterns API Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Messaging System<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">High-Performance Cross-Platform Messaging Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dc/d3e/md_docs_2PATTERNS__API.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Messaging Patterns API Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md510"></a> This document provides detailed API documentation for the messaging patterns implemented in the messaging system.</p>
<h1><a class="anchor" id="autotoc_md511"></a>
Table of Contents</h1>
<ol type="1">
<li>Pub/Sub Pattern</li>
<li>Request-Reply Pattern</li>
<li>Event Streaming Pattern</li>
<li>Message Pipeline Pattern</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md513"></a>
Pub/Sub Pattern</h1>
<h2><a class="anchor" id="autotoc_md514"></a>
Namespace: &lt;tt&gt;kcenon::messaging::patterns&lt;/tt&gt;</h2>
<p>The Pub/Sub pattern provides a simplified interface for publish-subscribe messaging.</p>
<h2><a class="anchor" id="autotoc_md515"></a>
Class: &lt;tt&gt;publisher&lt;/tt&gt;</h2>
<p>High-level publisher for the pub/sub pattern.</p>
<h3><a class="anchor" id="autotoc_md516"></a>
Constructor</h3>
<div class="fragment"><div class="line">publisher(std::shared_ptr&lt;message_bus&gt; bus);</div>
<div class="line">publisher(std::shared_ptr&lt;message_bus&gt; bus, std::string default_topic);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md517"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md518"></a>
&lt;tt&gt;publish&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult publish(message msg);</div>
<div class="line">common::VoidResult publish(<span class="keyword">const</span> std::string&amp; topic, message msg);</div>
</div><!-- fragment --><p> Publishes a message to the default topic or a specified topic.</p>
<h4><a class="anchor" id="autotoc_md519"></a>
&lt;tt&gt;get_default_topic&lt;/tt&gt;</h4>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string&amp; get_default_topic() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Returns the default topic.</p>
<h4><a class="anchor" id="autotoc_md520"></a>
&lt;tt&gt;set_default_topic&lt;/tt&gt;</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_default_topic(std::string topic);</div>
</div><!-- fragment --><p> Sets a new default topic.</p>
<h4><a class="anchor" id="autotoc_md521"></a>
&lt;tt&gt;is_ready&lt;/tt&gt;</h4>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_ready() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Checks if the publisher is ready to publish messages.</p>
<h3><a class="anchor" id="autotoc_md522"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/patterns/pub_sub.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>kcenon::messaging;</div>
<div class="line"><span class="keyword">using namespace </span>kcenon::messaging::patterns;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create message bus</span></div>
<div class="line"><span class="keyword">auto</span> backend = std::make_shared&lt;standalone_backend&gt;(4);</div>
<div class="line"><span class="keyword">auto</span> bus = std::make_shared&lt;message_bus&gt;(backend);</div>
<div class="line">bus-&gt;start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create publisher with default topic</span></div>
<div class="line">publisher pub(bus, <span class="stringliteral">&quot;events.system&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Publish message to default topic</span></div>
<div class="line">message msg(<span class="stringliteral">&quot;events.system&quot;</span>, message_type::event);</div>
<div class="line">msg.metadata().source = <span class="stringliteral">&quot;service-a&quot;</span>;</div>
<div class="line">pub.publish(std::move(msg));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Publish to specific topic</span></div>
<div class="line">message msg2(<span class="stringliteral">&quot;events.custom&quot;</span>, message_type::event);</div>
<div class="line">pub.publish(<span class="stringliteral">&quot;events.custom&quot;</span>, std::move(msg2));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md523"></a>
Class: &lt;tt&gt;subscriber&lt;/tt&gt;</h2>
<p>High-level subscriber for the pub/sub pattern.</p>
<h3><a class="anchor" id="autotoc_md524"></a>
Constructor</h3>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> subscriber(std::shared_ptr&lt;message_bus&gt; bus);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md525"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md526"></a>
&lt;tt&gt;subscribe&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::Result&lt;uint64_t&gt; subscribe(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; topic_pattern,</div>
<div class="line">    subscription_callback callback,</div>
<div class="line">    message_filter filter = <span class="keyword">nullptr</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> Subscribes to a topic pattern with an optional filter.</p>
<h4><a class="anchor" id="autotoc_md527"></a>
&lt;tt&gt;unsubscribe_all&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult unsubscribe_all();</div>
</div><!-- fragment --><p> Unsubscribes from all topics.</p>
<h3><a class="anchor" id="autotoc_md528"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Create subscriber</span></div>
<div class="line">subscriber sub(bus);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subscribe to events</span></div>
<div class="line"><span class="keyword">auto</span> sub_result = sub.subscribe(<span class="stringliteral">&quot;events.*&quot;</span>, [](<span class="keyword">const</span> message&amp; msg) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Received event: &quot;</span> &lt;&lt; msg.metadata().topic &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> common::ok();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subscribe with filter</span></div>
<div class="line"><span class="keyword">auto</span> filtered_sub = sub.subscribe(</div>
<div class="line">    <span class="stringliteral">&quot;events.*&quot;</span>,</div>
<div class="line">    [](<span class="keyword">const</span> message&amp; msg) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;High priority event: &quot;</span> &lt;&lt; msg.metadata().topic &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> common::ok();</div>
<div class="line">    },</div>
<div class="line">    [](<span class="keyword">const</span> message&amp; msg) {</div>
<div class="line">        <span class="keywordflow">return</span> msg.metadata().priority == message_priority::high;</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md530"></a>
Request-Reply Pattern</h1>
<h2><a class="anchor" id="autotoc_md531"></a>
Namespace: &lt;tt&gt;kcenon::messaging::patterns&lt;/tt&gt;</h2>
<p>The Request-Reply pattern enables synchronous request-reply communication over asynchronous messaging.</p>
<h2><a class="anchor" id="autotoc_md532"></a>
Class: &lt;tt&gt;request_reply_handler&lt;/tt&gt;</h2>
<p>Handles request-reply messaging pattern with correlation IDs.</p>
<h3><a class="anchor" id="autotoc_md533"></a>
Constructor</h3>
<div class="fragment"><div class="line">request_reply_handler(</div>
<div class="line">    std::shared_ptr&lt;message_bus&gt; bus,</div>
<div class="line">    std::string service_topic</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md534"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md535"></a>
&lt;tt&gt;request&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::Result&lt;message&gt; request(</div>
<div class="line">    message req,</div>
<div class="line">    std::chrono::milliseconds timeout = std::chrono::milliseconds{5000}</div>
<div class="line">);</div>
</div><!-- fragment --><p> Sends a request and waits for a reply.</p>
<h4><a class="anchor" id="autotoc_md536"></a>
&lt;tt&gt;register_handler&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult register_handler(</div>
<div class="line">    std::function&lt;common::Result&lt;message&gt;(<span class="keyword">const</span> message&amp;)&gt; handler</div>
<div class="line">);</div>
</div><!-- fragment --><p> Registers a handler function for processing requests (server side).</p>
<h3><a class="anchor" id="autotoc_md537"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/patterns/request_reply.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Client side</span></div>
<div class="line">request_reply_handler client(bus, <span class="stringliteral">&quot;service.compute&quot;</span>);</div>
<div class="line"> </div>
<div class="line">message request(<span class="stringliteral">&quot;service.compute&quot;</span>, message_type::query);</div>
<div class="line">request.metadata().source = <span class="stringliteral">&quot;client-app&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> reply_result = client.request(std::move(request), std::chrono::seconds{10});</div>
<div class="line"><span class="keywordflow">if</span> (reply_result.is_ok()) {</div>
<div class="line">    <span class="keyword">auto</span> reply = reply_result.unwrap();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Got reply: &quot;</span> &lt;&lt; reply.metadata().topic &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Server side</span></div>
<div class="line">request_reply_handler server(bus, <span class="stringliteral">&quot;service.compute&quot;</span>);</div>
<div class="line"> </div>
<div class="line">server.register_handler([](<span class="keyword">const</span> message&amp; request) -&gt; common::Result&lt;message&gt; {</div>
<div class="line">    <span class="comment">// Process request</span></div>
<div class="line">    message reply(<span class="stringliteral">&quot;reply.topic&quot;</span>, message_type::reply);</div>
<div class="line">    reply.metadata().correlation_id = request.metadata().id;</div>
<div class="line">    <span class="keywordflow">return</span> common::ok(std::move(reply));</div>
<div class="line">});</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md538"></a>
Class: &lt;tt&gt;request_client&lt;/tt&gt;</h2>
<p>Simplified client for making requests.</p>
<h3><a class="anchor" id="autotoc_md539"></a>
Constructor</h3>
<div class="fragment"><div class="line">request_client(std::shared_ptr&lt;message_bus&gt; bus);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md540"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md541"></a>
&lt;tt&gt;request&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::Result&lt;message&gt; request(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; service_topic,</div>
<div class="line">    message req,</div>
<div class="line">    std::chrono::milliseconds timeout = std::chrono::milliseconds{5000}</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md542"></a>
Usage Example</h3>
<div class="fragment"><div class="line">request_client client(bus);</div>
<div class="line"> </div>
<div class="line">message req(<span class="stringliteral">&quot;service.data&quot;</span>, message_type::query);</div>
<div class="line"><span class="keyword">auto</span> reply = client.request(<span class="stringliteral">&quot;service.data&quot;</span>, std::move(req));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md543"></a>
Class: &lt;tt&gt;request_server&lt;/tt&gt;</h2>
<p>Simplified server for handling requests.</p>
<h3><a class="anchor" id="autotoc_md544"></a>
Constructor</h3>
<div class="fragment"><div class="line">request_server(</div>
<div class="line">    std::shared_ptr&lt;message_bus&gt; bus,</div>
<div class="line">    std::string service_topic</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md545"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md546"></a>
&lt;tt&gt;register_handler&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult register_handler(</div>
<div class="line">    std::function&lt;common::Result&lt;message&gt;(<span class="keyword">const</span> message&amp;)&gt; handler</div>
<div class="line">);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md547"></a>
&lt;tt&gt;start&lt;/tt&gt; / &lt;tt&gt;stop&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult start();</div>
<div class="line">common::VoidResult stop();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md548"></a>
Usage Example</h3>
<div class="fragment"><div class="line">request_server server(bus, <span class="stringliteral">&quot;service.calculator&quot;</span>);</div>
<div class="line"> </div>
<div class="line">server.register_handler([](<span class="keyword">const</span> message&amp; req) -&gt; common::Result&lt;message&gt; {</div>
<div class="line">    <span class="comment">// Perform calculation</span></div>
<div class="line">    message reply(<span class="stringliteral">&quot;reply&quot;</span>, message_type::reply);</div>
<div class="line">    <span class="comment">// ... set reply data ...</span></div>
<div class="line">    <span class="keywordflow">return</span> common::ok(std::move(reply));</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">server.start();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md550"></a>
Event Streaming Pattern</h1>
<h2><a class="anchor" id="autotoc_md551"></a>
Namespace: &lt;tt&gt;kcenon::messaging::patterns&lt;/tt&gt;</h2>
<p>The Event Streaming pattern provides event sourcing capabilities with replay, filtering, and batch processing.</p>
<h2><a class="anchor" id="autotoc_md552"></a>
Struct: &lt;tt&gt;event_stream_config&lt;/tt&gt;</h2>
<p>Configuration for event streams.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>event_stream_config {</div>
<div class="line">    <span class="keywordtype">size_t</span> max_buffer_size = 1000;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_replay = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_persistence = <span class="keyword">false</span>;</div>
<div class="line">    std::chrono::milliseconds batch_timeout{100};</div>
<div class="line">    <span class="keywordtype">size_t</span> batch_size = 10;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md553"></a>
Class: &lt;tt&gt;event_stream&lt;/tt&gt;</h2>
<p>Event streaming and sourcing with replay capabilities.</p>
<h3><a class="anchor" id="autotoc_md554"></a>
Constructor</h3>
<div class="fragment"><div class="line">event_stream(</div>
<div class="line">    std::shared_ptr&lt;message_bus&gt; bus,</div>
<div class="line">    std::string stream_topic,</div>
<div class="line">    event_stream_config config = {}</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md555"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md556"></a>
&lt;tt&gt;publish_event&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult publish_event(message event);</div>
</div><!-- fragment --><p> Publishes an event to the stream and buffers it for replay.</p>
<h4><a class="anchor" id="autotoc_md557"></a>
&lt;tt&gt;subscribe&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::Result&lt;uint64_t&gt; subscribe(</div>
<div class="line">    subscription_callback callback,</div>
<div class="line">    <span class="keywordtype">bool</span> replay_past_events = <span class="keyword">false</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">common::Result&lt;uint64_t&gt; subscribe(</div>
<div class="line">    subscription_callback callback,</div>
<div class="line">    message_filter filter,</div>
<div class="line">    <span class="keywordtype">bool</span> replay_past_events = <span class="keyword">false</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> Subscribes to the event stream with optional replay and filtering.</p>
<h4><a class="anchor" id="autotoc_md558"></a>
&lt;tt&gt;unsubscribe&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult unsubscribe(uint64_t subscription_id);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md559"></a>
&lt;tt&gt;replay&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult replay(</div>
<div class="line">    subscription_callback callback,</div>
<div class="line">    message_filter filter = <span class="keyword">nullptr</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> Manually replays buffered events to a callback.</p>
<h4><a class="anchor" id="autotoc_md560"></a>
&lt;tt&gt;get_events&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">std::vector&lt;message&gt; get_events(message_filter filter = <span class="keyword">nullptr</span>) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Retrieves buffered events with optional filtering.</p>
<h4><a class="anchor" id="autotoc_md561"></a>
&lt;tt&gt;event_count&lt;/tt&gt;</h4>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> event_count() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Returns the number of buffered events.</p>
<h4><a class="anchor" id="autotoc_md562"></a>
&lt;tt&gt;clear_buffer&lt;/tt&gt;</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> clear_buffer();</div>
</div><!-- fragment --><p> Clears the event buffer.</p>
<h3><a class="anchor" id="autotoc_md563"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/patterns/event_streaming.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Configure event stream</span></div>
<div class="line">event_stream_config config;</div>
<div class="line">config.max_buffer_size = 1000;</div>
<div class="line">config.enable_replay = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">event_stream stream(bus, <span class="stringliteral">&quot;events.orders&quot;</span>, config);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Publish events</span></div>
<div class="line">message order_created(<span class="stringliteral">&quot;events.orders&quot;</span>, message_type::event);</div>
<div class="line">order_created.metadata().source = <span class="stringliteral">&quot;order-service&quot;</span>;</div>
<div class="line">stream.publish_event(std::move(order_created));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subscribe with replay</span></div>
<div class="line">stream.subscribe([](<span class="keyword">const</span> message&amp; event) {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Event: &quot;</span> &lt;&lt; <span class="keyword">event</span>.metadata().topic &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> common::ok();</div>
<div class="line">}, <span class="keyword">true</span>);  <span class="comment">// Replay past events</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Subscribe with filter</span></div>
<div class="line"><span class="keyword">auto</span> high_value_filter = [](<span class="keyword">const</span> message&amp; msg) {</div>
<div class="line">    <span class="comment">// Custom filtering logic</span></div>
<div class="line">    <span class="keywordflow">return</span> msg.metadata().priority == message_priority::high;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">stream.subscribe(</div>
<div class="line">    [](<span class="keyword">const</span> message&amp; event) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;High value order!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> common::ok();</div>
<div class="line">    },</div>
<div class="line">    high_value_filter,</div>
<div class="line">    true</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get snapshot of events</span></div>
<div class="line"><span class="keyword">auto</span> events = stream.get_events();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Total events in stream: &quot;</span> &lt;&lt; events.size() &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md564"></a>
Class: &lt;tt&gt;event_batch_processor&lt;/tt&gt;</h2>
<p>Processes events in batches for efficiency.</p>
<h3><a class="anchor" id="autotoc_md565"></a>
Constructor</h3>
<div class="fragment"><div class="line">event_batch_processor(</div>
<div class="line">    std::shared_ptr&lt;message_bus&gt; bus,</div>
<div class="line">    std::string topic_pattern,</div>
<div class="line">    batch_callback callback,</div>
<div class="line">    <span class="keywordtype">size_t</span> batch_size = 10,</div>
<div class="line">    std::chrono::milliseconds batch_timeout = std::chrono::milliseconds{100}</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md566"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md567"></a>
&lt;tt&gt;start&lt;/tt&gt; / &lt;tt&gt;stop&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult start();</div>
<div class="line">common::VoidResult stop();</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md568"></a>
&lt;tt&gt;flush&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult flush();</div>
</div><!-- fragment --><p> Immediately processes the current batch.</p>
<h4><a class="anchor" id="autotoc_md569"></a>
&lt;tt&gt;is_running&lt;/tt&gt;</h4>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> is_running() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md570"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="comment">// Process events in batches of 100</span></div>
<div class="line">event_batch_processor processor(</div>
<div class="line">    bus,</div>
<div class="line">    <span class="stringliteral">&quot;events.analytics.*&quot;</span>,</div>
<div class="line">    [](<span class="keyword">const</span> std::vector&lt;message&gt;&amp; batch) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Processing batch of &quot;</span> &lt;&lt; batch.size() &lt;&lt; <span class="stringliteral">&quot; events&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="comment">// Bulk processing logic</span></div>
<div class="line">        <span class="keywordflow">return</span> common::ok();</div>
<div class="line">    },</div>
<div class="line">    100,  <span class="comment">// batch size</span></div>
<div class="line">    std::chrono::seconds{5}  <span class="comment">// max wait time</span></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">processor.start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Events are automatically collected and processed in batches</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">processor.stop();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md572"></a>
Message Pipeline Pattern</h1>
<h2><a class="anchor" id="autotoc_md573"></a>
Namespace: &lt;tt&gt;kcenon::messaging::patterns&lt;/tt&gt;</h2>
<p>The Message Pipeline pattern implements pipes-and-filters for sequential message processing.</p>
<h2><a class="anchor" id="autotoc_md574"></a>
Type Aliases</h2>
<div class="fragment"><div class="line"><span class="keyword">using </span>message_processor = std::function&lt;common::Result&lt;message&gt;(<span class="keyword">const</span> message&amp;)&gt;;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md575"></a>
Class: &lt;tt&gt;message_pipeline&lt;/tt&gt;</h2>
<p>Sequential message processing pipeline.</p>
<h3><a class="anchor" id="autotoc_md576"></a>
Struct: &lt;tt&gt;pipeline_stage&lt;/tt&gt;</h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span>pipeline_stage {</div>
<div class="line">    std::string name;</div>
<div class="line">    message_processor processor;</div>
<div class="line">    <span class="keywordtype">bool</span> optional;  <span class="comment">// If true, stage failures won&#39;t stop pipeline</span></div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md577"></a>
Constructor</h3>
<div class="fragment"><div class="line">message_pipeline(</div>
<div class="line">    std::shared_ptr&lt;message_bus&gt; bus,</div>
<div class="line">    std::string input_topic,</div>
<div class="line">    std::string output_topic</div>
<div class="line">);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md578"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md579"></a>
&lt;tt&gt;add_stage&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">message_pipeline&amp; add_stage(</div>
<div class="line">    std::string name,</div>
<div class="line">    message_processor processor,</div>
<div class="line">    <span class="keywordtype">bool</span> optional = <span class="keyword">false</span></div>
<div class="line">);</div>
</div><!-- fragment --><p> Adds a processing stage to the pipeline. Returns reference for chaining.</p>
<h4><a class="anchor" id="autotoc_md580"></a>
&lt;tt&gt;remove_stage&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult remove_stage(<span class="keyword">const</span> std::string&amp; name);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md581"></a>
&lt;tt&gt;start&lt;/tt&gt; / &lt;tt&gt;stop&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::VoidResult start();</div>
<div class="line">common::VoidResult stop();</div>
</div><!-- fragment --><p> Starts/stops automatic processing from input to output topic.</p>
<h4><a class="anchor" id="autotoc_md582"></a>
&lt;tt&gt;process&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::Result&lt;message&gt; process(message msg) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> Manually processes a single message through the pipeline.</p>
<h4><a class="anchor" id="autotoc_md583"></a>
&lt;tt&gt;stage_count&lt;/tt&gt;</h4>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> stage_count() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md584"></a>
&lt;tt&gt;get_stage_names&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; get_stage_names() <span class="keyword">const</span>;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md585"></a>
&lt;tt&gt;get_statistics&lt;/tt&gt;</h4>
<div class="fragment"><div class="line"><span class="keyword">struct </span>statistics_snapshot {</div>
<div class="line">    uint64_t messages_processed;</div>
<div class="line">    uint64_t messages_succeeded;</div>
<div class="line">    uint64_t messages_failed;</div>
<div class="line">    uint64_t stage_failures;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">statistics_snapshot get_statistics() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">void</span> reset_statistics();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md586"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;kcenon/messaging/patterns/message_pipeline.h&gt;</span></div>
<div class="line"> </div>
<div class="line">message_pipeline pipeline(bus, <span class="stringliteral">&quot;input.raw&quot;</span>, <span class="stringliteral">&quot;output.processed&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add validation stage</span></div>
<div class="line">pipeline.add_stage(<span class="stringliteral">&quot;validate&quot;</span>, [](<span class="keyword">const</span> message&amp; msg) -&gt; common::Result&lt;message&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (msg.metadata().topic.empty()) {</div>
<div class="line">        return common::err&lt;message&gt;(</div>
<div class="line">            common::error_info::create(-1, <span class="stringliteral">&quot;Invalid message&quot;</span>)</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> common::ok(message(msg));</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add transformation stage</span></div>
<div class="line">pipeline.add_stage(<span class="stringliteral">&quot;transform&quot;</span>, [](<span class="keyword">const</span> message&amp; msg) -&gt; common::Result&lt;message&gt; {</div>
<div class="line">    message transformed(msg);</div>
<div class="line">    transformed.metadata().priority = message_priority::high;</div>
<div class="line">    <span class="keywordflow">return</span> common::ok(std::move(transformed));</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add enrichment stage (optional - failures won&#39;t stop pipeline)</span></div>
<div class="line">pipeline.add_stage(<span class="stringliteral">&quot;enrich&quot;</span>, [](<span class="keyword">const</span> message&amp; msg) -&gt; common::Result&lt;message&gt; {</div>
<div class="line">    message enriched(msg);</div>
<div class="line">    enriched.metadata().source = <span class="stringliteral">&quot;pipeline-processor&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> common::ok(std::move(enriched));</div>
<div class="line">}, <span class="keyword">true</span>);  <span class="comment">// Mark as optional</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start automatic processing</span></div>
<div class="line">pipeline.start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or manually process</span></div>
<div class="line">message input(<span class="stringliteral">&quot;test.topic&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> result = pipeline.process(std::move(input));</div>
<div class="line"><span class="keywordflow">if</span> (result.is_ok()) {</div>
<div class="line">    <span class="keyword">auto</span> output = result.unwrap();</div>
<div class="line">    <span class="comment">// Use processed message</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check statistics</span></div>
<div class="line"><span class="keyword">auto</span> stats = pipeline.get_statistics();</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Processed: &quot;</span> &lt;&lt; stats.messages_processed &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Succeeded: &quot;</span> &lt;&lt; stats.messages_succeeded &lt;&lt; std::endl;</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Failed: &quot;</span> &lt;&lt; stats.messages_failed &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md587"></a>
Class: &lt;tt&gt;pipeline_builder&lt;/tt&gt;</h2>
<p>Builder pattern for constructing pipelines.</p>
<h3><a class="anchor" id="autotoc_md588"></a>
Constructor</h3>
<div class="fragment"><div class="line"><span class="keyword">explicit</span> pipeline_builder(std::shared_ptr&lt;message_bus&gt; bus);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md589"></a>
Methods</h3>
<h4><a class="anchor" id="autotoc_md590"></a>
&lt;tt&gt;from&lt;/tt&gt; / &lt;tt&gt;to&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">pipeline_builder&amp; from(std::string topic);</div>
<div class="line">pipeline_builder&amp; to(std::string topic);</div>
</div><!-- fragment --><p> Sets input and output topics.</p>
<h4><a class="anchor" id="autotoc_md591"></a>
&lt;tt&gt;add_stage&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">pipeline_builder&amp; add_stage(</div>
<div class="line">    std::string name,</div>
<div class="line">    message_processor processor,</div>
<div class="line">    <span class="keywordtype">bool</span> optional = <span class="keyword">false</span></div>
<div class="line">);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md592"></a>
&lt;tt&gt;add_filter&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">pipeline_builder&amp; add_filter(</div>
<div class="line">    std::string name,</div>
<div class="line">    std::function&lt;<span class="keywordtype">bool</span>(<span class="keyword">const</span> message&amp;)&gt; filter</div>
<div class="line">);</div>
</div><!-- fragment --><p> Adds a filter stage (messages that don't match are dropped).</p>
<h4><a class="anchor" id="autotoc_md593"></a>
&lt;tt&gt;add_transformer&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">pipeline_builder&amp; add_transformer(</div>
<div class="line">    std::string name,</div>
<div class="line">    std::function&lt;message(<span class="keyword">const</span> message&amp;)&gt; transformer</div>
<div class="line">);</div>
</div><!-- fragment --><p> Adds a transformation stage.</p>
<h4><a class="anchor" id="autotoc_md594"></a>
&lt;tt&gt;build&lt;/tt&gt;</h4>
<div class="fragment"><div class="line">common::Result&lt;std::unique_ptr&lt;message_pipeline&gt;&gt; build();</div>
</div><!-- fragment --><p> Builds and returns the configured pipeline.</p>
<h3><a class="anchor" id="autotoc_md595"></a>
Usage Example</h3>
<div class="fragment"><div class="line">pipeline_builder builder(bus);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> pipeline_result = builder</div>
<div class="line">    .from(<span class="stringliteral">&quot;input.orders&quot;</span>)</div>
<div class="line">    .to(<span class="stringliteral">&quot;output.validated_orders&quot;</span>)</div>
<div class="line">    .add_filter(<span class="stringliteral">&quot;high_value_only&quot;</span>, [](<span class="keyword">const</span> message&amp; msg) {</div>
<div class="line">        <span class="comment">// Custom filter logic</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// Keep message</span></div>
<div class="line">    })</div>
<div class="line">    .add_transformer(<span class="stringliteral">&quot;add_timestamp&quot;</span>, [](<span class="keyword">const</span> message&amp; msg) {</div>
<div class="line">        message transformed(msg);</div>
<div class="line">        transformed.metadata().timestamp = std::chrono::system_clock::now();</div>
<div class="line">        <span class="keywordflow">return</span> transformed;</div>
<div class="line">    })</div>
<div class="line">    .add_stage(<span class="stringliteral">&quot;validate&quot;</span>, [](<span class="keyword">const</span> message&amp; msg) -&gt; common::Result&lt;message&gt; {</div>
<div class="line">        <span class="comment">// Validation logic</span></div>
<div class="line">        <span class="keywordflow">return</span> common::ok(message(msg));</div>
<div class="line">    })</div>
<div class="line">    .build();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (pipeline_result.is_ok()) {</div>
<div class="line">    <span class="keyword">auto</span> pipeline = pipeline_result.unwrap();</div>
<div class="line">    pipeline-&gt;start();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md596"></a>
Namespace: &lt;tt&gt;pipeline_stages&lt;/tt&gt;</h2>
<p>Common pipeline stage implementations.</p>
<h3><a class="anchor" id="autotoc_md597"></a>
&lt;tt&gt;create_logging_stage&lt;/tt&gt;</h3>
<div class="fragment"><div class="line">message_processor create_logging_stage(<span class="keyword">const</span> std::string&amp; stage_name);</div>
</div><!-- fragment --><p> Creates a stage that logs messages passing through.</p>
<h3><a class="anchor" id="autotoc_md598"></a>
&lt;tt&gt;create_validation_stage&lt;/tt&gt;</h3>
<div class="fragment"><div class="line">message_processor create_validation_stage(</div>
<div class="line">    std::function&lt;<span class="keywordtype">bool</span>(<span class="keyword">const</span> message&amp;)&gt; validator</div>
<div class="line">);</div>
</div><!-- fragment --><p> Creates a stage that validates messages.</p>
<h3><a class="anchor" id="autotoc_md599"></a>
&lt;tt&gt;create_enrichment_stage&lt;/tt&gt;</h3>
<div class="fragment"><div class="line">message_processor create_enrichment_stage(</div>
<div class="line">    std::function&lt;<span class="keywordtype">void</span>(message&amp;)&gt; enricher</div>
<div class="line">);</div>
</div><!-- fragment --><p> Creates a stage that enriches messages with additional data.</p>
<h3><a class="anchor" id="autotoc_md600"></a>
&lt;tt&gt;create_retry_stage&lt;/tt&gt;</h3>
<div class="fragment"><div class="line">message_processor create_retry_stage(</div>
<div class="line">    message_processor processor,</div>
<div class="line">    <span class="keywordtype">size_t</span> max_retries = 3,</div>
<div class="line">    std::chrono::milliseconds retry_delay = std::chrono::milliseconds{100}</div>
<div class="line">);</div>
</div><!-- fragment --><p> Wraps a processor with retry logic.</p>
<h3><a class="anchor" id="autotoc_md601"></a>
Usage Example</h3>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>pipeline_stages;</div>
<div class="line"> </div>
<div class="line">message_pipeline pipeline(bus, <span class="stringliteral">&quot;input&quot;</span>, <span class="stringliteral">&quot;output&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add logging stage</span></div>
<div class="line">pipeline.add_stage(<span class="stringliteral">&quot;log_input&quot;</span>, create_logging_stage(<span class="stringliteral">&quot;InputLogger&quot;</span>));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add validation stage</span></div>
<div class="line"><span class="keyword">auto</span> validator = [](<span class="keyword">const</span> message&amp; msg) {</div>
<div class="line">    <span class="keywordflow">return</span> !msg.metadata().topic.empty();</div>
<div class="line">};</div>
<div class="line">pipeline.add_stage(<span class="stringliteral">&quot;validate&quot;</span>, create_validation_stage(validator));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add enrichment stage</span></div>
<div class="line"><span class="keyword">auto</span> enricher = [](message&amp; msg) {</div>
<div class="line">    msg.metadata().source = <span class="stringliteral">&quot;pipeline&quot;</span>;</div>
<div class="line">    msg.metadata().timestamp = std::chrono::system_clock::now();</div>
<div class="line">};</div>
<div class="line">pipeline.add_stage(<span class="stringliteral">&quot;enrich&quot;</span>, create_enrichment_stage(enricher));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add retry wrapper for flaky operation</span></div>
<div class="line"><span class="keyword">auto</span> flaky_operation = [](<span class="keyword">const</span> message&amp; msg) -&gt; common::Result&lt;message&gt; {</div>
<div class="line">    <span class="comment">// Operation that might fail temporarily</span></div>
<div class="line">    <span class="keywordflow">return</span> common::ok(message(msg));</div>
<div class="line">};</div>
<div class="line">pipeline.add_stage(<span class="stringliteral">&quot;process&quot;</span>, create_retry_stage(flaky_operation, 3));</div>
<div class="line"> </div>
<div class="line">pipeline.start();</div>
</div><!-- fragment --><hr  />
<h1><a class="anchor" id="autotoc_md603"></a>
Best Practices</h1>
<h2><a class="anchor" id="autotoc_md604"></a>
Pub/Sub Pattern</h2>
<ul>
<li>Use topic wildcards (<code>*</code>, <code>#</code>) for flexible subscription patterns</li>
<li>Apply message filters to reduce callback invocations</li>
<li>Set appropriate default topics to simplify publishing</li>
</ul>
<h2><a class="anchor" id="autotoc_md605"></a>
Request-Reply Pattern</h2>
<ul>
<li>Always set reasonable timeouts for requests</li>
<li>Use correlation IDs to track request-reply pairs</li>
<li>Handle timeout errors gracefully on the client side</li>
<li>Process requests asynchronously on the server side</li>
</ul>
<h2><a class="anchor" id="autotoc_md606"></a>
Event Streaming Pattern</h2>
<ul>
<li>Configure buffer size based on replay requirements</li>
<li>Use filters to optimize replay performance</li>
<li>Consider batch processing for high-throughput scenarios</li>
<li>Enable persistence for critical event streams</li>
</ul>
<h2><a class="anchor" id="autotoc_md607"></a>
Message Pipeline Pattern</h2>
<ul>
<li>Keep stages focused on single responsibilities</li>
<li>Use optional stages for non-critical operations</li>
<li>Monitor pipeline statistics to identify bottlenecks</li>
<li>Use the builder pattern for complex pipelines</li>
<li>Apply retry logic for transient failures</li>
</ul>
<h2><a class="anchor" id="autotoc_md608"></a>
General Guidelines</h2>
<ul>
<li>Always check Result return values</li>
<li>Use appropriate message priorities</li>
<li>Set message TTL for time-sensitive messages</li>
<li>Leverage the DI container for dependency management</li>
<li>Monitor message bus statistics for performance tuning</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md610"></a>
Error Handling</h1>
<p>All pattern APIs use the <code>common::Result&lt;T&gt;</code> pattern for error handling:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> result = publisher.publish(msg);</div>
<div class="line"><span class="keywordflow">if</span> (result.is_err()) {</div>
<div class="line">    <span class="keyword">auto</span> error = result.get_error();</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Publish failed: &quot;</span> &lt;&lt; error.message</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot; (code: &quot;</span> &lt;&lt; error.code &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Common error codes are defined in <code>kcenon::common::error::codes::messaging_system</code>.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md612"></a>
Thread Safety</h1>
<ul>
<li>All pattern classes are thread-safe unless otherwise noted</li>
<li>Message bus can be safely accessed from multiple threads</li>
<li>Callbacks may be invoked from worker threads - ensure thread-safe access to shared state</li>
<li>Use appropriate synchronization primitives in callback implementations</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md614"></a>
Performance Considerations</h1>
<ul>
<li><b>Pub/Sub</b>: Lightweight for simple publish-subscribe scenarios</li>
<li><b>Request-Reply</b>: Adds overhead for correlation tracking - use only when synchronous semantics are required</li>
<li><b>Event Streaming</b>: Buffer size affects memory usage - tune based on replay requirements</li>
<li><b>Message Pipeline</b>: Each stage adds processing overhead - minimize stage count for latency-critical paths</li>
</ul>
<p>For high-performance scenarios, consider:</p><ul>
<li>Using lock-free queue implementations</li>
<li>Tuning worker thread counts</li>
<li>Adjusting queue capacities</li>
<li>Enabling batch processing for bulk operations </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
